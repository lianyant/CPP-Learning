# 7.2 炫技写法  

在面试的时候，不免会碰到一些古里古怪的问题，个别面试官是为了炫技或通过难为你以得到一种快感。但是不管遇到哪种情况，作为应聘者，都需要微笑面对，从容应答，否则这份工作一定不会属于你。  

## 7.2.1不能被继承的类  

读者都知道， $\mathrm{C++11}$ 中提供final关键字使得类不能够被继承。那么，如何在不用final关键字的情况下，实现一个不能被继承的类呢？  

听说可以用友元函数 + 虚继承来实现，在这里就试一试。但这种实现方式有它的副作用：友元是破坏封装的。虚继承的消耗是比较大的，只有非常必要的情况下才去使用。  

在MyProject.cpp的上面，增加如下代码行：  

``` cpp
class A  
{  
private:  
    A() {}  
    friend class B; //B可以调用A的私有构造函数  
};  
class B : public  A  
{  
public:  
    int m_b;  
};  
class C :public B  
{  
public:  
    int m_c;  
};
```

在main主函数中加人如下代码：  

``` cpp
B myobjb;  
myobjb.m_b = 15;  
  
C myobjc;  
myobjc.m_c = 20;
```

编译一下，可以成功，因为B类是A类的友元类，B类构造函数可以调用A类构造函数，所以能成功构造出B对象来。  

但是，如果希望B类不能被继承，现在显然没达到目的，因为B类现在能够被C类继承。怎么办呢？  

解决办法就是用B类虚继承A类。代码如下

``` cpp
class B : virtual public A //虚继承A  
{  
... 
};
```

现在再次编译，会发现Cmyobjc；代码行变得不合法了。  

读者都知道，虚基类A的构造函数是由孙子来调用，也就是由C类来调用的，但是虚基类A的构造函数是私有的，只有友元类B能调用，孙子类C无法调用，这样就无法创建出C类对象来。  

最终结果就是B类对象可以被正常构造，但是继承B的C类对象无法被正常构造，可以认为这个B类就是最终想得到的无法被继承的类。  

## 7.2.2类外调用私有虚成员函数  

有些人比较喜欢炫技，所以会写出下面的代码，笔者完全不提倡这种写法。现在，拿到这里进行讲解，目的是避免将来读者真碰到这样的考题时会感到茫然无措。  

注释掉以往的所有代码，在MyProject.cpp的上面，增加如下代码行：  

``` cpp
class A  
{  
private:  
    virtual void virfunc()  
    {  
       myfunc();  
    }  
    void myfunc()  
    {  
       cout << "A::myfunc()运行了" << endl;  
    }  
};
```

观看上面代码不难看到，虚函数virfunc是私有的。私有的虚函数是否能被调用呢？其实能调用，于是有人就写出了非常难看的代码。在main主函数中，加人如下代码：  

``` cpp
A aobj;  
(reinterpret_cast<void(*)()>(**(int**)(&aobj)))();
```

执行起来，看一看结果：  

``` cpp
A：：myfunc（）运行了
```

根据结果可以看到，正常调用了虚函数。  

毫无疑问，上面的代码很难看，但实际上做的事情就是通过虚函数表调用虚函数，这里所有用到的知识前面都讲解过。回忆一下3.2节，曾经详细写过手工调用虚函数的代码，不知读者是否还记得。  

其实，上面这段这么难看的代码就是手工调用虚函数的代码，把这些代码都写到一起，结果就这么长，这么难看。把这一行难看的代码拆解一下看。  

（1）A是空类，但因为其中有虚函数，因此sizeof值是4字节，这4字节正好是虚函数表指针。这就好办了：  
```cpp
long * pvptr = (long *)& aobj;
    // 把对象 aoobj 地址拿到
```

（2）拿到虚函数表指针：  
```cpp
long* vptr = (long*)(*pvptr);
// 把对象 aobj 地址中的内容(虚函数表指针)拿到，现在 vptr 就指向了虚函数表
```
（3）定义一个函数指针类型：  
```cpp
typedef void ( * Func)(void);
//定义一个函数指针类型
```

（4）将函数指针f赋值为第一个虚函数地址：  

``` cpp
Func f = (Func)vptr[0];
//将函数指针 f 赋值为第一个虚函数地址
```

（5）调用虚函数：  

``` cpp
f();
//调用虚函数
```

到此为止，main主函数中这行难看的代码分解一下，就是上面这几句。  

这里笔者就不多讲，也不提倡这样写。  

总之，这种通过虚函数表指针直接调用虚函数的写法，就好像一个房间本来是有门的，但非不从门走，而从窗户进。绕过了编译器的检查机制，对于研究虚函数表这个话题和技术有意义，但对实际应用没有什么意义。
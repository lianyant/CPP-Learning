# 4.1数据成员绑定时机  

## 4 数据语义学  

本章主要讲解类对象的数据布局，着重讲解虚函数存在的情况下类对象的数据布局。同时，本章也详细描述了虚基类表指针和虚基类表的概念与实现细节，并继续详述虚基类存在时类对象的数据布局。  

通过本章的学习，读者可以详细地了解一个类对象在内存中如何存储，成员的存储顺序是怎样的，在单一继承与多重继承的情况下，this指针如何调整，以及成员变量偏移值等概念。  

---

## 4.1.1成员函数函数体的解析时机（整个类定义完毕后）  

看看如下范例。在MyProject，cpp的上面，增加如下代码行：  

``` cpp
string myvar;  //定义全局量，字符串型  
  
//定义一个类  
class A  
{  
public:  
    int myfunc()   
    {  
       return myvar;   
    }   
private:  
    int myvar; //同全局量同名的成员变量  
};
```

编译一下，没有报错。看一下这个myfunc成员函数，代码中，它返回的是myvar。现在的问题是，有一个全局量叫myvar，而类A中也有一个成员变量叫myvar，而这两者的类型并不相同。显然，在myfunc成员函数中返回的myvar编译器认为是类A的成员变量myvar，因为myfunc返回类型是int类型，而只有类A的成员变量myvar是int类型。  

编译器为什么不认为成员函数myfunc返回的myvar变量是全局的myvar变量呢？  

这是因为，编译器对myfunc的解析是整个类A定义完毕后才开始的，所以，对这个myvar成员变量的解析和绑定操作，也是在这个类定义完成之后才发生。这个类定义完成了，编译器会优先在类中找myvar。所以，这个myvar指的是类A中定义的myvar成员变量。  

现在修改一下代码，将myfunc成员函数的函数体写在类定义的外面：  

``` cpp
int A::myfunc()  
{  
    return myvar;  
}
```

那这里的myvar是全局的myvar还是类中的myvar成员变量呢？  

可能许多读者认为是全局的myvar变量，实际上还是类A中的成员变量myvar，编译器很聪明，遇到成员函数体内的变量时，会先到类中去找，如果找不到，才会到全局范围去找。  

那么，如果要在A：：myfunc的函数体中访问全局的myvar变量该怎么做？只需要在myvar前面增加：：就可以了，这就表示全局的myvar变量。当然，全局的myvar变量是string类型，所以在A：：myfunc的函数体中返回全局的myvar，编译肯定不通过，会报错。  

如果再写一个全局函数，也返回myvar，看以下代码：  

``` cpp
int  myfunc()  
{  
    return myvar;  
}
```


编译一下，发现会报错，因为在这个函数中找到的是全局的myvar，把鼠标放到myvar上，看弹出的浮动提示，发现编译器找到的确实是stringmyvar。但myfunc全局函数要求返回的是int类型，所以编译肯定报错。  

编译器确实挺智能的，在成员函数中，它找的就是类定义里面的成员变量；在全局函数中，它找的就是全局范围的成员变量。  

以上所讲，最核心的要意是一句话：  

编译器对成员函数myfunc的解析是整个A类定义完毕后才开始的。因为只有整个类A定义完毕后，编译器才能看到类A中的myvar，才能根据实际的需要把出现myvar的场合做上述的适当的解析（成员函数中解析成类中的myvar，全局函数中解析成全局的myvar）。  

## 4.1.2-成员函数参数类型的确定时机（最近碰到原则）  

上面看了一下成员函数的返回值的问题，现在看一下参数列表的问题。为了简单起见，把以往所有的演示代码全部注释掉，下面的演示重新写代码。  

在MyProject.cpp的上面，增加如下代码行：  

``` cpp
typedef string mytype;  
class A  
{  
    typedef int mytype;  
public:  
    void myfunc(mytype tmpvalue);  
    void myfunc(mytype tmpvalue) //这个mytype是string类型  
    {  
       m_value = tmpvalue;  
    }  
  
private:  
    typedef int mytype;  
    mytype m_value;    //这个mytype是int类型   };
```


编译一下，报错，分析一下会发现myfunc中的tmpvalue是string类型，而 $\mathbf{m_{\pm}}$ value是int类型，string类型变量不能给int类型变量赋值。  

现在修改一下代码，将myfunc成员函数的函数体写在类定义的外面：  

``` cpp
void A::myfunc(mytype tmpvalue) //这个mytype又变成了int类型，但若在类中定义myfunc，那么参数中出现的mytype是string类型  
{  
    m_value = tmpvalue;  
}
```


编译一下，依然会报错，因为现在的情况是，在类A内部声明的myfunc的形参t mp value string，A my fun c t mp value in t 型，显然两者形参类型不一致。  

但如果是一个普通的全局函数，编译就不会报错：  

``` cpp
void myfunc(mytype tmpvalue)//这个mytype就是string类型  
{  
    string mvalue = tmpvalue;  
}
```

所以为什么说编译器挺智能的，因为遇到类成员函数，它就把mytype解析成类内的int类型，否则它就解析成全局的string类型。  

现在问题的焦点在于类内声明的这行代码：  

``` cpp
void myfunc(mytype tmpvalue);
```

将光标放到mytype上，根据弹出的浮动提示，mytype的类型被解析成了string类型，现在的编译错误是因为mytype被解析成了string类型引发的，那么，为什么mytype被解string。  

通过种种观察，可以得到一些结论：  

成员函数的参数类型是在编译器最近一次遇到mytype时决定的，从上往下看代码，最近一次遇到mytype的时候，编译器只看到了：  

``` cpp
typedef string my type;
```

没有看到类中的：

``` cpp
typedef int mytype;  
```

所以，为了在类中“最近”看到类型mytype，类中的这种类型定义语句（typedef）一定要挪到类内的开始位置来定义，这样，后面的成员函数遇到这个类型时，它就本着最近碰到的类型的原则来应用最近碰到的类型。以后读者写程序的时候也要注意并遵守这个规则。  

所以，根据最近碰到的类型的原则，只需要在类A中把mytype类型的定义提到类A的最前面，一切问题就迎刃而解：  

``` cpp
class A  
{  
    typedef int mytype;
    ...
};
```

当然，对于全局的myfunc函数的形参类型，依旧会解释成string类型，因为是全局函数，不可能解释成类A内的int类型。
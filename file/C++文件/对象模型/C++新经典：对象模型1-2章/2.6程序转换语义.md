# 2.6程序转换语义  

程序转换语义，就是程序员书写的一些代码，编译器在处理的时候，会进一步把这些代码拆分，拆分成更容易被理解和被实现的代码。  

换句话说，现在要研究的是程序员所写的代码，编译器会如何去解析的问题。所以本节内容不但会站在程序员的角度，也会站在编译器的角度，研究一下编译器的做法，通过这样的分析，对编译器的工作步骤有更进一步的了解。  

本节需要在“程序员看代码”的视角和“编译器看代码的视角”之间不断切换。  

## 2.6.1定义时初始化对象  

看看如下范例。在MyProject.cpp前面，增加一个X类的定义：  

``` cpp
class X  
{  
public:  
    int m_i;  
    X(const X& tmpx)  
    {  
       m_i = tmpx.m_i;  
       cout << "X类的拷贝构造函数被调用" << endl;  
    }  
    X()  
    {  
       m_i = 0;  
       cout << "X类的构造函数被调用" << endl;  
    }  
};
```

在main主函数中，加人如下代码：  

``` cpp
X x0;  
x0.m_i = 15;  
X x1 = x0;  
X x2(x0);  
X x3 = x0;
```

执行起来，看一看结果：  

``` cpp
X类的构造函数被调用
X类的拷贝构造函数被调用
X类的拷贝构造函数被调用
X类的拷贝构造函数被调用  
```

因为读者对C++都很熟悉，所以上面的结果不难理解。这里就以Xx3=x0；代码行为例，谈一下这种定义时初始化的操作（下面把x3换名为x3_2以方便代码演示）。

编译器遇到这种代码时，它会拆分成两个步骤。切换成编译器的视角看一看。

（1）定义一个对象，为对象分配内存，但这里编译器内部并没有调用构造函数。如果以编译器的眼光看Xx3_2，则不会调用构造函数，除非编译器主动增加x3_2.X：：X（）；这种代码行到现有的代码中： 

``` cpp
X x3_2;
```


（2）直接调用对象的拷贝构造函数：  

``` cpp
x3_2.X::X(x0);
```

读者可以把上面这两行代码输入到程序中，运行起来注意观察结果。可以看到，在原有结果的基础之上，多了两行结果：  

``` cpp
X类的构造函数被调用
X类的拷贝构造函数被调用  
```

这两行结果中的第一行多调用了一个构造函数，因为这是程序员自己写的代码。实际编译器在处理的时候并不会调用X类的构造函数，所以实际上是看不到第一行结果的。最终能看到的是第二行结果“×类的拷贝构造函数被调用”。  

## 2.6.2参数的初始化  

继续给X类增加一个public修饰的析构函数：  

``` cpp
public:  
    ~X()  
    {  
       cout << "X类的析构函数被调用" << endl;  
    }
```

再增加一个普通函数：  

``` cpp
void func(  
{  
    return;  
}
```



在main主函数中，注释掉以往代码，增加如下代码：  

``` cpp
X x0;  
func(x0); //程序员视角（现代编译器视角）
```

执行起来，看一看结果：  

``` cpp
X类的构造函数被调用 
X类的拷贝构造函数被调用
X类的析构函数被调用
X类的析构函数被调用  
```

从上面这个结果不难理解，当把实参传递给形参时，调用了X类的拷贝构造函数。  

上面这两行代码的执行结果与下面这两行代码一样（都是调用了一次构造函数和一次拷贝构造函数）：  

``` cpp
X x0;  
X tmpx = x0;
```

对于代码行func（ ${\bf x}0)$ ）：，编译器是在func这个函数的空间内构造出来了tmpx对象，然后在func函数返回之前，再把tmpx对象析构掉。  

对于比较老（早期）的编译器，上面对func函数的调用可能就更加烦琐，站在老编译器的视角看一看（再次提醒：站在编译器视角来说，类的构造、复制构造、析构等函数都不会自动去调用）：  

//以下这些可以认为是伪代码，并不代表在当代编译器上能够正确运行，只是借此了解编译器内部具体都做了什么

``` cpp
X tmpobj;  //编译器产生出来一个临时对象  
tmpobj.X::X(x0); //调用拷贝构造函数  
func(tmpobj); //用临时对象调用func  
tmpobj.X::~X(); //func()被调用完成后，析构函数被调用
```

func函数的参数站在老编译器的角度也会做出调整，变成了引用：  

``` cpp
void func(X &tmpx)  
{  
    return;  
}
```

上面这种老编译器视角相当于把func函数的参数率先在调用func函数之前就构造出来，然后再传递到func函数中。  

所以，读者可以看到，程序员写的一行代码，编译器往往会转换成多行代码实现相应的功能。同时也感觉到了老编译器实现一些代码的笨拙和编译器的不断进化。  

## 2.6.3返回值初始化  

注释掉以往的代码，在MyProject.cpp前面，增加如下代码：  

``` cpp
X func()  
{  
    X x0;  
    //......  
    return x0;  
}
```

在main主函数中，增加如下代码：  

```cpp
X my = func();
```

执行起来，看一看结果：  

``` cpp
X类的构造函数被调用
X类的拷贝构造函数被调用
X类的析构函数被调用
X类的析构函数被调用
```

读者可以设置断点跟踪调试并观察结果。笔者假设读者对 $\mathrm{C++}$ 的开发知识掌握的已经比较好。所以，对上面的结果也会很明了。  

在上面代码的func函数中，因为return x0；语句行的出现，产生了临时对象，这个临时对象就直接构造到了my中，也就是说可以把my看成是这个临时对象。

站在程序员的角度，上面的解释和理解是对的。那么，看一看编译器是怎样理解和处理这些代码的。  

切换成编译器视角，如下是一种编译器的理解方法：  

``` cpp
void func(X& extra)  //1：安插一个引用参数  
{  
    X x0;  //这个在我们看来之所以能调用构造函数，是因为编译器内部有诸如x0.X::X()这种代码  
    //..  
    extra.X::X(x0);  //2：return之前安插一个对拷贝构造函数的调用  
    //return x0;  
    return;  
}
```

main主函数中代码从编译器的视角看应该是这样的：  

``` cpp
X my; //从编译器的视角看，这里是不调用构造函数的,除非编译器主动增加代码my.X::X();  
func(my);
```

观看从编译器的视角生成的这些代码，感觉更容易理解。
现在，再给X类增加一个public修饰的成员函数：

``` cpp
public:  
    void functest()  
    {  
       cout << "functest()成员函数被调用" << endl;  
    }
```

现在，切换回程序员视角。在main主函数中，加人下面代码行：  

``` cpp
func().functest();
```

func函数的程序员视角内容保持不变（前面的Xfunc（）（··）
此时，看一看编译器视角下的main主函数中的代码变成什么样子：

``` cpp
X my;  
(func(my), my).functest(); //逗号表达式，先求解表达式1，再求解表达式2，整个表达式的值是表达式2的值
```

func函数的编译器视角内容保持不变(前面的 void func(X&.  extra){…}) 继续，切换回程序员视角。在main主函数中，加入下面代码行：

``` cpp
X(*pf)();   //定义函数指针  
pf = func;  
pf().functest();
```

此时，看一看编译器视角下的main主函数中的代码变成什么样子：  

``` cpp
X my;  
void (*pf)(X&);  
pf = func;  
pf(my);  
my.functest();
```
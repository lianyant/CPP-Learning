# 2.7模板代码的组织结构与模板的显式实例化和声明  

## 2.7.1模板代码的组织结构  

读者都知道，在实际的项自开发中，对于一个普通的类，常规的书写规范是把类定义和类实现放在分开的.h头文件和.cpp源文件中。例如，在myclass.h中可以这样写：  

``` cpp
#ifndef __MYCLASS_H__  
#define __MYCLASS_H__  
  
template <typename T>  
class MYClass  
{  
public:  
    void func();  
};  
#endif
```

在mvclass.cpp中可以这样与：  

``` cpp
#include <iostream>  
#include "myclass.h"  
using namespace std;  
  
template <typename T>  
void MYClass::func()  
{  
    cout << "MYClass::func成员函数执行了!" << endl;  
}
```

这里读者要注意把myclass.cpp加人MyProject项目中，如果读者不熟悉如何加人，请通过搜索引擎了解如何在Visual Studio中将一个.cpp文件加人当前项目。  

在其他.cpp源文件中，如果要使用 MYClass类，如在main()主函数所属的 MyProjectcpp MY Class，My Project.cpp上面位置增加#include my classh头文件：  

``` cpp
#include "myclass.h" 
```


这样，在main（主函数中就可以使用MYClass类了。

``` cpp
MYClass mycls;  
mycls.func();
```

那么，如法炮制，如果将 MYClass修改为一个类模板，也这样组织代码。试一下，修改myclass.h中的代码：  

``` cpp
#ifndef __MYCLASS_H__  
#define __MYCLASS_H__  
  
template <typename T>  
class MYClass  
{  
public:  
    void func();  
};
#endif
```
修改myclass.cpp中的代码：  

``` cpp
#include <iostream>  
#include "myclass.h"  
using namespace std;  
  
template <typename T>  
void MYClass<T>::func()
{  
    cout << "MYClass::func成员函数执行了!" << endl;  
}
```

在main（）主函数中，修改刚刚加人的两行代码（只需要修改第1行）：  

``` cpp
MYClass<int> mycls;  
mycls.func();
```

编译项目，此时会发现出现链接错误：  

``` cpp
public: void thiscall MYClass<int>: func(void)" (?funce?SMYClass@H@@QAEXxZ). 该符号在函数_main中被引用
```

这个链接报错的主要原因读者应该有所了解。类模板的定义并不会导致编译器生成相关代码(实例化)，只有使用这个类模板时，编译器才会实例化一个特定版本的类并生成类相关代码（函数模板也同样适合这些说法）。详细一点可以理解如下。  

（1）因为 main()主函数位于MyProject.cpp 源文件中，编译器是针对每个.cpp 源文件作为一个编译单元进行编译，所以编译器要编译 MyProject.cpp 源文件。  

（2）编译器遇到main（）MY Class`<int>`mycls;MY Class模板实例化出MYClass`<int>`类（否则编译器不会无缘无故实例化出MYClass`<int>`）。但因为在MyProject.cpp源文件代表的这个编译单元找不到MYClass类模板的实现代码（实现代码在myclass.cpp中），因此实际上无法实例化出MYClass`<int>`类，编译器并不会因此而报错，而是会假设在其他的编译单元中可能实例化出了该类（虽然这个编译单元无法实例化出该类，但其他编译单元也许能够实例化出该类，所以需要到链接的时候再具体找一找到底是否实例化出了该类）。  

（3）链接的时候需要链接MYClass`<int>`类（不然代码行MYClass`<int>`mycls;无法执行），因为在各个目标文件中找不到该类，所以编译器会报链接错误。  

（4）当然，可能在多个编译单元（多个用到了实例化后的MYClass`<int>`类的.cpp源文件）中都对MYClass`<int>`进行了实例化，链接的时候，编译器会进行多选一（重复的会被忽略掉），这种实例化的方式也叫贪婪实例化，程序员不需要担心。  

总之，编译器生成代码的时候，需要能够找到类模板的代码实现部分，所以，类模板的定义和实现通常都放在.h头文件中而不能把定义和实现代码分开。具体说来，就是把myclass.cpp去掉，其中的内容移入myclass.h中。那么，新的myclass.h文件内容大概如下。  

```cpp
# ifndef __MYCLASS_H__
# define __MYCLASS_H__

#include <iostream>

// 模板的定义
template <typename T>
class MyClass
{
public:
    void func();
};

// 模板的实现
template <typename T>
void MyClass<T>::func()
{
    std::cout << MYClass::func 成员函数执行了! << std::endl;
}

# endif
```

这里值得注意的是，如果MYClass类模板有特化版本，那么特化版本一般也应该紧跟在泛化版本之后（上面的代码之后，但要放在#endif行之前），如下面的特化（是个全特化）版本：  

``` cpp
//特化版本  
template <>  
class MYClass<int>  
{  
public:  
    void func();  
};  
void MYClass<int>::func() //这行的前面不需要template <>  
{  
    std::cout << "MYClass<int>::func成员函数执行了!" << std::endl;  
}
```

上面谈到了类模板的定义和实现，函数模板也一样，定义和实现也都放在.h头文件中。具体范例笔者就不列举了，理念上与类模板相同。  

## 2.7.2模板的显式实例化、模板声明、代码组织结构  

为了避免影响本节内容的演示，请确保将上面讲解时用到的myclass.h和myclass.cpp文件从项目中移除（如果不熟悉如何移除，请通过搜索引擎了解如何在VisualStudio中将一个.cpp文件从当前项目中移除，其实只需要选中对应文件然后按Delete键)，同时也移除MyProject.cpp MY Class。  

通过前面的学习已经知道，模板只有被使用时才会被实例化。  

但是现在有这样一个问题，一个项目中可能有多个.cpp 源码文件（也可能是其他扩展名的源码文件），这里为讲解方便，创建一个叫作 test.cpp 的源码文件并加人项目中。  

再创建一个 ca.h头文件，加人如下类模板A的定义代码。而后在 MyProject.cpp 和test.cpp 的顶部包含这个头文件。这样，两个.cpp 源文件就都可以使用这个类模板了。现在分别确定一下几个文件的内容。  

ca.h头文件内容如下。  

``` cpp
#ifndef __CAH__  
#define __CAH__  
template <typename C>  
class A  
{  
      
public:  
    template <typename T2>  
    A(T2 v1, T2 v2);  
  
    template <typename T>  
    void myft(T tmpt)  
    {  
       std::cout << tmpt << std::endl;  
    }  
    C m_ic;  
};  
template <typename C>  
template <typename T2>  
A<C>::A(T2 v1, T2 v2)  
{  
    std::cout << v1 << v2 << std::endl;  
}  
  
  
#endif
```

test.cpp源文件内容如下（注意其中有一个新函数mfunc()）。  

``` cpp
#include <iostream>  
#include <vector>  
#include "ca.h"  
using namespace std;  
  
void mfunc()  
{  
    A<float> a(1, 2);    
    a.myft(3);  
}
```

MyProject.cpp源文件内容如下。  

``` cpp
#include <iostream>  
#include "ca.h"  
using namespace std;
int main()  
{  
    A<float> a(1, 2);  
    A<float> a2(1.1, 2.2);  
    a.myft(3); //3  
	return 0;
  
}
```

现在，要编译这个项目，已经知道的事实是：这些.cpp源文件对于编译器都是独立编译的（每个.cpp源文件编译后都生成一个.obj文件，多个.cpp源文件编译后自然生成多个.obj文件）。  

当这两个.cpp源文件中的A`<float>`a(1，2);代码行在编译的时候，因为每个.cpp源文件独立编译，所以编译器在MyProject.cpp中会实例化出一个A`<float>`类（也可以叫类模板A的一个实例)，在test.cpp中也会实例化出一个A`<float>`类，可以使用dumpbin工具查看。可想而知，多个.cpp 都实例化出了相同的类，如果项目很大，.cpp 源文件很多，那这个额外的开销比较大，增加了很多编译时间并且没有必要，这并不是开发人员想看到的情况。  

可以通过“显式实例化”避免这种生成多个相同类模板实例的开销。看一看怎样写这个显式实例化。  

可以在test.cpp文件头写人如下代码。  


``` cpp
template  A<float>;//这叫"实例化定义"，只有一个.cpp文件里这样写，编译器为其生成代码
```

上面这行代码的意思就是让编译器实例化出一个 A`<float>`。然后，在其他的.cpp文件中，当然不需要再实例化了，只需要在其他的.cpp 源文件的头上声明这个实例化出来的类就行了，看看怎样写：  

``` cpp
extern template A<float>;
//其他所有.cpp文件都这样写
```

为什么要在.cPp文件头上写这些呢？因为编译器遇到使用类模板的代码会自动对模板实例化，所以在.cpp文件头上写的代码肯定比那些使用该类模板的代码先执行到。  

这个带extern的代码行，称为模板实例化声明，当编译器遇到extern模板实例化声明时，编译器就不会在本.cpp源文件中生成一个extern后面所表示的类模板的实例化版本代码。这个extern的意思就是告诉编译器，在其他的.cpp源文件中已经有一个该类模板的实例化版本了，所以这个extern一般写在多个.cpp源文件的文件开头位置（如果项目中存在多个.cpp源文件）。  

读者可以注意到这个写法：模板实例化定义的格式，是以template开头，template后面可以加一个class关键字，也可以不加。而模板实例化声明的格式，是以extern template开头。  

函数模板也是一样的，在ca.h头文件中，可以定义一个函数模板，添加在文件开头位置。  

``` cpp
template <typename T>  
void myfunc(T v1, T v2)  
{  
    std::cout << v1 + v2 << std::endl;  
}
```

然后可以在test.cpp中的上面位置这样写：

``` cpp
template void myfunc(int& v1, int& v2); //函数模板实例化定义，编译器会为其生成实例化代码
```

在MyProject.cpp中的上面位置这样写：

``` cpp
extern template void myfunc(int& v1, int& v2); //函数模板实例化声明
```

通过上面这些步骤，float 版本的 A 类模板（A`<float>`）以及 int 版本的 myfunc(） 函数模板就都会在test.cpp 文件中实例化，而不会在MyProject.cpp 文件中实例化。所以，extern有“禁止实例化”这样的意思。  

当然，如果此时在MyProject.cpp中的main()主函数中使用了int作为模板参数的类模板A，那么这个int 作为模板参数的类模板A还会在MyProject.cpp中被实例化：  

``` cpp
A<int> d(6, 7); //int版本的A（A<int>）会被实例化
```

特别注意：模板的实例化定义只有一个，模板的实例化声明可以有多个。实例化定义不 要忘记写，否则就达不到减少系统额外开销的效果或会造成链接出错。  

针对本节讲解的内容，笔者做了一定的测试，如果读者朋友有兴趣，也可以自己测试。笔者估计，不同编译器测试结果可能不一样。笔者测试的时候其实是观察编译生成的.obj目标文件（用文本编辑器直接打开就可以观察），就是想看看到底.obj文件中是否存在通过类模板实例化出来的具体类。  

笔者在Visual Studio 2017和Visual Studio 2019中分别做了测试（不一定100%对， 但可以供参考），测试的结论是：extern是有作用的。例如，在类模板A中增加普通成员函数：

``` cpp
public:  
    void myfuncpt() { std::cout << "myfuncpt()执行了" << std::endl; };
```

但是并没有调用这个普通成员函数，编译之后，可以通过dumpbin工具观察，对于ex tern template A`<float>`;的.cpp源文件，编译器没有针对A`<float>`类实例化出myfuncpt()成员函数；而对于使用了templateA`<float>`;的.cpp源文件，编译器就会针对A`<float>`类实例化出myfuncpt()成员函数。实际上，一旦利用代码行template A`<float>`;进行显式实例化，那么系统会把这个类模板以及所有成员函数都实例化出来（感觉这样并不好)，包括内联的成员函数。为什么会实例化类模板的所有成员函数？因为像templateA`<float>`;代码行这种实例化方式，编译器并不了解程序使用了哪些成员函数，所以就一股脑地把类模板的所有成员函数都实例化了，不管代码中用到的，还是没用到的。  

总结如下。  

（1）使用VisualStudio2017或VisualStudio2019的读者，不推荐使用类模板显式实例化特色，因为该特色虽然有作用，但也会把所有成员函数（不包括成员函数模板）都实例化出来，增加了编译时间和代码长度。其他平台编译器，读者有条件可以自行测试验证一下本节所讲的内容。另外，毕竟笔者和读者都不是编译器的开发者，所以可能对“模板显式实例化”实现的复杂性有所低估。  

（2）笔者讲解本节内容的另一个目的就是希望读者日后遇到这种写法的程序代码能够看得懂，例如下面这种语句：  

``` cpp
template A<float>;
extern template A<float>;
```
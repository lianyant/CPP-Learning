# 2.5多态在模板中的应用  

笔者在《 $\mathbf{C}^{++}$ 新经典：对象模型》一书中已对多态的概念谈得非常清楚、非常到位，看一个简单的多态的例子：  

``` cpp
class Human  
{  
public:  
    virtual void eat()  
    {  
       cout << "人类以米饭和面食为主!" << endl;  
    }  
    virtual ~Human() {} //作为父类存在时一般应该书写虚析构函数  
};  
  
class Men :public Human  
{  
public:  
    virtual void eat()  
    {  
       cout << "男人喜欢吃面食!" << endl;  
    }  
};  
  
class Women :public Human  
{  
public:  
    virtual void eat()  
    {  
       cout << "女人喜欢吃米饭!" << endl;  
    }  
};
```

上面的代码中，定义了一个父类Human以及两个public继承的子类Men和Women，3个类中都存在一个虚函数eat()。在mainO主函数中添加代码：  

``` cpp
Men objmen;  
Women objwomen;  
//父类引用绑定（指向）子类对象，以表现多态  
Human& yinbase1 = objmen;  
Human& yinbase2 = objwomen;  
yinbase1.eat();  
yinbase2.eat();
```

运行程序，结果如下。  

``` cpp
男人喜欢吃面食！
女人喜欢吃米饭！  
```

根据上面这个范例，从“表现形式”上回顾一下“多态”的概念：

（1）有父类和子类（有继承关系），父类中必须含有虚函数，子类重写父类中的虚函数；

（2）父类指针指向子类对象或父类引用绑定（指向）子类对象；  

（3）当以父类的指针或引用调用子类中重写了的虚函数时，就能看出多态的表现了，因为调用的是子类的虚函数。  

现在看一看，如果把多态这个概念运用到模板中，是怎样的情形呢？  

模板中的多态，并不需要用到父类以及继承的概念，子类中也不需要虚函数（压根也就不存在父类指针指向子类对象或父类引用绑定子类对象的概念），所以，现在可以把Human类注释掉，Men类和Women类的定义改造如下（去掉继承，去掉函数中的virtual修饰）。  

``` cpp
class Men  
{  
public:  
    void eat()  
    {  
       cout << "男人喜欢吃面食!" << endl;  
    }  
};  
class Women  
{  
public:  
    void eat()  
    {  
       cout << "女人喜欢吃米饭!" << endl;  
    }  
};
```

加人函数模板：

``` cpp
template<typename T>  
void eatTmpl(T& obj)  
{  
    obj.eat();  
}
```

在main(主函数中，保留前两行代码，并加人新代码。完整的main（)主函数代码如下。  

``` cpp
Men objmen;  
Women objwomen;  
eatTmpl(objmen);  
eatTmpl(objwomen);
```

运行程序，结果如下。  

``` cpp
男人喜欢吃面食！
女人喜欢吃米饭  
```


从结果中不难看到，其实这也是一种多态的感觉，编译器在编译期间会实例化出eatTmpl`<Men>`和eatTmpl`<Women>`这两个函数，然后不同的类对象obj（引用）调用不同类的同名成员函数eat()。  

传统多态也叫作动态多态（运行时的多态），因为要访问虚函数表指针，所以程序执行性能上多少会有一些影响，但这种在模板中运用的多态技术在编译期间就确定了具体调用谁，因此并不存在这样的性能问题，这也是泛型编程与面向对象程序设计的不同之处的一个体现。另外，在模板中运用的这种多态技术也叫作静态多态（只要支持相同的语法，就允许不同类型的对象以同样的方式被操纵—都有eat()成员函数，那么就允许调用该成员函数），因为是在编译期间完成的多态。  

同时，请注意这种在模板中的多态使用方式，与传统的多态相比，省略一个父类，也省略成员函数前面的virtual修饰符，所以代码看起来更简洁。而且，显然静态多态比动态多态具有更好的执行效率，因为查询虚函数表确定调用哪个虚函数等一系列判断决策只出现在动态多态中。
# 2.3类模板中的友元  

想必读者对友元这个概念已经比较熟悉了，在引人模板的概念之后，还是有必要对友元这个概念进行整理和总结。  

## 2.3.1 友元类  

传统友元类的概念是：让某个类B成为另外一个类A的友元类，这样的话，类B就可以在其成员函数中访问类A的所有成员（成员变量、成员函数），而不管这些成员在类A中是用什么修饰符（private、protected、public）修饰的。  

如果现在类A和类B都变成了类模板，那么能否让类模板B成为类模板A的友元类模板呢？这要分3种情况讨论。  

### 1.让类模板的某个实例成为友元类  


``` cpp
template <typename T>  
class A  
{  
private:  
    int data;  
};  
  
template <typename U>  
class B  
{  
public:  
    void callBAF()  
    {  
       A<int> atmpobj;  
       atmpobj.data = 5;  
       std::cout << atmpobj.data << std::endl;  
    }  
};
```

在main（）主函数中添加代码：  

``` cpp
B<long> bobj;  
bobj.callBAF();
```

上面这段代码编译后会报错，因为类模板B的calIBAF()成员函数要访问类模板A的私有成员变量data，这是不允许的。那么，如果类模板B成为类模板A的朋友，显然就会解决编译出错的问题。于是，调整类模板A的代码，增加一个friend声明，调整后的类模板A的代码如下。  

``` cpp
template <typename T>  
class A  
{  
    //友元类  
    friend class B<long>; //不需要任何public、private等修饰符修饰  
  
private:  
    int data;  
};
```

此外，还需要在类模板A定义的前面增加针对类模板B的声明（如果B不是类模板，而只是一个普通类，就不需要增加针对类B的声明）：  

``` cpp
template <typename U> class B; //类模板B声明
```

再次编译，一切顺利。运行程序，结果如下。  

``` cpp
5
```

从上面的代码中可以看到，实际是让类模板B的特定类模板实例（也就是B`<long>`）成为类模板A的友元类。也就是说，B`<long>`实际上代表的是一个具体的类，这一点请读者理解好。  

### 2.让类模板成为友元类模板  

前面只是让B`<long>`成为类模板A的友元类，如果调整main()主函数中的代码，把B`<long>`bobj;代码行中的long类型修改为int类型，再次编译，发现又报错，报错内容如下。  

``` cpp
errorC2248："A<int>：:data”：无法访问private成员（在"A<int>"类中声明）  
```


之所以出现这个错误，是因为 $_{\mathbf{B}<\mathbf{int}>}$ 并不是类模板A 的友元类，自然不能访问data私有成员。  

那么，如果把整个类模板B变成类模板A的友元类模板，这个问题自然就解决了，所以修改一下类模板A的定义，修改后的类模板A的代码如下。  

``` cpp
template <typename T>  
class A  
{  
    //friend class B<long>;  
    template<typename> friend class B;  
private:  
    int data;  
};
```

此时再次编译，发现已经不再出现错误，而且，也不再需要在类模板A定义的前面增加针对类模板B的声明：  

``` cpp
template <typename U> class B; //类模板B声明
```

现在，类模板B就成了类模板A的友元类模板。  

### 3.让类型模板参数成为友元类  

这是一个 $\mathbf{C}^{++}$ 11标准引人的特性：如果传递进来的类型模板参数是一个类类型，则这个类类型可以成为当前类模板的友元类。以下代码创建一个全新的类模板A2，注意其中的friend用法。  

``` cpp
template <typename T>  
class A2  
{  
    friend  T;  
private:  
    int data;  
};
```

另有一个CF类，定义如下。  

``` cpp
class CF  
{  
public:  
    void callCFAF()  
    {  
       A2<CF> aobj1;  
       aobj1.data = 12;  
       std::cout << aobj1.data << std::endl;  
    }  
};
```

在main（主函数中添加代码：  

``` cpp
CF mycfobj;  
mycfobj.callCFAF();
```

可以正确编译和执行。分析一下CF类中calICFAFO）成员函数的代码：

（1）代码行 $_{\bf A2<C F>}$ aobjl；的作用是让CF类成为 $_{{\bf A}2<{\bf C F}>}$ 类的友元类；  

（2）于是，在CF类的成员函数中，可以直接访问aobj1这个 $_{{\bf A}2<{\bf C F}>}$ 类对象的data私有成员变量。  

上面这两条要理解好，首先是“在CF类的成员函数中”这句话，如果在main()主函数中写如下代码，必然报错，因为这不是在CF类的成员函数中。  

``` cpp
A2<CF> aobj1;  
aobj1.data = 12;
```

其次，类模板有其特殊性，如果传递给类模板 A2的类型模板参数不是一个类类型，那么代码行 friend T;就会被忽略，从而不能访问 data 成员变量。例如，在CF 类的callCFAFO成员函数中添加代码：  

``` cpp
A2<int> aobj2;  
aobj2.data = 12;
```

上面这样的代码是无法编译通过的，因为CF 类并不是 A2`<int>`的友元类，自然不能在CF 类的callCFAF()成员函数中访问 aobj2这个 A2`<int>`类对象的 data 私有成员变量，除非在类模板A2中加人代码行：  

``` cpp
friend class CF;  
```


上面这行代码表示不管类模板 A2 被实例化为哪个具体类，CF 类都是 A2 实例化的具体类的友元类。这样，上面编译无法通过的代码行就可以顺利编译了。  

## 2.3.2友元函数  

函数模板可以被声明为友元函数，从一段代码开始，首先定义一个最普通的函数模板：  

``` cpp
template<typename U, typename V>  
void func(U val1, V val2)  
{  
    cout << "val1 = " << val1 << endl;  
    cout << "val2 = " << val2 << endl;  
  
};
``` 

在main（主函数中添加代码：  

``` cpp
//调用func方法很多
func(2, 3);  
func<float>(4.6f, 5); //第一个模板参数指定，第二个模板参数自己能推断出来  
func<int, float>(4, 5.8f); //完全手工指定模板参数
```

运行程序，结果如下。  


``` cpp
vall=2
va12  3
val1 = 4. 6
val2=5
val1 = 4
val2  5. 8
```

现在，在func（）函数模板的前面增加一个Men类的定义：  


``` cpp
class Men  
{  
private:  
    void funcmen() const  
    {  
       std::cout << "Men:funcmen被调用了" << std::endl;  
    };  
};
```

然后，修改funcO函数模板中的代码：  

``` cpp
template<typename U, typename V>  
void func(U val1, V val2)  
{  
    Men mymen;  
    mymen.funcmen(); //这行报错  
  
};
```

再次编译，发现报错，报错内容如下。  

``` cpp
errorC2248：Men:：funcmen"：private（在"Men"类中声明）  
```


之所以出现这个错误，是因为函数模板func()并不是Men类的友元函数，自然不能访问Men类的私有成员函数，解决的方法就是让函数模板func(）成为Men类的友元函数。  

### 1.让函数模板的某个实例成为友元函数  

单独分析一下main(）主函数的func(2，3);代码行（把main(）主函数中其余新加入的两行先注释掉），显然，这行代码会针对func(）函数模板实例化出如下func(）函数。  

```cpp
void func<int, int>(int, int){...}
```

所以，把上面这个实例化后的func<int,int>函数声明为Men类的友元，在Men类中添加代码：  

``` cpp
friend void func<int, int>(int, int);
```

同时记住，在Men类定义的上面，还要增加函数模板func（）的声明：  

``` cpp
template<typename U, typename V>friend void func(U val1, V val2);
```

编译，链接，没有问题。运行程序，结果如下。  


``` cpp
Men:funcmen被调用了
```

上面在Men类中加人的friend这行代码，注意这里的尖括号，尖括号中的内容叫作模板实参。在这里可以看到，这两个模板实参都可以通过后面圆括号中调用func(）时指定的实参推导出来。所以，friend这行代码的尖括号中可以不写任何内容，也可以只写一个int，。例如，friend void fun c`<int>`(int，int);friend voidfunc $<>$ (int,int)；都是可以的。  

上面只是为Men类增加了一个具体的func()函数模板的某个实例作为友元，再看看main(主函数中刚被注释的代码行func`<float>`(4.6f,5);，将它的注释去掉，编译一下，依然报错，这说明在Men类中也需要声明func`<float，int>`函数为Men类的友元。在Men类中继续添加代码：  

``` cpp
friend void func  <> (float,int);  
```


上面的代码中，尖括号内保持为空，编译器会用指定的实参类型推导出模板参数的类型。  

同理，针对main()主函数中的func<int,float>(4,5.8f);代码行，将其注释去掉，在Men类中继续添加代码：  

``` cpp
friend void func<>(int,float);  
```


编译，链接，没有问题。运行程序，结果如下。  

``` cpp
Men: funcmen被调用了 
Men: funcmen被调用了 
Men:funcmen被调用了
```

上面这个例子是在Men类中增加了友元函数声明。其实，如果把Men类改造成一个类模板，也完全没有问题（后续统一把Men称为Men类模板）。  

``` cpp
template<typename Z>  
class Men  
{  
   ...
};
```

当然，func（）函数模板的代码也要改造一下。  


``` cpp
template<typename U, typename V>  
void func(U val1, V val2)  
{  
    Men<int> mymen;  
    mymen.funcmen(); 
};
```

编译，链接，程序也能正常执行。  

### 2.友元模板  

上面的范例中，只是让函数模板func()的某个实例成为Men类模板的友元函数，而且为了应对不同的情况，还要分别设置多个func()函数模板的实例成为Men类模板的友元函数。显然，如果希望所有func()实例都成为Men类模板的友元函数，像上面这样一个个设置很辛苦。所以，为了做到这点，就需要让函数模板func()成为 Men 类模板的友元模板。  

方法是在Men类模板的定义中添加代码行：

``` cpp
template<typename U, typename V> void func(U val1, V val2);
```

这样，所有func(）函数模板的实例就都成为Men类模板的友元函数，Men类模板中原来的几行友元函数声明代码行（如下）就不再需要，可以注释掉。  

``` cpp
 friend void func<>(int, int);  
friend void func<>(float, int);  
friend void func<>(int, float);
```

而且，也不再需要在类模板Men定义的前面增加针对函数模板func(的声明了。  

值得注意的是，将func(）函数模板（泛化版本）声明为Men类模板的友元模板之后，func(）函数模板的特化版本也会被看作Men类模板的友元。例如，下面的func（）函数模板的特化（全特化）版本的代码是没有问题的，可以正常编译。  

``` cpp
template<>  
void func(int val1, double val2)  
{  
    Men<int> mymen;  
    mymen.funcmen();  
}
```

这里面有一个比较有趣的现象，如果把mainO主函数中的代码全部注释掉，然后把Men类模板中的所有friend语句也注释掉，此时观察泛化版本和全特化版本的func(O函数模板，虽然这两个版本的函数体中都有对Men类模板的私有成员函数funcmen（）的调用（mymen.funcmen(O;），但不难发现，编译项目时，只有全特化版本的func（）函数模板中的mymen.funcmenO；代码行会报错，而泛化版本的funcO函数模板中的该代码行并不报错，除非在main(）主函数中使用诸如func<int,float>(4，5.8f);的代码对func(）进行调用导致对泛化版本的func(）函数模板进行实例化，才会导致泛化版本的func(函数模板的mymen.funcmen(）；代码行编译错误。从这点可以看出（前面也曾经提过），编译器是把全特化的func(）函数模板看作一个实例化过的函数模板（理解得更直接一点，就是看作一个已经存在了的函数），形如：  

```cpp
void func<int,double>(int val1, double val2){...}
```

### 3.在类模板中定义友元函数  

还有一种相对比较奇怪的语法，就是可以在一个类模板中定义（不是声明）一个友元函数，这种友元函数是能被调用的，而且也只有在代码中调用了这个函数时，编译器才会实例化这个函数。之所以这样定义友元函数，一般都是因为在友元函数中会用到这个类模板。这种友元函数的调用就跟调用普通函数差不多，当作普通函数看待就可以。换句话说，虽然下面的函数func2()的定义写在了Men类模板中，但是应该把它看作一个全局函数，不受Men类模板的限制。  

在Men类模板中添加一个func2()友元函数的定义：  

``` cpp
template<typename Z>  
class Men  
{  
    friend void func2(Men<Z>& tmpmen)  
    {  
       tmpmen.funcmen();  
    }  
      
   ...
};
```

在mainO主函数中添加代码：  

``` cpp
Men<double> mymen2;  
func2(mymen2);  //直接调用Men类模板中定义的友元函数func2  
Men<int> mymen3;  
func2(mymen3);
```

这里再解释一次，虽然func2()友元函数被写在一个类模板中，但是类模板被实例化时并不会实例化这些友元函数，只有代码中调用到这些函数时，这些函数才会被实例化。  

另外值得一提的就是，因为func2()是写在类模板定义中的，所以，当调用func2（）时，如果func2O中的代码非常简单，那么聪明的编译器就会把func2(当作一个内联（Inline）函数来处理；如果func2(）中的代码比较复杂（如出现了for循环等），那么func2O就很可能不会被当作一个内联函数处理。例如，如果修改func2(）的代码：  

``` cpp
friend void func2(Men<Z>& tmpmen)  
{  
    for (int i = 0; i < 1; ++i)  
    tmpmen.funcmen();  
}
```

因为增加了for循环，则很可能func2()就不会被当作内联函数处理，此时，因为在main(主函数中调用出现了func2(mymen2);和func2(mymen3);，那么，func20会实例化两个不同的函数（读者可以用讲解过的dumpbin工具观察）：  

``` cpp
void func2(class Men<double> &) 
void func2(class Men<int> &)
```

可以看到，虽然func2()是写在了Men类模板的定义中（好处是可以访问类模板中的私有成员），但它的作用域其实是全局作用域，所以func2()是一个全局函数。
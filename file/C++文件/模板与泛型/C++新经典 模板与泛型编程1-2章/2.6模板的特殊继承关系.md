# 2.6模板的特殊继承关系  

模板的继承其实与普通的继承区别不大，但在模板的继承关系中，有一些比较特殊的继承关系。  

## 2.6.1奇异（奇特）的递归模板模式  

奇异的递归模板模式（Curiously Recurring Template Pattern，CRTP）不是一种新技术，而是一种模板编程时使用的编程手法一把派生类作为基类的模板参数。  

看一下范例代码：  

``` cpp
template <typename T> //T代表着派生类  
class Base   //Base是类模板  
{  

};  
  
class Derived1 : public Base<Derived1> //Derived1是普通类  
{  
public:  
    void myfunc()  
    {  
       cout << "Derived1::myfunc()执行了" << endl;  
    }  
    //......  
};  
  
template <typename T>  
class Derived2 : public Base< Derived2<T> > //Derived2是类模板  
{  
  
};
```

这种继承方式在模板与泛型编程中很常见，当然，对于初次看到的读者，可能会觉得不习惯，但见多了就好了。  

这种编程手法有什么用途呢？应该说是用途是比较广泛的，而且这些用途可能需要读者日后多读一些 $\mathbf{c}_{++}$ 标准库、Boost库等作品的源码才能感受得比较深刻。在这里，举一些简单的例子展示一下奇异的递归模板模式这种编程手法的用途。  

### 1.在基类中使用派生类对象  

在Base基类模板中，增加一个public修饰的成员函数
``` cpp
public:  
    void asDerived()  
    {  
       T& derived = static_cast<T&>(*this);  
       derived.myfunc(); //调用派生类的成员函数  
    }
```

上面这段代码能够正常工作的原因是在单继承的情况下，派生类对象也是基类对象，这一点在《 $\mathbf{c}_{++}$ 新经典：对象模型》一书中有比较详细的阐述。所以，通过static_cast就可以把基类对象转换成派生类对象，从而调用派生类中的成员函数（myfunc）。  

在main（主函数中添加代码：  

``` cpp
Derived1 myd;  
myd.asDerived(); //调用基类的成员函数  
```

运行程序，结果如下。  

``` cpp
Derivedl::myfunc（）执行了  
```

这里有一个技巧笔者要强调一下，因为这种技巧将来在读实际代码时可能会遇到。例如，再创建一个Derived3派生类，也是把派生类作为基类的模板参数，但是因为笔误，把继承的基类Base`<Derived3>`写成了Base`<Derived1>`，这个错误比较隐晦，不太好发现，例如：  

``` cpp
class Derived3 : public Base<Derived1>  
{  
  
};
```

那么，此时在main（主函数中添加如下代码行，也能成功编译。  

``` cpp
Derived3 myd3;  
```

为了防止这种笔误出现，可以改造一下Base类模板，改造之后，一旦出现像上面这样的Dervied3笔误的时候，用Dervied3创建对象就会产生编译错误。在Base类模板中，增加private修饰的代码行：  

``` cpp
private:  
    Base() {};  
    friend T;  
};
```

从代码中可以看到，Base类模板的构造函数变成了私有的，而派生类（T）变成了友元类。此时再编译，代码行Derived3myd3；就会报告错误。  

想一想，当创建一个Derived3类对象时，需要调用Base类模板中的构造函数，因为该构造函数是私有的，但友元类（Derived3）却可以访问该私有函数，所以，Base类的构造函数可以被成功调用，从而可以成功创建Derived3类对象。但假如定义Derived3类时误写class Derived 3：publicBase`<Derived1>`，Derived 1 Base， 创建Derived3类对象时无法访问Base类模板中的构造函数，从而造成Derived3类对象创建失败。  

在奇异的递归模板模式这种编程手法中，可能会经常看到友元的身影，读者要注意理解。  

### 2.基于减少派生类中代码量的考虑  

基于代码量的考虑的出发点是尽可能把一些代码挪到基类中去，从而有效减少派生类的代码量。这里举一个例子：  


``` cpp
template<typename T>  
struct shape  
{  
    //不写成友元而写成全局的operator==也可以，但要注意格式就应该是：  
    //template <typename T>  bool operator==(const shape<T>& obj1, const shape<T>& obj2){......}  
    friend bool operator==(const shape<T>& obj1, const shape<T>& obj2)  
    {  
       const T& objtmp1 = static_cast<const T&>(obj1);  
       const T& objtmp2 = static_cast<const T&>(obj2);  
       if (!(objtmp1 < objtmp2) && !(objtmp2 < objtmp1))  
          return true;  
       return false;  
    }  
};  
struct square :public shape<square>  
{  
    int sidelength;  //边长  
};  
  
//类外运算符重载可以这样写  
bool operator<(square const& obj1, square const& obj2)  
{  
    if (obj1.sidelength < obj2.sidelength)  
       return true;  
    return false;  
}
```

shape operator $==$ 前面增加了friend修饰，这个知识在前面讲过一在类模板中定义友元函数，这种函数当作全局函数或普通函数进行调用即可。  

在main（主函数中，添加代码：  

``` cpp
square objsq1; //派生类对象  
objsq1.sidelength = 15;  
square objsq2; //派生类对象  
objsq2.sidelength = 21;  
if (!(objsq1 == objsq2))  
{  
    cout << "objsq1和objsq2不相等!" << endl;  
}  
else  
{  
    cout << "objsq1和objsq2相等!" << endl;  
}
```

运行程序，新增代码的执行结果如下。  

``` cpp
objsq1和objsq2不相等！
```

上面这个例子中，把派生类对象是否相等这个判断操作挪到了基类中实现，也就是使用了在类模板中定义友元函数的手段把全局的operator $==$ 放到了基类中。当然，operator $==$ 可以不写到基类中。  

如果需要进一步增加如大于（>）、不等于（！=）等操作符，依旧可以利用友元函数的手段在基类中实现，派生类中不用增加任何新代码。  

### 3.基类调用派生类的接口与多态的体现  

因为基类可以调用派生类中的方法，因此，有很多事情可以在基类中做。看下面这个范例：

``` cpp
//基类模板  
template <typename T>  
class Human    
{  
public:  
    T& toChild()  
    {  
       return static_cast<T&>(*this);  
    }  
  
    void parenteat()  
    {  
       toChild().eat();  
    }  
  
private:  
    Human() {};  
    friend T;  
};  
  
class Men : public Human<Men>  
{  
public:  
    void eat()  
    {  
       cout << "男人喜欢吃面食!" << endl;  
    }  
};  
  
class Women : public Human<Women>  
{  
public:  
    void eat()  
    {  
       cout << "女人喜欢吃米饭!" << endl;  
    }  
};  
  
template<typename T>  
void myHumanFuncTest(Human<T>& tmpobj)  
{  
    tmpobj.parenteat();  
}
```

在main()主函数中添加代码：  


``` cpp
Men mymen;  
Women mywomen;  
  
mymen.parenteat();  
mywomen.parenteat();  
cout << "-----------------------" << endl;  
myHumanFuncTest(mymen);  
myHumanFuncTest(mywomen);
```

运行程序，新增代码的执行结果如下。  


``` cpp
男人喜欢吃面食！
女人喜欢吃米饭！
男人喜欢吃面食！
女人喜欢吃米饭！
```

从上面这个例子中可以看到，在基类增加的方法（parenteat())，派生类对象都能够调用。这里观察一下基类的parenteat()方法，有意思的是基类调用的实际上还是派生类的方法（eat()，这相当于派生类给基类提供了调用接口（传统都是基类给派生类提供调用接口），这也是奇异的递归模板模式的一个特点。  

另外，通过对myHumanFuncTest()调用的观察，这里也涉及了静态多态（在编译期间就确定了具体调用谁）的概念一分别用mymen和mywomen作为实参调用myHuman-FuncTestO，得到的结果不同，分别调用了不同派生类的eatO）成员函数表现不同的行为。所以，从这个角度来讲，可以把奇异的递归模板模式这种编程手法看作是静态多态编程技术，如果想在编译期间通过基类获得派生类的行为，用这种编程技术是不错的。  

当然，在这个范例中，如果不用奇异的递归模板模式，而是把eat()成员函数在基类和派生类中都写为虚函数，也可以实现多态的功能。但如果eat()是一个函数模板或静态成员函数，那么就没有办法将其实现为一个虚函数，此时就有必要采用奇异的递归模板模式实现虚函数的多态效果了。  

还有其他奇异的递归模板模式的用法，这里不一一列举，可以在今后的进一步学习和实践中不断积累。  

## 2.6.2混人  

混人（Mixins）这个概念，是一种编程手法，用于描述类与类之间的一种关系，这种关系比较类似于多重继承，看起来更像颠倒过来的继承（基类继承自派生类）。混人的实现手段是把传入的模板参数当作该类模板的父类。  

### 1．常规范例  

举一个例子讲解混入的概念。先看没有引入“混人”概念之前的一个设计。这里以一个大型网络游戏为例，游戏中每个玩家代表一个角色，多个角色可以组成一个家族，家族与家族之间可以进行战斗。  

首先设计一个角色类role（代表玩家），一个角色具有攻击力、防御力、血量（生命值）等属性，代码如下。  

``` cpp
class role  
{  
public:  
    //构造函数  
    role() :m_attack(0.0), m_defence(0.0), m_life(100.0) {} //初始时攻击力防御力都为0，血量100  
    role(double att, double def, double life) :m_attack(att), m_defence(def), m_life(life) {}  
public:  
    double m_attack;  //攻击力  
    double m_defence; //防御力  
    double m_life;    //血量（生命值）      
//......其他信息  
};
```

再设计一个家族类，若干个角色（玩家）构成一个家族，代码如下。  

``` cpp
class family  
{  
public:  
    std::vector<role> m_members;  
    ......其他信息，比如家族创建日期等  
};
```

后来，考虑到游戏中还可能有一些怪物、非玩家角色（Non-PlayerCharacter,NPC）等,这些角色不由玩家控制，而是由游戏内部的怪物智能系统控制。这些怪物或NPC也是分家族的，考虑到这种情况，有必要修改family这个家族类，将其修改为类模板以更通用。修改后的代码如下。  

``` cpp
template<typename T>  
class family  
{  
public:  
    std::vector<T> m_members;  
    ......其他信息，比如家族创建日期等  
};
```

随着游戏开发的不断深人，需求进一步明晰，新的需求又出现了。原来的role类，本来是用于玩家的，但是游戏中的怪物、NPC也有攻击力、防御力、血量等属性，因此role类也完全适用于游戏中的怪物、NPC等。  

但新需求是NPC这种非玩家角色有一些额外的属性，如记录该NPC的种类（O代表无实际功能，装饰游戏场景用的；1代表卖服装的；2代表把游戏任务派送给玩家的等），又如该NPC可能会在不与玩家交互时自言自语一句话。所以引人NPC属性类：  

``` cpp
struct npcattr  
{  
    int m_sort;  //npc种类：0代表无实际功能装饰游戏场景用的NPC，1代表卖服装的，2代表把游戏任务派送给玩家  
    std::string m_lang;  //记录自言自语的一句话的内容  
};
```

考虑使用继承创建一个新类role_npc，继承自role类，专门用来应对NPC这种非玩家角色，代码如下。  

``` cpp
class role_npc : public role  
{  
public:  
    //构造函数  
    role_npc() : role(), m_strucattr{ 0,"" } {}  
    role_npc(double att, double def, double life, int extraa, int sort, std::string lang) : role(att, def, life), m_strucattr{ sort,lang } {}  
public:  
    npcattr m_strucattr;  
};
```

随着游戏玩法的丰富，为玩家引人了属性系统，属性分为“力量”“敏捷”“体质”。玩家在游戏中每升1级，会得到10点属性，玩家可以把这10点属性分别加到这3个属性上去（最终目的是提高玩家的攻击力、防御力、血量)：每加1点力量，攻击力提高1.2；每加1点敏捷，防御力提高1.5；每加1点体质，血量增加0.6。于是，引人玩家属性类：  

``` cpp
struct playerattr  
{  
    int m_strength;     //力量  
    int m_agile;        //敏捷  
    int m_constitution; //体质  
};
```

考虑使用继承创建一个新类 role_player，继承自 role 类，专门用来应对真实玩家角色,代码如下。  

``` cpp
class role_player :public role  
{  
public:  
    role_player() :role(), m_strucattr{ 0 } {}  
    role_player(double att, double def, double life, int sth, int agi, int cons) : role(att, def, life), m_strucattr{ sth,agi,cons } {}  
public:  
    playerattr m_strucattr;  
};
```

以上这些代码就是通过继承的方式实现了NPC角色（role_npc 类）和玩家角色（role_player类），最终可以把这些角色汇集起来形成一个家族（family类模板）。  

从代码中可以看到，子类（role_npc、role_player）有参构造函数的初始化列表，都比较长，而且如果将来修改了role类，那么可能role_npc、role_player等子类中的代码也要修改，总体来讲，不是很方便。于是，引人了混入这种实现手段取代传统的类继承，这种混人实现手段看起来更像是把某个或某些类混合到当前类中凑成一个更大的类。  

下面，尝试用混人技术实现上面代码相同的功能，涉及模板参数的时候，为了灵活，引人可变参模板（不使用可变参模板也可以，读者可以自行书写不使用可变参模板的代码)，为了后续演示方便，先把刚刚的 role类、role_npc 类和role_player 类的定义注释掉。首先 实现role类模板，注意看它的父类：  


``` cpp
template<typename... T>  
class role : public T...  //把传入的模板参数当做该类模板的父类  
{  
public:  
    role() : T()..., m_attack(0.0), m_defence(0.0), m_life(100.0) {}  
    role(double att, double def, double life) : T()..., m_attack(att), m_defence(def), m_life(life) {}  
public:  
    double m_attack;  //攻击力  
    double m_defence; //防御力  
    double m_life;    //血量（生命值）    };
```

这时，就可以通过混人的方式把role_npc和role_player这两个类构造出来（不需要通过继承role类的方式创建这两个类）。  

使用using定义类型别名：  

``` cpp
using role_npc = role<npcattr>;
```

如果在main（主函数中添加代码：  

``` cpp
role_npc  mynpc;  
mynpc.m_attack = 15;   //攻击  
mynpc.m_defence = 10;  //防御  
mynpc.m_life = 120;    //血量  
mynpc.m_sort = 1;      //npc种类  
mynpc.m_lang = "Are You OK?";  //NPC自言自语时所说的话*/
```

则显然这里的role_npc类型的效果有点类似于下面这种继承关系：  

```cpp
class role_npc : public role, publicnpcattr {...}
```

同理，role_player也可以通过如下代码实现出来。  

```cpp
using role_player = role<playerattr>;
```

当然，如果将来在游戏中出现了一种新型NPC，同时具备role_npc 和role_player 的属性，那么这个新型NPC（取名role_mixnpc）也一样可以通过混人技术方便地组合出来（自由装配各种功能），代码如下。  

``` cpp
using role_mixnpc role<npcattr, playerattr>;
```

上面的代码行看上去要比使用继承实现role_mixnpc类方便多了。  

然后，family类模板也应该做出相应的调整，变成一个可变参模板以支持role这个可变参模板（注意要把family类模板的定义放到新的role 可变参模板定义的后面）。  

``` cpp
template<typename... T>  
class family  
{  
public:  
    std::vector<role<T...>> m_members;  
    //......其他信息，比如家族创建日期等  
};  
  
using family_npc = family<npcattr>;
```

而后在main（主函数中，可以增加如下代码使用该类型。  

```cpp
family_npc myfamily;
myfamily.m_members.push_back(mynpc);
```

### 2.用参数化的方式表达成员函数的虚拟性  

可能这个标题听起来有些奇怪，难道成员函数的虚拟性也能用参数化的方式表达吗？答案当然是肯定的。  

首先看一个用混人技术实现的简单范例，代码如下。  

``` cpp
template<typename... T>  
class Base : public T...  
{  
public:  
    void myfunc()  
    {  
       cout << "Base::myfunc()执行了!" << endl;  
    }  
  
};
```

上面这段代码非常简单，其中唯一值得注意的是成员函数myfunc()，这个成员函数看起来只是一个普通的成员函数（怎么看也看不出来它是一个虚成员函数），但是这里面的一个关键问题是Base是一个可变参类模板，带着模板参数T，模板参数T代表“一包类型”，并且，由于使用了混人技术，所以T代表的一包类型都会作为Base 的父类。这意味着，一旦这一包类型中的某个类型（某个类）包含一个名字叫作myfunc(的虚函数，那么它的孩子类(Base）中的 myfunc(）就变成了虚函数，即使 Base中的myfunc()不用 virtual修饰。

接着，创建Derived类模板作为Base 类模板的子类模板，代码如下。  

``` cpp
template<typename... T>  
class Derived :public Base<T...>  
{  
public:  
    void myfunc()  
    {  
       cout << "Derived::myfunc()执行了!" << endl;  
    }  
};
```

现在，父类Base（类模板）和子类Derived（类模板）中都有myfunc（）函数。根据 $\mathtt{c}_{++}$ 语言中虚函数的特点，当父类指针指向子类对象时，有以下几点说明。  

（1）如果在Base中的myfunc(）是一个虚函数，使用父类指针调用 myfunc(）函数必然执行的是子类中的myfunc()函数。  

（2）如果在Base中的myfunc（）是一个普通（非虚）函数，使用父类指针调用myfunc()函数执行的就是父类Base中的myfunc(）函数。  

（3）如果一个函数在父类中是虚函数，则在子类中即便不用virtual修饰该函数，该函数在子类中依然是虚函数。  

接着，创建一个最简单的空类A，代码如下。  

``` cpp
class A  
{  
};
```

有了上面这个最简单的类A，就可以做测试了。在main（）主函数中添加代码：

``` cpp
Base<A>* pb1 = new Derived<_nmsp4::A>; //父类指针指向子类对象 
pb1->myfunc();
```

运行程序，结果如下。  

``` cpp
Base：：myfunc（）执行了！
```


从结果中可以看到，虽然父类指针 pb1 指向的是子类对象，但是因为 myfunc() 函数是非虚函数，所以用 pbl 调用 myfunc()的时候执行的仍然是父类 Base 中的 myfunc(）函数。  

但是，通过给 Base 类模板提供一个带有虚函数 myfunc()的类（作为 Base 的父类)，就可以让Base中的myfunc()函数变成虚函数，这就是所谓的“用参数化的方式表达成员函数的虚拟性”。  

为此，创建一个AVir类，这个类中 myfunc(）函数是一个虚函数，代码如下。  

``` cpp
class AVir  
{  
public:  
    virtual void myfunc() {}  
};
```

在main（）主函数中继续添加代码：

``` cpp
Base<AVir>* pb2 = new Derived<AVir>;  
pb2->myfunc();
```

运行程序，新增代码的执行结果如下。  

``` cpp
Derived::myfunc()执行了！
```

通过结果可以看到，在指定了AVir为Base的父类（因为有代码行Base`<AVir>`*pb2 $=$ newDerived`<AVir>`;的存在）之后，AVi r my fun c(）虚函数，所以Base中的myfunc()函数就变成了虚函数（myfuncO函数的虚拟性可以通过指定Base的模板参数为A还是Avir来决定），那么，执行 $\tt p b2J$ myfunc();的时候，Base my fun cO)函数，而是Derived中的myfunc(）函数，此时，myfunc（）函数就肯定是一个虚函数了。  

其实“用参数化的方式表达成员函数的虚拟性”这个话题体现的并不是一种纯粹的技术实现，而是一种设计理念，这种设计理念体现了开发者超越代码之上的更高级开发智慧，在实践中，同样需要通过不断学习和积累培养这种设计理念。  

无论是奇异的递归模板模式，还是混人，都涉及让一些类作为父类的情形。在常规的开发中，读者都知道，一般一个类如果作为父类，那么它应该有析构函数并且该析构函数应该是一个虚函数，这一点在笔者的《 $\mathtt{C++}$ 新经典：对象模型》一书中有详细的解释。当然这不是绝对的，某些情况下，如果父类的析构函数不是虚函数，肯定会出问题。但如果下面的情况不发生，那么父类没有析构函数或父类的析构函数不是虚函数也是完全可以的，如子类并没有虚构函数（不需要在析构函数中释放任何用 new运算符创建出来的数据）或代码中并不会出现父类指针指向子类对象（多态）的情形。  

这里有一个技巧值得提一下，为了防止父类指针用 new运算符创建一个子类对象，可以把父类的析构函数（正常而非虚析构函数）用 protected修饰，一旦这样修饰，就会发现虽然父类指针可以创建一个子类对象，却无法通过父类指针删除（delete）该子类对象，因为析构对象时要调用父类的析构函数，而父类的析构函数是 protected类型的，无法被调用,所以最终还是等于无法用父类指针创建一个子类对象（谁会去创建一个无法成功删除的对象呢？）。例如，下面的代码定义父子关系的两个类A和B。  


``` cpp
class A  
{  
protected:  
    ~A() {}  
};  
class B :public A {};
```

在mainO主函数中添加测试代码：

``` cpp
A* pa = new _nmsp5::B();  
delete pa; //编译报错
```

有兴趣的读者可以参考Boost库中noncopyable类的实现代码。
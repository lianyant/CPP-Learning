# C语言的语句和程序的基本结构

## 1.C语言下语句的分类

​	在C语言中，语句主要可以分为以下几类：

### (1)**表达式语句**：

- 表达式语句是最常见的语句类型，它由一个表达式和一个分号组成。这类语句主要用于执行一个操作，如赋值、函数调用、递增（++）、递减（--）等。表达式的执行通常会产生一个值，但该值不被使用。
- 示例：`a = b + c;`

### (2)**复合语句（块语句）**：

- 复合语句或块语句是由一对大括号括起来的一系列语句和声明。复合语句允许在一个单元中组合多个语句，使它们可以在语法上出现在单个语句应该出现的地方。通常用于控制流语句内部。

- 示例：

    ```c
    {
        int x = 1;
        x++;
        printf("%d", x);
    }
    ```

### (3)**控制流语句**：

- 控制(流)语句用于控制程序的执行流程。这类语句包括条件语句（if-else）、选择语句（switch-case）、循环语句（for、while、do-while）等。
- 示例：
    - `if (condition) { /*...*/ } else { /*...*/ }`
    - `for (initialization; condition; increment) { /*...*/ }`

​	

​	在C语言中，控制语句主要用于控制程序的执行流程。这些语句可以根据不同的条件或者直到满足某个条件为止来执行代码块。C语言中的控制语句大致可以分为以下几种：

1. **条件语句**：
    - `if`语句：根据条件是否满足来执行相应的代码块。
    - `if-else`语句：在`if`语句的基础上，提供一个备选的代码块，当条件不满足时执行。
    - `if-else if-else`链：用于处理多条件的判断。
    - `switch`语句：根据表达式的值选择多个代码块之一执行。
2. **循环语句**：
    - `while`循环：在给定条件为真时重复执行代码块。
    - `do-while`循环：至少执行一次代码块，之后如果条件为真则重复执行。
    - `for`循环：在循环前初始化变量，然后在给定条件为真时重复执行代码块，每次循环结束时更新变量。
3. **跳转语句**：
    - `break`语句：用于立即退出最内层的`switch`语句或循环语句。
    - `continue`语句：跳过当前循环的剩余部分，立即进行下一次循环的条件判断。
    - `goto`语句：将控制转移到标记的位置。使用`goto`语句可以导致代码结构混乱，一般不推荐使用。
    - `return`语句：用于从函数返回一个值（如果有的话）并退出函数。

​	这些控制语句为C语言编程提供了强大的控制逻辑能力，允许开发者根据不同的条件和场景灵活地控制程序的执行路径。在使用时，合理选择和组合这些控制语句可以使程序结构更加清晰、逻辑更加严谨。

### (4)**声明语句**：

- 声明语句用于声明变量或函数的类型。在C语言中，变量可以在使用之前或当它们首次需要时声明。声明不仅指定了变量的类型，还可以包括其初始值。
- 示例：`int a = 5;`

### (5)**跳转语句**：

- 跳转语句用于无条件地转移程序的控制流。这类语句包括`return`、`break`、`continue`和`goto`。`return`语句从函数返回一个值；`break`语句用于退出循环或switch语句；`continue`语句跳过当前循环的剩余部分，开始下一次迭代；`goto`语句将控制转移到程序的另一部分。
- 示例：
    - `return 0;`
    - `break;`
    - `continue;`
    - `goto label;`

### (6)空语句：

- **空语句**：空语句是由一个单独的分号（`;`）构成的语句，它不执行任何操作。虽然看起来没有实际作用，但在某些情况下，空语句是有用的，比如在循环结构中，当循环条件已经在循环体或其他地方处理过了，但语法上需要一个循环体时。

- 示例：

    ```c
    for (int i = 0; i < 10; i++); // 循环没有实际执行体，只是简单地增加i
    ```

### (7)函数调用语句：

- **函数调用语句**：函数调用语句是通过函数名和一组括号（可能包含参数）来调用一个函数。函数调用可以有返回值，也可以没有。如果函数返回一个值，该值可以被忽略，或者用在表达式中。当函数调用作为一个语句单独出现时（不使用其返回值），它就构成了一个函数调用语句。

- 示例：

    ```c
    printf("Hello, World!\n"); // 调用printf函数输出字符串
    ```

### (8)标签语句：

- **标签语句**：在C语言中，标签用于标记程序中的位置，以便`goto`语句可以跳转到。标签本身后面通常跟着一个语句。标签语句在处理复杂的跳转逻辑时非常有用，但过度使用可能会导致代码难以理解和维护。

- 示例：

    ```c
    label: printf("This is a label.\n");
    ```



​	每一类语句在C语言编程中都扮演着重要的角色，合理使用这些语句可以构造出逻辑严谨、结构清晰的程序。因此，C语言中的语句种类包括但不限于表达式语句、复合语句（块语句）、控制流语句、声明语句、跳转语句、空语句、函数调用语句以及标签语句等。这些语句共同构成了C语言强大的语法结构，允许开发者以多种方式控制程序的执行流程。



## 2.C++语言下的语句分类

​	C++语言在继承了C语言的基础上，增加了一些新的特性和概念，这些新增加的特性也对语句的分类带来了扩展和补充。虽然C++保留了C语言中的大多数语句类型，如表达式语句、控制流语句（if-else、switch、for、while、do-while等）、跳转语句（break、continue、return、goto）等，但它还引入了一些面向对象和异常处理相关的新语句类型。以下是C++相比于C语言在语句分类上的一些扩展：

1. **声明语句的扩展**：

    - C++增加了类、模板等的声明语句，这是面向对象编程和泛型编程的基础。

2. **范围基于的for循环（Range-based for loop）**：

    - C++11引入了一种新的for循环语法，用于遍历容器（如数组、vector等）或其他序列。这使得遍历操作更加简洁。

    - 示例：

        ```cpp
        std::vector<int> vec = {1, 2, 3, 4, 5};
        for(int x : vec) {
            std::cout << x << std::endl;
        }
        ```

3. **异常处理语句**：

    - `try`和`catch`用于异常处理。`try`块用于包围可能抛出异常的代码，`catch`块用于捕获和处理异常。

    - 示例：

        ```cpp
        try {
            // 可能抛出异常的代码
        } catch (const std::exception& e) {
            // 处理异常
        }
        ```

    - `throw`语句用于抛出异常。

4. **类型转换语句**：

    - C++提供了静态类型转换（`static_cast`）、动态类型转换（`dynamic_cast`）、常量类型转换（`const_cast`）和重新解释类型转换（`reinterpret_cast`）等操作符，使得类型转换更加安全和清晰。

5. **声明式语句**：

    - C++允许更加复杂的声明式语句，如使用`auto`关键字进行自动类型推导。

​	这些扩展和补充增强了C++的表达能力，使其能够更好地支持面向对象编程、泛型编程、异常处理等现代编程范式。通过这些新的语句类型，C++程序员可以写出更加安全、高效和清晰的代码。

## 3.程序的三种基本结构

​	程序的三种基本结构，无论是在C语言还是C++语言中，都是相同的。这些基本结构构成了所有程序设计的基础，它们是：

### **顺序结构**：

- 顺序结构是最基本的程序结构，它按照代码的书写顺序逐条执行程序指令。程序的执行从一条语句到下一条语句，依次进行，没有任何的跳转或者分支。顺序结构是构建复杂程序逻辑的基础。
- 示例：变量声明后赋值，接着进行计算，最后输出结果，整个过程就是一种顺序结构。

### **选择结构**：

- 选择结构允许程序基于条件判断来选择不同的执行路径。它引入了决策制定，使得程序能够根据不同的输入或状态执行不同的代码段。常见的选择结构包括`if`、`if-else`、`switch`语句。
- 示例：根据用户输入的数值判断是正数、负数还是零，并输出相应的信息。

### **循环结构**：

- 循环结构使得程序能够重复执行一段代码，直到满足某个条件为止。这是处理重复任务、遍历数据结构等操作的基础。C语言和C++都提供了`while`、`do-while`、`for`等循环语句。
- 示例：计算从1加到100的总和。

循环结构在编程中用于重复执行一段代码直到满足特定的条件。循环结构可以分为两种主要类型：当型循环结构（pre-test loop）和直到型循环结构（post-test loop）。这两种循环的主要区别在于条件检查的时机，即是在循环体的执行之前还是之后。

#### (1)当型循环结构（Pre-test Loop）

当型循环结构首先检查条件，然后决定是否执行循环体。如果条件为真（满足条件），则执行循环体；执行完循环体后，再次检查条件，重复上述过程。如果条件为假（不满足条件），循环终止，继续执行循环之后的代码。

C语言和C++中的`while`循环是典型的当型循环结构示例：

```c
int i = 0;
while (i < 5) { // 条件检查在循环体执行之前
    printf("%d ", i);
    i++;
}
```

在这个例子中，首先检查`i < 5`的条件，如果为真，则执行循环体内的代码。循环体执行完毕后，再次检查条件，如此往复直到条件不再满足（即`i`不小于`5`）。

#### (2)直到型循环结构（Post-test Loop）

直到型循环结构在执行完循环体后检查条件。这意味着循环体至少会被执行一次，之后如果条件满足（注意，这里通常条件是继续循环的条件），则继续执行循环体；如果条件不满足，则终止循环，继续执行循环之后的代码。

C语言和C++中的`do-while`循环是典型的直到型循环结构示例：

```c
int i = 0;
do {
    printf("%d ", i);
    i++;
} while (i < 5); // 条件检查在循环体执行之后
```

在这个例子中，`do-while`循环先执行一次循环体，然后检查`i < 5`的条件，如果条件为真，则继续执行循环体。这保证了循环体至少执行一次，即使初始条件不满足。

#### (3)他们之间的区别

- **条件检查时机**：当型循环（如`while`循环）在循环体执行之前检查条件，直到型循环（如`do-while`循环）在循环体执行之后检查条件。
- **循环体执行次数**：当型循环可能一次都不执行循环体（如果初始条件就不满足），而直到型循环至少执行一次循环体，无论条件最初是否满足。

选择哪种循环结构取决于具体情况，例如，如果需要循环体至少执行一次，应选择直到型循环结构（`do-while`）。如果执行循环体之前需要评估条件，应选择当型循环结构（`while`或`for`）。

### 总结：

​	C语言和C++语言在这三种基本结构的支持上没有区别。它们都提供了相应的语法结构来实现顺序、选择和循环逻辑。这三种基本结构是构建任何复杂程序逻辑的基础，通过组合使用这些结构，可以实现几乎所有类型的程序设计需求。

​	不过，由于C++引入了面向对象编程、模板、异常处理等高级特性，相比C语言，C++在表达上更加灵活和强大。例如，C++中的范围基于for循环（range-based for loop）提供了一种更现代和简洁的方式来遍历容器，这是C语言中不具备的。但这些高级特性并不改变基本的程序结构原理，它们只是提供了更多的工具和方法来实现这些基本结构。

## 4.赋值语句的特殊写法

​	C/C++中的赋值语句的几种特殊写法，包括如何在赋值的同时进行条件判断和执行其他操作。具体来说，可以总结如下：

1. **赋值与运算的结合**：
    - 赋值操作可以和其他运算符结合使用，例如，`x /= 2;` 相当于 `x = x / 2;`。这样不仅完成了除法运算，同时将结果赋值给变量 `x`。又例如：`int x;  printf("x = 8的值是:%d",x = 8);`
2. **赋值与条件判断的结合**：
    - 赋值语句可以在`if`语句的条件中进行，使得可以在判断条件时同时改变变量的值。例如，`if ((a = b) > 0) t = a;` 在这里，首先执行赋值 `a = b`，然后判断 `a` 是否大于0，如果是，则将 `a` 的值赋给变量 `t`。
3. **链式赋值**：
    - C/C++允许进行链式赋值，这意味着可以在一行中给多个变量赋相同的值。例如，`a = b = c = 0;` 会将 `0` 赋给变量 `c`，然后将 `c` 的值（此时也是0）赋给 `b`，最后将 `b` 的值（此时也是0）赋给 `a`。

这些特殊写法提高了代码的紧凑性和某些情况下的执行效率，但可能会牺牲代码的可读性。因此，在使用这些特殊写法时需要考虑代码的清晰性和维护性。

### 赋值语句特殊讨论

​	在C和C++中，在赋值语句中，"="(赋值)运算符的左侧必须是一个左值（lvalue）。左值表示的是对象的身份（或位置），而不仅仅是对象的值。这意味着左值可以出现在赋值表达式的左侧，因为它们指向内存中的一个具体位置，可以存储（或重新存储）数据。

**左值的定义**

左值通常是指那些可以被引用的对象，包括但不限于：

- 变量（包括全局变量、局部变量）
- 数组元素
- 对象的属性（例如结构体的成员）
- 引用
- 可被解引用的指针（`*ptr`）

这些都是可以位于赋值运算符左侧的合法表达式，因为它们都代表了内存中的一个确定位置。

**例子**

以下是一些合法的左值示例：

```c
int x;
int array[10];
struct { int a; float b; } myStruct;

x = 20;                  // x是一个左值
array[5] = 100;          // array[5]是一个左值
myStruct.a = 15;         // myStruct.a是一个左值
```

​	在这些例子中，`x`、`array[5]` 和 `myStruct.a` 都是左值，因为它们都可以明确地引用内存中的位置。

**左值 vs 右值**

​	与左值相对的是右值（rvalue），右值是那些不具有持久存储位置的表达式，它们通常用于表示字面量或临时结果。右值不能出现在赋值语句的左侧，因为它们不指向明确的内存位置，因此不能存储值。

```c
100 = x;               // 错误: 100是一个右值，不能作为左值使用
(x + 10) = 20;         // 错误: (x + 10)是一个右值
```

特殊情况

在C++中，对左值和右值的概念有更细致的分类，包括将右值进一步细分为纯右值（prvalue，例如临时对象和字面量）和将左值（例如具有名称的对象）进一步细分为亡值（xvalue）。C++引入了右值引用和移动语义，这使得某些原本只能用左值的场景可以使用右值。

结论

总之，是的，在赋值语句中，"="的左侧必须是一个左值，因为只有左值才表示内存中的一个具体位置，这样才能存储赋值运算符右侧的值。

### 左值和右值讨论

​	在C++中，对于左值和右值的分类确实更为细致，特别是相对于C语言。在C++中，表达式被分为左值（lvalue）、亡值（xvalue），和纯右值（prvalue）。这三种类型的值共同组成了左值（glvalue）和右值（rvalue）的更广泛分类。让我们逐一解释这些术语：

#### **左值 (lvalue)**

左值（lvalue, locator value）代表一个对象的定位标识。它们指向一个具体的内存位置，因此可以出现在赋值运算符的左侧。左值包括：

- 变量
- 引用
- 解引用指针
- 数组元素
- 类成员

左值是持久的，即它们存在于内存中的确定位置，并在赋值表达式中可以被修改。

#### **亡值 (xvalue)**

亡值（xvalue, expiring value）是C++11中引入的一个概念，代表“将要过期”的值。它们是一种特殊类型的**右值**，既可以识别对象的位置又表示对象即将被销毁。亡值常常用于实现移动语义和转发。它们包括：

- 返回非引用类型的函数调用
- 显式转换为右值引用类型
- 访问即将被销毁的对象，如通过 `std::move()` 获得的对象

#### **纯右值 (prvalue)**

纯右值（prvalue, pure rvalue）是指不与任何内存位置关联的临时值，如字面量和临时对象。它们通常用于表达值本身而非值的位置。纯右值包括：

- 字面量（例如 `42`, `true`）
- 表达式计算结果（例如 `3 + 4`, `x * y`）
- 返回临时对象的函数调用

#### **左值和右值的更广泛分类**

- **广义左值（glvalue）**：包括左值和亡值。这是指能够标识内存位置的所有值。
- **右值（rvalue）**：包括亡值和纯右值。这是指可以移动的值，它们不必要持久存在于内存中。

#### **关于广义左值和右值中都含有亡值的讨论**

​	在C++中，“亡值”（xvalue）同时被分类为广义左值（glvalue）和右值（rvalue），这种分类可能初看起来有些混淆，但实际上反映了亡值所具有的特定属性和用途。理解这一点关键在于认识到亡值的两个主要特征：

1. **位置标识性**：亡值仍然表示一个对象的位置，这是它被归类为广义左值（glvalue）的原因。广义左值是指可以标识存储位置的值，即使这个位置上的对象可能即将销毁。这使得亡值仍然可以被引用或者有地址。
2. **即将销毁或可移动**：亡值通常指向即将销毁的对象或者已经无需维持原有状态的对象。这种“将要过期”的特性使得亡值非常适合进行资源的移动操作，这是它被归类为右值（rvalue）的原因。右值适合用于移动语义，因为它们通常表示临时对象或者是可以“被移动”的对象。

**结合例子理解亡值**

​	亡值（xvalue）在C++中是一个既属于广义左值（glvalue）也属于右值（rvalue）的特殊类型。这个双重分类允许它同时具备表示内存位置的属性（类似于左值）和可被移动的属性（类似于右值）。以下是一些示例来展示亡值如何在不同场景中表现为广义左值和右值。

**1. 亡值作为广义左值的例子**

​	广义左值的主要特点是它可以被引用，即它们具有地址可被取得。下面是一个展示亡值作为广义左值的例子：

```cpp
#include <iostream>

class Widget {
public:
    int data;
    Widget(int d) : data(d) {}
    Widget& operator=(Widget&& other) {
        data = other.data;
        return *this;
    }
};

Widget&& getTemporaryWidget() {
    return std::move(Widget(42));
}

int main() {
    Widget&& temporary = getTemporaryWidget(); // temporary 是一个亡值引用
    std::cout << "The data is: " << temporary.data << std::endl; // 可以取得亡值的地址
    return 0;
}
```

​	在这个例子中，`getTemporaryWidget()` 函数通过 `std::move()` 返回一个局部对象 `Widget(42)` 的右值引用，这里的 `std::move()` 不实际移动任何东西，而是将左值转换为亡值。返回的 `Widget&&` 是一个亡值，但因为它可以被引用并访问其成员，所以它也是一个广义左值。===其实还是有点没太看懂，总复习时来看看，待完成。

**2. 亡值作为右值的例子**

亡值作为右值最重要的特性是它适合被用于移动语义，这意味着可以从亡值中移动数据，从而优化资源使用。以下是一个示例：

```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> v1 = {1, 2, 3, 4, 5};
    std::vector<int> v2 = std::move(v1); // 使用亡值v1初始化v2

    std::cout << "v1 size: " << v1.size() << std::endl; // v1已经被移动，大小为0
    std::cout << "v2 size: " << v2.size() << std::endl; // v2现在拥有原本v1的数据
    return 0;
}
```

​	在这个例子中，`std::move(v1)` 将 `v1` 转换为一个亡值，这允许 `v2` 的构造函数从 `v1` 中移动数据，而不是复制。通过移动构造函数，`v1` 的内容被转移到 `v2` 中，`v1` 被留下为空。这里亡值 `std::move(v1)` 明显表现为一个右值，适合用于移动语义。===其实还是有点没太看懂，总复习时来看看，待完成。

​	总结：亡值的这种双重特性使其在C++中非常有用，特别是在涉及到性能优化和资源管理的场景中。通过将对象标记为可移动，亡值允许开发者编写更高效的代码，同时保持对内存位置的引用能力，这在设计需要地址信息的场景（如某些低层次操作）时特别重要。

**总结**

​	所以，亡值之所以同时包括在广义左值和右值中，是因为它们既具有位置的标识性（使它们可以像左值那样被引用），又具有即将销毁或可移动的特性（使它们适合用于右值操作，如移动语义）。这种分类反映了C++语言在设计上的一种权衡，旨在兼顾效率（通过移动语义）和表达力（通过清晰的值分类），使得资源管理更为高效和灵活。

#### **实际应用**

- **右值引用和移动语义**：C++11引入了右值引用（使用 `&&`），它允许编译器区分一个对象是应该被复制还是被移动。当一个右值被用来初始化一个右值引用时，可以进行资源的移动而非复制，从而提高效率。
- **完美转发**：使用模板和 `std::forward` 可以实现参数的完美转发，既支持左值又支持右值。

​	这种细致的分类在C++中的应用非常广泛，尤其是在现代C++（C++11及以后版本）中，它们对于优化性能、管理资源和函数重载解析非常关键。希望这个解释能帮助你更好地理解C++中的值分类及其重要性。

### `char* const p = "adada";`讨论

在C++中，关于 `char* const p = "adada";` 这个声明，需要澄清几个概念：

1. **声明与赋值**：
   - 这条语句实际上是一个变量声明，同时也是一个初始化操作，而不是一个典型的赋值语句。初始化发生在变量被创建时，赋值则是在变量已存在后改变其内容。
   - 在变量声明的同时进行的初始化，尽管语法上看起来像赋值，但在语义上处理为初始化。
2. **指针常量**：
   - `char* const p` 中的 `const` 修饰符修饰的是指针 `p`，不是指向的字符。这意味着 `p` 是一个常量指针，一旦被赋予一个地址值，就不能再指向其他地址，但是它指向的内容（字符）是可以修改的。
   - 在这个例子中，`p` 被初始化为指向字符串字面量 `"adada"`。由于 `p` 是常量指针，我们不能更改 `p` 的值（即它所指向的地址），但理论上可以修改它所指向的数据（尽管这里指向的是字符串字面量，实际上不应被修改，因为它通常存储在只读内存段）。
3. **右值引用**：
   - 右值引用在C++中使用 `&&` 符号表示，通常用于引用临时对象。例如，`int &&r = 10;`。在 `char* const p = "adada";` 这里，并没有使用右值引用。
   - `p` 不是一个右值引用，它是一个常量指针。这种类型的指针本身是个左值，因为它具有明确的标识（即 `p` 这个名字）和内存位置。

**结论**

​	因此，`char* const p = "adada";` 是一个声明常量指针 `p` 并初始化它指向字符串字面量 `"adada"` 的语句。`p` 是左值，因为它具有持久的存储地址，但作为一个指针的值（即它所持有的地址）在其生命周期内不能改变。此外，这并不涉及右值引用的使用。在处理字符串和指针时，尤其要注意 `const` 的位置和它修饰的对象，这决定了哪些操作是允许的。
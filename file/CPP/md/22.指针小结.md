# 指针小结(要有代码证明)

## (1) 指针变量的类型小结

- `int i;`：普通的整型变量 `i`。
- `int *p;`：指针变量 `p`，可以指向整型变量的地址。
- `int a[5];`：整型数组 `a`，包含 5 个整数。
- `int *p[5];`：指针数组，包含 5 个整型指针。
- `int (*p)[5];`：指向一个包含 5 个整数的数组的指针。
- `int f();`：函数声明，表示一个不接受参数返回整型值的函数。
- `int *f();`：函数声明，表示一个不接受参数返回整型指针的函数。
- `int (*p)();`：指向函数的指针，该函数不接受参数并返回整型值。
- `int **p;`：指向指针的指针，该指针指向另一个指向整型值的指针。

## (2) 指针的操作

- 指针的自增自减：`p++` 或 `p--` 会改变指针 `p` 指向的地址，使其指向下一个或前一个元素。
- 指针的赋值操作：示例中显示了将整型指针指向一个特定的地址。
- 指针的空指针 NULL：分配给 `char *p` 的 NULL 意味着它不指向任何有效的内存地址。

## (3) void 类型的指针

- void 类型的指针可以指向任何类型的数据，并可以在不同类型之间进行转换，但在使用之前需要进行适当的类型转换。

### 示例：

- `int *p;`：整型指针。
- `void *pv = &i;`：`void` 指针指向整型变量 `i` 的地址。
- 类型转换：例如，`int` 指针转换为 `float` 指针，需要明确的类型转换操作。

## (4)指针的使用场景

指针在C/C++中有广泛的应用，包括：

- **动态内存管理**：指针用于动态分配和释放内存（如使用 `malloc`, `free`, `new`, `delete`）。
- **数组和指针的关系**：数组名在大多数上下文中可以作为指向其首元素的指针使用。
- **函数通过指针传递参数**：可以通过指针传递变量的地址，从而允许函数修改调用者的变量。
- **构建复杂的数据结构**：如链表、树等数据结构中广泛使用指针来构建和链接各个元素。



## (5)指针的危险和注意事项

指针是一把双刃剑，它提供了强大的功能，但也容易导致程序错误，如：

- **野指针**：未初始化的指针。
- **悬挂指针**：指向已释放内存的指针。
- **内存泄漏**：未能释放已分配的内存。

正确使用指针需要谨慎，确保每个指针都指向有效的内存区

### 指针的定义和声明

指针变量是用来存储内存地址的变量。它的声明告诉编译器该变量将存储一个地址，这个地址指向特定类型的数据。例如：

```c
int* p; // p 是一个指向整型数据的指针
char* c; // c 是一个指向字符型数据的指针
```

这里，`int*` 和 `char*` 分别表示指向整数和字符的指针类型。指针本身也是一种类型，因此指针也占用内存空间。

## (6) 总结

- 指针在C语言中是一个强大的功能，允许直接访问和操作内存。
- 作者提到，指针的理解和使用应当非常谨慎，以避免程序中的潜在错误和崩溃。
- 对指针的理解和掌握可以让程序员更有效地控制程序的内存和数据结构。

​	在上述内容中，特别强调了指针类型和操作的重要性，并通过示例展示了如何声明和使用不同类型的指针变量。还说明了`void *`指针作为一种通用指针的使用方式，以及为何需要在不同类型之间转换指针时进行显式类型转换。指针在C语言中的使用非常灵活，但必须谨慎，以确保程序的稳定性和安全性。

## (7)NULL、nullptr和0的关系

### **1.NULL和0的关系**

看一个例子：

```c
FILE *fp;
fp = fopen("A1", "r");
if (fp == NULL) {
  // 文件打开失败的处理代码
  // ……
}
```

​	上面的fp == NULL是否可以换成  fp == 0呢？

在C语言中，`NULL` 是指针字面量，通常用于表示指针没有指向任何有效的内存地址。在标准C中，`NULL` 被定义为指针类型的零值，通常是 `(void*)0`。因此，在语义上，`NULL` 用于指针是为了增强代码的可读性和表达性，明确表示“无效指针”或“空指针”。

**替换 `NULL` 为 `0`**

在实际上，将 `fp == NULL` 替换为 `fp == 0` 是有效的，并且在C中这两种表达式在技术上是等价的。当`0`用在指针的上下文中时，编译器会自动将其视为空指针。所以，`fp == 0` 实际上与 `fp == NULL` 执行相同的操作，即检查 `fp` 是否是一个空指针。

**代码的可读性和最佳实践**

尽管 `fp == 0` 在技术上是正确的，使用 `fp == NULL` 通常更受推荐，原因包括：

1. **可读性**：`fp == NULL` 明确表达了 `fp` 是一个指针，而且这个表达式检查的是指针是否未被赋予任何有效地址。这使得代码更易于理解，尤其是对那些可能不太熟悉C语言的人。
2. **表达性**：`NULL` 更明确地表明意图是检查一个“空指针”，而不是简单的数值0，这有助于区分指针和整数类型的操作，尽管在这种情况下它们的行为相同。
3. **一致性**：在多数C项目中，使用 `NULL` 检查指针已经成为一种常见做法。保持一致性有助于维护代码的整洁性和规范性。

**示例代码**

```c
#include <stdio.h>

int main() {
    FILE *fp;
    fp = fopen("A1", "r");
    if (fp == NULL) {
        printf("File could not be opened.\n");
        // 更多错误处理代码……
    } else {
        printf("File opened successfully.\n");
        // 对文件进行操作的代码……
        fclose(fp);
    }
    return 0;
}
```

这段代码通过使用 `fp == NULL` 来判断文件是否成功打开，表达了明确的意图，并且符合C语言编程的最佳实践。

结论

尽管从技术上来说 `fp == 0` 和 `fp == NULL` 是等价的，但从编写高质量C代码的角度来看，推荐使用 `fp == NULL`，因为它提供了更好的可读性和明确性。这有助于代码的维护和未来的错误检查。

​	*自己在(C以及C++)编译器下试试,当一个指针被赋值为了NULL，再将这个指针和0判断是否相等吧。**待完成**，如果相等，说明NULL被定义为了0而不是(void\*)0？是这样吗？ 还是(void*)0也可以这样进行显式/隐式的转换为0呢？看看NULL和nullptr实际是如何定义的吧。在下面说到了当被定义成0时：当`0`用在指针的上下文中时，编译器会自动将其视为空指针(这句话基于什么前提呢？将NULL定义为0才可以吗？)。**待验证，待完成**。看看实际的nullptr和C/C++下的NULL是如何定义的：*
```cpp
namespace std
{
  typedef __SIZE_TYPE__ 	size_t;
  typedef __PTRDIFF_TYPE__	ptrdiff_t;

#if __cplusplus >= 201103L
  typedef decltype(nullptr)	nullptr_t;
#endif
}
```



### 2.nullptr和0的关系

​	在C++中，`nullptr`是一个关键字，用来表示空指针，它与C中的`NULL`有相似的用途，但是`nullptr`和`0`在C++中并不是等价的，尤其是在类型安全和重载函数的上下文中。下面是对`nullptr`与`0`差异的详细解释：

**`nullptr` vs `0`**

1. **类型区别**:
    - `nullptr`是一个nullptr类型的字面量，专门用于表示空指针。它可以自动转换为任何指针类型，但不是整数类型。
    - `0`是一个整数字面量。在C++中，虽然`0`可以被用作空指针常量，它仍然是整数，并且可以隐式转换为任何指针类型和整数类型。
2. **函数重载解析**:
    - 当使用`nullptr`时，C++编译器可以更精确地确定函数重载。例如，如果有两个重载函数，一个接受指针，另一个接受整数，使用`nullptr`时，编译器将选择接受指针的重载版本。
    - 使用`0`时，编译器可能需要更多的上下文来确定应该调用哪个重载函数，因为`0`可以被解释为指针或整数。

**示例：函数重载**

```cpp
#include <iostream>

void func(int x) {
    std::cout << "Integer overload: " << x << std::endl;
}

void func(int* ptr) {
    if (ptr == nullptr) {
        std::cout << "Pointer overload: null pointer" << std::endl;
    } else {
        std::cout << "Pointer overload: non-null pointer" << std::endl;
    }
}

int main() {
    func(0);          // Calls func(int)
    func(nullptr);    // Calls func(int*)

    return 0;
}
```

在这个示例中：

- 调用`func(0)`将解析为`func(int)`，因为`0`是整数。
- 调用`func(nullptr)`将解析为`func(int*)`，因为`nullptr`明确指示空指针。

结论

`nullptr`在C++中提供了一种类型安全的方式来表示空指针，相比之下，`0`虽然在技术上可以表示空指针，但它缺乏类型安全性，可能会导致模糊的函数调用解析。因此，在C++中推荐使用`nullptr`而不是`0`来表示空指针，以利用C++的类型系统提供更清晰、更安全的代码。

### 3.再探讨C语言的NULL

​	在C语言中，`NULL`被定义为指针常量。通常，`NULL`在C中被定义为`void*`类型的零值，通常是`(void *)0`。这意味着它是一个通用指针类型，可以被隐式转换为任何其他类型的指针。这种定义方式保证了`NULL`可以用在任何需要空指针的场合，而不会引起类型兼容性问题。

**C标准库（stddef.h或stdlib.h）中的定义示例**:

```c
#define NULL ((void *)0)
```

**C语言示例（使用NULL）**:

```c
#include <iostream>

int main() {
    int *ptr = nullptr;
    if (ptr == nullptr) {
        std::cout << "Pointer is null." << std::endl;
    }
    return 0;
}
```

​	C语言中的`NULL`旨在提供一个通用的空指针常量。

在C语言中，`NULL` 的定义具体取决于编译器和所使用的标准库的实现。然而，通常的实践是将 `NULL` 定义为 `0` 或 `(void*)0`。这两种定义各有其逻辑和历史背景：

1. **定义为 `0`**：
   - 定义 `NULL` 为 `0` 是基于C语言标准的规定，即整数常量 `0` 在需要指针值的上下文中自动转换为空指针。这种定义的好处是简单且直观，易于理解和使用。
   - 当使用 `0` 时，C语言标准确保它能够在指针上下文中正确地转换为一个空指针。

2. **定义为 `(void*)0`**：
   - 定义 `NULL` 为 `(void*)0` 的目的是明确指出这是一个指针类型。这种表示法在类型安全方面提供了更明确的指示，因为它避免了将 `NULL` 与整数类型混淆的可能性。
   - 使用 `(void*)0` 的好处在于它使 `NULL` 明确成为一个指针，这有助于避免将其误用为非指针类型的值。然而，在某些上下文中，`(void*)0` 可能需要显式地转换为其他具体的指针类型，因为 `void*` 类型指针不能直接赋值给其他类型的指针而不进行转换（这一点在C++中更加严格）。

标准定义的选择

大多数现代C编译器和标准库实现倾向于使用 `(void*)0` 定义 `NULL`，以强调其为指针的性质。这样的定义有助于提高代码的可读性和安全性，尤其是在与C++共用代码或库时。

在具体编程或查看代码时，可以通过查看您使用的编译器或开发环境中的 `<stddef.h>` 或 `<stdlib.h>` 头文件来确认 `NULL` 的确切定义。在一些编译器文档或源代码中，这些定义通常很容易找到。

结论

尽管在不同的系统和编译器中 `NULL` 的具体定义可能略有不同，但在任何情况下，它都是用来表示空指针的。了解这一点对于编写可移植和健壮的C程序至关重要。在编写跨平台代码时，理解和适应可能的差异也同样重要。



### 4.再探讨C++语言的nullptr

​	C++11引入了`nullptr`，它是一种新的关键字，专门用于表示空指针。`nullptr`的类型是`nullptr_t`，这是一个特殊的类型，只能赋值给指针或者用作布尔表达式。`nullptr_t`类型可以自动转换为任何类型的指针，但不可以直接转换为整数类型，这提供了比C中的`NULL`更好的类型安全性。

**C++标准中的类型定义示例**: `nullptr`本身是`nullptr_t`类型的一个唯一实例。`nullptr_t`定义了几个重要的操作，如**与任何类型的指针的比较操作，以及转换为布尔类型（用于条件判断）。它不能被当作整数使用，这解决了C中使用`NULL`（可能导致混淆的问题）的某些问题**。

**C++语言示例（使用nullptr）**:

```cpp
#include <iostream>

int main() {
    int *ptr = nullptr;
    if (ptr == nullptr) {
        std::cout << "Pointer is null." << std::endl;
    }
    return 0;
}
```

​	C++中的`nullptr`则提供了一种类型安全的空指针表示方法。通过引入`nullptr`和`nullptr_t`，C++旨在减少由于指针和整数之间的隐式转换可能引起的错误和混淆，增强了代码的清晰性和安全性。

### 5.C++下的NULL

在C++中，`NULL`通常是从C继承而来的，但由于C++的类型严格性和特性，`NULL`在C++中的使用与C语言有一些区别和局限。这些差异主要是由C++的类型安全特性和`nullptr`的引入引起的。

**C++中的 `NULL`**

在C++中，`NULL`仍然常常定义为`0`或者`(void*)0`，这与C语言中的定义相似。在C++中，`NULL`的定义通常在头文件（如`<cstddef>`）中给出，与C语言一样意图表示空指针。

**定义示例**:

```cpp
#define NULL 0
```
或者
```cpp
#define NULL ((void*)0)
```

然而，由于C++支持函数重载和更严格的类型检查，使用`NULL`（特别是当定义为`0`的时候）可能会导致一些问题。例如，在函数重载的环境下，`NULL`作为`0`可能被误识别为整数类型，而不是指针类型，从而引起歧义。

**C++11中的 `nullptr`**

为了解决这些问题，C++11引入了`nullptr`关键字，其类型为`nullptr_t`，专门用于表示空指针。与`NULL`相比，`nullptr`提供了更好的类型安全性，可以清晰地区分指针和整数，避免重载解析中的歧义。

**C语言中的 `NULL`**

在C语言中，`NULL`通常被定义为`(void*)0`，用于通用指针赋值，以表明指针不指向任何对象。C语言中没有函数重载的问题，所以`NULL`作为`(void*)0`使用时较少出现类型歧义的问题。

**C++中使用`NULL`和`nullptr`的区别**

- **类型安全**: `nullptr`比`NULL`提供更好的类型安全。在C++中使用`nullptr`可以避免与整数的混淆，特别是在函数重载和模板编程中。
- **函数重载**: 当存在接受整数和指针参数的重载函数时，使用`nullptr`可以确保编译器选择接受指针参数的版本，而`NULL`可能导致歧义。
- **现代C++推荐**: 现代C++编程中推荐使用`nullptr`而不是`NULL`，以利用其提供的类型安全和清晰的代码语义。

**示例代码**

```cpp
#include <iostream>

void func(int x) {
    std::cout << "Integer version called" << std::endl;
}

void func(char* ptr) {
    std::cout << "Pointer version called" << std::endl;
}

int main() {
    func(NULL);    // 可能调用 func(int), 依赖于NULL的定义
    func(nullptr); // 一定调用 func(char*)

    return 0;
}
```

在这个例子中，使用`nullptr`可以明确无误地调用接受指针参数的函数版本，而`NULL`的行为则取决于其定义，可能引起调用整数版本的函数，尤其是当`NULL`被定义为`0`时。

**结论**

在C++中，尽管`NULL`仍然可用，但`nullptr`提供了更为安全和明确的方式来处理空指针，特别是在涉及到函数重载和模板编程的上下文中。因此，在C++中推荐使用`nullptr`来替代`NULL`，以避免类型相关的潜在问题。
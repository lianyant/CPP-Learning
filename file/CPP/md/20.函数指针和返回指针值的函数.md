# 函数指针和返回指针值的函数

## 1.用函数指针变量调用函数

​	使用函数指针变量调用函数是C语言中一个高级且功能强大的特性，它允许程序在运行时选择或改变将要执行的函数。这种技巧可以提升代码的灵活性和复用性，尤其在实现回调函数、事件处理器或策略模式时特别有用。下面详细解释如何定义、初始化和使用函数指针，以及相关的注意事项。

​	函数指针是一种特殊类型的指针，它指向函数而不是普通的数据。通过函数指针，你可以把函数当作参数传递给其他函数，或者存储函数的地址以备后续调用。

### 定义函数指针

​	函数指针的定义必须包括函数的返回类型和参数类型。这里的关键是正确地使用语法，确保指针被定义为指向函数的指针，而不是其他类型。例如，定义一个指向接受两个整数参数并返回整数的函数的指针：

```c
int (*func_ptr)(int, int);
/* 数据类型标识符 (*指针变量名)(形参列表); 
 “数据类型标识符” 是指函数的返回值类型；“形参列表” 里可以只有类型说明符（不必带有形参名），多个类型说明符之间用逗号分隔。*/

/*关于是否需要写形参(变量)名的总结说明：
1.在C和C++编程中，函数声明可以不包括形式参数的名称，只需要指定其类型。这主要是因为在声明阶段，编译器主要关注函数的返回类型和参数类型，以确保在调用时使用正确的类型。
2.在函数定义时，必须给出每个参数的名称，因为这些名称将在函数体内被用来引用传递给函数的实际值。
3.对于函数指针，声明也可以不包括形式参数的名称，只需要参数的类型。*/
```

​	这里，`int (*func_ptr)` 表明 `func_ptr` 是一个指针，指向一个函数，该函数接受两个 `int` 类型参数并返回一个 `int` 类型的值。

### 初始化函数指针

​	一旦定义了函数指针，你可以将其初始化为指向具体的函数。假设有一个求两数最大值的函数：

```c
int max(int x, int y) {
    return (x > y) ? x : y;
}
```

​	你可以将函数指针 `func_ptr` 初始化为指向 `max` 函数：

```c
func_ptr = max;
```

### 使用函数指针调用函数

​	使用初始化后的函数指针调用函数与直接使用函数名调用函数的效果相同，但通过指针调用提供了额外的灵活性。例如：

```c
int result = func_ptr(10, 20);
// 或者 int result = (*func_ptr)(10, 20);
printf("The maximum value is: %d\n", result);
```

​	这里，通过函数指针 `func_ptr` 调用了 `max` 函数，传入参数 `10` 和 `20`，并打印出结果。

### 注意事项

- **函数指针的定义**：如上所示，函数指针的定义应清晰表达其指向的函数类型。错误的定义，如 `int *func();`，会导致解释为一个返回整型指针的函数，int *表示这个函数的返回值是指向整型变量的指针，这与开发者的本意不符。
- **函数指针的地址**：在某些环境下，例如 Visual Studio，函数的入口地址可能因编译器或链接器的优化策略而不直接暴露。实际使用中，这通常不影响函数指针的使用，因为编译器会处理这些底层细节。
- **指针运算**：对于函数指针，进行像 `p++`、`p--` 、`p+n（n代表一个数字）`这样的指针运算是没有意义且通常是不允许的。函数指针应当直接指向有效的函数地址，并用于调用。

### 实际应用

​	函数指针广泛应用于实现接口回调、事件监听器和多态行为等。在实际编程中，随着经验的积累，你会发现使用函数指针能够使代码更加灵活和动态，特别是在需要将函数作为参数传递给其他函数或需要在运行时决定调用哪个函数时。通过函数指针，可以根据不同的需求动态地调用不同的函数，从而实现代码的高度可配置和可扩展性。

### 额外说明

​	在某些开发环境中，如Visual Studio，当你将函数名（如`max`）赋给一个函数指针（如`func_ptr`）时，观察到的现象是`func_ptr`与`max`的值不相等。这是因为编译器和链接器可能采用了额外的中间层或跳转表（称为跳转表或地址表）来管理函数的调用。

这种机制通常用于以下几种目的：

1. **优化**：编译器可能通过间接寻址来优化函数调用，尤其是在涉及动态链接库（DLL）或其他模块化设计的情况下。
2. **安全**：间接调用可以增加代码的安全性，阻止潜在的恶意软件直接访问函数地址。
3. **调试支持**：在调试模式下，使用跳转表可以更方便地管理和重定向函数调用，便于执行如代码热替换等操作。

​	**示例和总结：**例如，你有一个简单的`max`函数：

```c
int max(int a, int b) {
    return (a > b) ? a : b;
}
```

在将这个函数的地址赋给函数指针时：

```c
int (*func_ptr)(int, int) = max;
```

​	在像Visual Studio这样的开发环境中，尽管`func_ptr`被赋值为`max`，在某些情况下查看这两个变量的值时可能会发现它们并不相等。`func_ptr`指向的是跳转表中的一个实际的函数入口地址，而`max`可能显示的是一个间接的或符号化的地址，用于调试和优化目的。

​	**结论：**这种差异通常不会影响程序的正常运行，因为无论如何，最终的函数调用都会正确地执行。作为开发者，通常不需要过于关注这些内部细节，除非你在进行底层的系统编程或需要对性能和内存布局有精确的控制。在高级编程中，了解这些机制有助于更好地理解你的代码在特定环境下的行为。在大多数应用程序中，你可以放心地使用函数指针，而不必担心这些底层的细节。



## 2.把指向函数的指针变量作为函数参数

​	将函数指针作为参数传递给其他函数可以创建非常灵活的代码，允许用户指定某些操作应该如何执行。这是策略模式的一个典型例子。

​	**示例：**假设你有一个数组排序函数，你希望允许用户定义排序的具体方式：

```c
void sort(int* array, int size, int (*compare)(int, int)) {
    for (int i = 0; i < size - 1; i++) {
        for (int j = i + 1; j < size; j++) {
            if (compare(array[i], array[j]) > 0) {
                int temp = array[i];
                array[i] = array[j];
                array[j] = temp;
            }
        }
    }
}

int ascending(int x, int y) {
    return x - y;
}

int descending(int x, int y) {
    return y - x;
}
```

你可以这样调用`sort`函数：

```c
int arr[5] = {5, 2, 9, 1, 5};
sort(arr, 5, ascending);
sort(arr, 5, descending);
```



### 再议：

​	使用函数指针作为函数参数是一种强大的C语言编程技巧，它提供了程序设计中的灵活性和扩展性。这种技术特别适用于需要根据上下文动态选择函数行为的情况。

#### 为什么使用函数指针作为参数？

​	将函数指针作为参数传递给另一个函数可以使得函数调用更加灵活，能够根据不同的需求调用不同的处理函数。这在设计通用库、框架或需要多态行为的系统时尤为重要。例如，你可能希望一个函数能够根据不同的比较策略对数据进行处理，而这些策略可以作为参数传入。

#### 示例解释

​	在给定的示例中，定义了两个函数：`max` 和 `wwmax`。`max` 函数简单地返回两个整数中的最大值。而 `wwmax` 函数则更加通用，它接受三个参数：两个整数和一个函数指针。这个函数指针指向的函数用于比较两个整数并返回结果。这样，`wwmax` 的行为可以通过传入不同的函数指针来动态改变。

```c
int max(int x, int y) {
    return (x > y) ? x : y;
}

int wwmax(int x, int y, int (*compareFunc)(int, int)) {
    return compareFunc(x, y);
}

int main() {
    int result;
    // 直接传递函数名作为函数指针
    result = wwmax(5, 19, max);
    printf("Result using max: %d\n", result);

    // 通过函数指针变量传递
    int (*func_ptr)(int, int) = max;
    result = wwmax(45, 21, func_ptr);
    printf("Result using function pointer: %d\n", result);

    return 0;
}
```

#### 功能和优势

1. **灵活性**：通过传递不同的函数指针，`wwmax` 可以用来执行各种比较操作（如最大值、最小值、或任何自定义比较），而无需修改其内部实现。
2. **代码重用**：相同的函数框架可以用于多种不同的操作，减少代码重复。
3. **扩展性**：随着程序的发展，可以很容易地添加更多的比较策略而不影响现有代码。
4. **模块化**：可以将特定的功能模块化，易于管理和维护。

#### 结论

​	在C语言中，将函数指针作为参数传递不仅提高了程序的灵活性，还增强了代码的模块化和可重用性。这种技术使得函数可以根据传入的逻辑动态地改变其行为，非常适合需要多态性和高复用性的场合。通过实际例子可以看出，使用函数指针作为参数可以使得程序结构更清晰，扩展更容易。



## 3.返回指针值的函数

​	返回指针值的函数在C语言中是一个重要的特性，允许函数返回动态分配的内存地址或全局/静态变量的地址。这种类型的函数可以非常有用，但也需要谨慎处理，以避免内存泄漏、悬挂指针或其它安全问题。

### 函数返回指针的定义

当函数需要返回一个指针时，它的返回类型应该是一个指针类型。这通常表明函数返回的是某种类型数据的地址。函数定义的一般形式如下：

```c
数据类型* 函数名(参数列表) {
    // 函数体
}
```

例如，一个返回整数指针的函数定义可能如下：

```c
int* createArray(int size) {
    int* arr = malloc(size * sizeof(int));
    // 初始化或操作
    return arr;
}
```

### 错误的示例和解释

在提供的错误示例中，函数尝试返回一个局部变量的地址，这是不安全的：

```c
int *add(int x, int y) {
    int sum = x + y;
    return &sum; // 错误：返回局部变量的地址
}
```

局部变量的生命周期只限于函数执行的时间框架内，一旦函数返回，局部变量的存储空间可能被回收或用于其他目的。尝试访问这个地址的值将导致未定义行为，通常是程序错误或崩溃。

### 正确的做法

为了安全地从函数返回指针，你可以使用以下方法：

1. **返回动态分配的内存**：使用`malloc`或相关函数分配内存，并返回指向这块内存的指针。调用者需要负责释放这块内存。

    ```c
    int* createArray(int size) {
        int* arr = malloc(size * sizeof(int));
        for (int i = 0; i < size; i++) {
            arr[i] = i;  // 示例初始化
        }
        return arr;
    }
    ```

2. **返回指向静态或全局变量的指针**：这种方法不推荐频繁使用，因为它会引入全局状态，但在某些情况下可以简化内存管理。

    ```c
    int sum;  // 全局变量
    int* add(int x, int y) {
        sum = x + y;
        return &sum;
    }
    ```

### 注意事项

- **内存泄漏**：当使用动态内存分配时，确保适时释放内存。
- **线程安全**：避免返回指向静态或全局变量的指针，尤其是在多线程环境中，除非使用适当的同步机制。
- **使用局部变量**：永远不要从函数返回局部变量的地址。

​	总结来说，返回指针值的函数在C语言中极为有用，但必须谨慎使用，确保返回的内存地址在函数返回后依然有效，且其生命周期可控。这样可以避免安全风险和程序错误。

### 拓展

​	对应的假设是这样： int add(int x, int y) {    int sum = x + y;    return sum;  } 

​	调用处： int p = add(1,3); 这样在函数中返回的临时对象就会被p接管从而导致其作用域等于p变量的作用域了。对吗？

​	在所描述的C语言中的情况里，对作用域和生命周期的理解需要稍作调整。当函数返回一个基本数据类型的值（如整型 `int`）时，这里涉及到的是值的拷贝，而不是像类实例或对象那样的“接管”。来具体看一下这个例子：

#### 函数定义和调用

```c
int add(int x, int y) {
    int sum = x + y;
    return sum; 
}
```

在上面的函数中，`sum` 是一个局部变量，它的作用域限于 `add` 函数内部，其生命周期也只持续到 `add` 函数的执行完毕。当 `add` 函数返回时，`sum` 的值被拷贝到返回值中。

#### 调用处

```c
int p = add(1, 3);
```

​	在这个调用处，`add` 函数的返回值（即 `sum` 的值）被拷贝到变量 `p` 中。这里发生的是一个值的拷贝行为，`p` 并没有直接“接管”任何对象或变量的生命周期，因为 `sum` 是一个整型值，不涉及到指针或复杂对象的动态分配管理。`p` 成为了这个返回值的一个独立副本，拥有自己的存储空间。

#### 关键点

- **值传递与生命周期**：对于基本数据类型，如 `int`，函数通过值返回。这意味着原始值被拷贝到接收变量中。函数内部的局部变量在函数返回时就销毁了，所以返回值是原始数据的一个拷贝。
- **内存与作用域**：局部变量（如函数 `add` 中的 `sum`）在函数执行结束后不再存在。返回值的拷贝被赋给了调用处的变量 `p`，而 `p` 的作用域是其被声明的代码块（比如一个函数体或更大的代码块），其生命周期由其作用域决定。

​	因此，在C语言中，当函数返回一个基本类型的值时，它返回的是值的拷贝，调用者得到的是这个值的一个完全独立的副本。对于更复杂的类型，如结构体或通过动态内存分配的数据，管理和传递的逻辑会有所不同，可能涉及到指针和内存的显式管理。

## 4.总结

​	总结来说，函数指针和返回指针值的函数是C语言中两个非常强大的特性，能够使程序设计更加灵活和模块化。正确使用这些特性可以帮助你构建出易于扩展和维护的系统。

### 	C/C++中对于函数名的讨论：

#### 1.C语言下：

​	在C语言中，函数名确实可以看作是该函数代码的入口地址，或者说是指向函数入口的指针。这意味着，当你使用函数名时，它可以被当做一个指针，指向函数的开始位置，在内存中的代码段（也称为文本段）。

**理解函数名作为地址**

​	函数名本身代表了函数代码的起始地址。在C中，这使得可以将函数名用作函数指针，而无需显式地取地址。例如，如果你有一个函数 `int add(int a, int b)`，你可以声明一个指向该函数的指针并赋值，而不需要使用取地址运算符（`&`）：

```c
int add(int a, int b) {
    return a + b;
}

int main() {
    int (*ptr)(int, int) = add;  // 注意这里没有用&add
    int result = ptr(3, 4);  // 调用函数指针
    return 0;
}
```

在这个例子中，`add` 在赋值给函数指针 `ptr` 时自动转化为指向其入口的指针。

**函数名与函数指针**

​	虽然函数名可以被视为指针，但在使用上有一些细微的差别。例如，函数名是一个常量，你不能改变函数名的值（即你不能使函数名指向另一个地址），而函数指针是变量，可以被重新赋值以指向不同的函数。

​	此外，函数名和函数指针在某些语义上是相互转换的，特别是在函数调用和地址赋值方面。但在表达意图时，使用函数指针可以提供更大的灵活性和明确性，比如在API设计或回调函数的实现中。

​	总的来说，理解函数名作为函数代码起始地址的代表是帮助理解C语言中函数如何被调用和管理的一个重要概念。

#### 2.C++语言下：

​	在C++中，函数名代表函数代码的地址这一概念与C语言是相同的。函数名在C++中也可以看作是指向函数的指针，尤其是在涉及到函数指针、回调、或将函数作为参数传递给其他函数时。这一点在C++中同样适用，不过C++提供了更多复杂的特性，如类成员函数指针、重载函数、模板函数等，这些特性在处理函数地址时要更加小心。

**函数指针**

基本的函数指针用法在C++中与C相同：

```cpp
int add(int a, int b) {
    return a + b;
}

int main() {
    int (*ptr)(int, int) = add;  // 无需使用&符号
    int result = ptr(3, 4);  // 通过函数指针调用函数
    return 0;
}
```

**类成员函数指针**

对于C++的类成员函数，需要使用特定的语法来处理函数指针，因为类成员函数与普通函数有不同的调用约定，通常包含一个隐含的`this`指针。例如：

```cpp
class MyClass {
public:
    void memberFunc(int x) {
        std::cout << "Value: " << x << std::endl;
    }
};

int main() {
    void (MyClass::*ptr)(int) = &MyClass::memberFunc;  // 注意必须使用&符号
    MyClass obj;
    (obj.*ptr)(10);  // 通过对象调用成员函数指针
    return 0;
}
```

**重载函数**

在处理重载函数时，你需要特别小心，因为必须明确指定所使用的重载版本的类型，否则编译器无法推断你指的是哪一个函数：

```cpp
void func(int x) {
    std::cout << "Int version: " << x << std::endl;
}
void func(double x) {
    std::cout << "Double version: " << x << std::endl;
}

int main() {
    void (*ptr)(int) = func;  // 明确选择接受int参数的版本
    ptr(5);
    return 0;
}
```



### **特殊点讨论：函数指针指向各种类函数时是否需要在函数名之前加&**

#### **普通(全局)函数**

​	在C++中，普通函数的名字，如`add`，可以直接用作指向该函数的指针。这是因为函数名在被用作值的上下文中会自动被转换成指向该函数的指针。编译器在遇到函数名被赋给相应类型的函数指针时，会自动将其解释为函数的地址。因此，使用`add`代替`&add`是合法的，因为编译器会进行隐式转换。在C语言中，普通函数的名称，比如 `add`，同样可以直接用作指向该函数的指针，这与C++中的行为一致。当函数名在需要函数指针的上下文中使用时，它会自动被转换成指向该函数的指针。因此，在C中，`add` 和 `&add` 都有效且等价，因为编译器会在需要时自动进行隐式的地址取用转换。总结起来就是：普通全局函数名在用作函数指针的上下文中自动被视为函数的地址，所以`&`是可选的。

#### **静态(全局)函数**

​	在C和C++中，关于全局函数（包括静态全局函数(即限定在文件内部可见的函数)和普通全局函数）和函数指针的处理是一样的。无论函数是否被定义为静态（`static`），其名字在被用作指向该函数的指针时的行为都是相同的。即：**不需要显式使用 `&` 操作符** 来取得函数的地址。函数名本身在需要函数指针的上下文中会自动转换为指向该函数的指针。

当声明一个静态全局函数，比如：

```c
static int add(int x, int y) {
    return x + y;
}
```

这个函数`add`被定义为静态，这意味着它只在定义它的文件中可见。但是，如果你在同一个文件中使用它来初始化一个函数指针，你可以直接使用函数名而不需要加 `&`：

```c
int main() {
    int (*funcPtr)(int, int) = add;  // 直接使用函数名，无需&
    int result = funcPtr(3, 4);
    printf("Result: %d\n", result);
    return 0;
}
```

​	在这个例子中，尽管`add`是静态的，但是在将它赋给函数指针`funcPtr`时，其地址的获取方式与非静态函数相同。因此，不需要显式使用`&`符号。无论在C还是C++中，函数（包括静态全局函数和非静态全局函数）名在用作函数指针的上下文中会自动被转换成指向该函数的指针，因此在赋值给函数指针时通常不需要使用`&`符号。这简化了代码的书写，使其更加简洁易读。这种行为适用于全局静态和非静态函数。

#### **类普通成员函数**

​	对于类成员函数，情况则有所不同。类成员函数需要与特定对象的上下文关联，因此它们的处理方式与普通函数不同。成员函数指针不仅要存储函数地址，还需要考虑到与对象实例的关系（如通过`this`指针）。因此，C++规定必须使用`&`运算符来显式获取成员函数的地址。

​	这种语法要求强调了成员函数与对象状态的绑定关系，即成员函数的执行依赖于特定对象的状态。这就是为什么你需要使用`&MyClass::memberFunc`而不是`MyClass::memberFunc`的原因。如果省略了`&`，编译器可能无法正确解析意图，因为成员函数名称本身并不自动表示地址。总结起来就是：必须显式使用`&`来取地址，因为普通成员函数依赖于特定对象的上下文，且成员函数的指针语法需要明确表示这种依赖。

#### **类静态成员函数**

​	非静态成员函数是与特定的对象实例相关联。对于**静态成员函数**的情况，处理方式有所不同，因为静态成员函数不依赖于任何特定对象的状态。

​	静态成员函数属于整个类，而不是类的任何特定对象。因此，它们不需要`this`指针。你可以认为静态成员函数更类似于普通函数，但它们仍然保留在类的命名空间内。

​	对于静态成员函数，你可以使用与普通函数相同的方式来处理函数指针，不需要使用`&`符号来获取其地址。这是因为静态成员函数的名字在用作值的上下文中，也会自动被视为指向该函数的指针。

示例：

```cpp
class MyClass {
public:
    static void staticMemberFunc(int x) {
        std::cout << "Value: " << x << std::endl;
    }
};

int main() {
    void (*ptr)(int) = MyClass::staticMemberFunc;  // 注意这里不需要使用&符号
    ptr(10);  // 调用静态成员函数指针
    return 0;
}
```

​	在这个例子中，`MyClass::staticMemberFunc` 直接赋值给函数指针`ptr`，无需使用`&`。这体现了静态成员函数与普通函数在使用上的相似性，尽管它们在语法上属于类。总结起来就是：**静态成员函数**不依赖于类的实例，因此可以像普通函数那样直接通过函数名引用，不需要`&`符号。这种方式简化了对静态成员函数的引用和使用，使其在语法上更接近于普通函数，但仍然受到类的封装和命名空间规则的约束。

#### **进一步说明**

​	**问题1**：关于函数指针指向类的普通成员函数时需要在类的成员函数名之前加上&的讨论：对于类成员函数，情况则有所不同。类成员函数需要与特定对象的上下文关联，因此它们的处理方式与普通函数不同。成员函数指针不仅要存储函数地址，还需要考虑到与对象实例的关系（如通过`this`指针）。  这是因为普通成员函数有个隐藏的形参，是this指针。

讨论：类的普通成员函数隐含一个`this`指针作为其参数，这个`this`指针指向调用该函数的对象实例。虽然在成员函数内部`this`指针是隐式存在的，可以通过一个示例来展示它是如何工作的：

```cpp
class MyClass {
public:
    int value;

    void setValue(int value) {
        this->value = value; // 显式使用this指针来区分成员变量和参数
    }

    void show() {
        std::cout << "Value: " << this->value << std::endl; // 显式使用this指针访问成员变量
    }
};

int main() {
    MyClass obj;
    obj.setValue(100);
    obj.show(); // 显示Value: 100
    return 0;
}
```

​	在这个例子中，`setValue`和`show`函数使用`this->value`显式地引用成员变量。这显示了`this`指针如何在成员函数内部隐式地提供对对象实例的访问。

​	**问题2**：之所以函数指针指向普通成员函数时需要在普通成员函数之前加上&，是因为不加&时根本 获取不到此函数的地址，就如同调用普通成员函数时需要使用对象，是需要一个对象才能调用到普通成员函数得，但是没有对象时就需要在前面加上&来显式获取到普通成员函数得内存地址才行。我理解对吗？

讨论：对于非静态成员函数，需要使用`&ClassName::FunctionName`来获取函数的地址，因为成员函数与类的实例相关联。在C++中，成员函数与普通函数不同，因为它们需要通过特定对象的上下文来调用，所以需要特殊的语法来正确处理它们的地址。直接使用成员函数名，如`ClassName::FunctionName`，不提供`&`运算符，是因为这在C++语法中不合法，而且没有语义。在C++中，对于成员函数，我们使用`&`来明确指出我们需要函数的地址，而不是尝试调用它。例如：

```cpp
class MyClass {
public:
    void myFunc() {
        std::cout << "Function called" << std::endl;
    }
};

int main() {
    void (MyClass::*funcPtr)() = &MyClass::myFunc;  // 获取成员函数地址
    MyClass obj;
    (obj.*funcPtr)();  // 通过对象调用成员函数指针
    return 0;
}
```

​	在这个示例中，使用`&MyClass::myFunc`来获取`myFunc`成员函数的地址，并通过一个实例`obj`来调用它。

​	那么问题2中对于成员函数指针的理解是正确的，确实需要使用`&`来显式获取成员函数的地址，这与成员函数的调用依赖于对象的实例相关。

#### **总结**

​	虽然C++在函数名作为地址的概念上与C相似，但C++中的高级特性（如类、重载、模板）需要更精确的语法和更明确的类型信息来正确处理函数指针。理解这些细节对于有效地在C++中使用函数指针至关重要。
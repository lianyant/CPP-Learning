# auto、头文件防卫、引用与常量（需要代码验证）

​	C++语言与C语言比起来多了一些基本知识，这里进行一些必要的补充，当将来再遇到基本知识时，也会随时补充讲解。

## 1.局部变量和初始化

​	严格来讲，在C语言中，如果某个函数中需要用到一些局部变量，那么局部变量都会集中定义在函数开头，而在C++中不必遵循这样的规则，随时用随时定义即可。当然，作用域一般就是从定义的地方开始到该函数结束为止。当然，也有例外，例如如果在一个循环中定义的变量就只在循环内有效，在一个{}包着的语句块中定义的变量就只能在该语句块内有效。典型的如for（int i=0；i＜100；i++）{…}，i的作用域就仅仅限制在for循环体内。

​	传统编码方式中，可以使用“=”(叫做赋值运算符)在定义变量的时候进行初始化。代码如下：

```cpp
int abc = 5;
```

​	在C++新标准中，可以使用“{}”在定义变量的时候进行初始化。代码如下：

```cpp
int abc{5};
```

​	常见的for语句按照如下方式书写：

```cpp	
for (int i = 0; i < 100; i++) {……}
```

​	针对以前的for语句，按照这句话所描述的：“在C++新标准中，可以使用“{}”在定义变量的时候进行初始化。”，可以换一种写法。代码如下：

```cpp
for (int i{0}; i < 100; i++) {……}
```

​	在看到了C++新标准中“{}”的用法后，需要额外说明的是，在“{}”之前还可以增加一个“=”号。如下代码：

```cpp
int abc = {5};
for (int i = {0}; i < 100; i++) {……}
```

​	在上面的“{}”用法中，只涉及一个数据，因为只有一个变量来接收数据。实际上，如果定义一个数组，那么是可以在“{}”中包含一组数据的。代码如下：

```cpp
int a[]{11,12,34};// 这里没使用等号
int b[] = {11,12,34};// 这里使用了等号
```

​	建议在学习的时候，把这些新标准的写法单独整理和记录一下，新标准中引入“{}”这种给变量初值的方法也是有一些考虑和好处的。例如下面这行语句：

```cpp
int abc = 3.5f;
```

​	上面这行代码是可以编译通过的，但执行起来后会发现，实际上abc因为是int类型，所以3.5的小数部分会被截断，结果是abc的值等于3。那下面这种C++新标准语法呢？

```cpp
int abc{3.5f};
```

​	上面这行代码根本无法编译通过，直接报语法错，这样做的好处是不会使数据被误截断，进一步保证所写的代码的健壮性。

​	再看一例，用“（）”也可以对变量进行初始化：

```cpp
int adc(12); // 通过()初始化变量
```

​	当然，C++新标准中增加了不少初始化变量的方式，但这里无须一一提及，随着后面内容的展开，不久之后都会见面。



### 对以上讨论的内容补充

​	上面的讨论正确地概述了 C++ 中变量初始化和作用域的一些关键概念，同时也比较了 C 语言和 C++ 在变量定义和初始化方面的一些差异。下面是对您提供的信息的一些补充和澄清：

#### 变量定义和作用域

- **C语言中的变量定义**: 在 C 语言中，确实推荐在函数开头部分定义所有局部变量，这主要是由于 C89/C90 标准的限制。但从 C99 开始，C 也支持在代码中任何位置声明变量，类似于 C++。
  
- **C++中的变量定义和作用域**: C++ 支持在需要时定义变量，这包括在循环内或任何代码块中。这样做提高了代码的清晰度和局部性，有助于减少错误并提升性能（因为可以尽可能晚地初始化变量）。

#### 变量初始化方式

- **传统的赋值初始化**: 如 `int abc = 5;`，这是最常见的初始化方式，直接使用 `=` 进行值的赋予。

- **列表初始化（C++11及以上）**: `int abc{5};` 这种使用大括号的初始化方式是 C++11 引入的，可以防止数据丢失或转换错误，增强类型安全。
  
- **拷贝初始化与直接初始化**: 使用 `int abc = {5};` 是拷贝初始化，而 `int abc{5};` 是直接初始化，两者在单个值的情况下作用相同，但在复杂类型和类的构造函数中可能有不同的效果。

- **对于浮点到整型的隐式转换问题**：使用 `{}` 初始化时，C++ 编译器会阻止浮点数到整数的隐式转换，如果存在精度损失，如 `int abc{3.5f};` 会导致编译错误，这是一种防止潜在错误的安全措施。

#### 数组和其他复合类型的初始化

- **数组初始化**：`int a[]{11,12,34};` 和 `int b[] = {11,12,34};` 都是有效的，前者是列表初始化，后者是拷贝初始化，两者在这种情况下作用相同。

- **使用圆括号进行初始化**：`int adc(12);` 这种初始化方式在 C++ 中也是可用的，特别是对于非聚合类型更为常见。

#### 总结

​	上面的讨论其实非常详细，准确地描述了 C++ 中的多种变量初始化方法及其考量。这些不同的初始化方式让 C++ 在类型安全和初始化控制上比 C 语言更为强大和灵活。在学习和使用 C++ 时，确实值得深入理解并掌握这些初始化方法，以编写更健壮、安全的代码。

### 对以上讨论的内容补充的补充

之前的解释可能在术语上有些混淆，特别是关于列表初始化、拷贝初始化和直接初始化的部分。让我们澄清一下这些术语，确保我们对 C++ 初始化的理解是准确的：

#### 初始化的类型

1. **直接初始化**
    - **语法**：使用圆括号 `()` 或大括号 `{}` 进行初始化，例如 `int x(5);` 或 `int x{5};`。
    - **上下文**：通常用于当需要显式调用构造函数时，特别是当类型转换可能不明确或存在多个构造函数候选时。对于非聚合类型的类对象，这种初始化方式直接调用匹配的构造函数。
2. **拷贝初始化**
    - **语法**：使用等号 `=` 进行初始化，例如 `int x = 5;`。
    - **上下文**：这种初始化方式在赋值的右侧创建一个临时对象，然后通过拷贝构造函数或移动构造函数将其值赋给左侧的对象。拷贝初始化不仅限于使用等号，列表初始化也可以触发拷贝初始化，如 `int x = {5};`，特别是当类型匹配时（无需隐式转换）。
3. **列表初始化**（特性来自 C++11）
    - **语法**：使用大括号 `{}` 进行初始化，例如 `int x{5};` 或 `int y = {5};`。
    - **上下文**：这种方式尤其在防止数据丢失或隐式类型转换时非常有用，例如尝试使用浮点数初始化整数时会导致编译错误。列表初始化可以避免窄化转换。

#### 示例和澄清

- **直接列表初始化**：`int x{5};`
    - 这是直接初始化的一种形式，使用了列表初始化的语法。
- **拷贝列表初始化**：`int y = {5};`
    - 这同样是列表初始化，但形式上类似于拷贝初始化。在这种情况下，它可能不涉及实际的拷贝构造调用（特别是对基本数据类型），但语法上使用了等号。

​	总结来说，直接初始化和拷贝初始化是两种基本的初始化形式，而列表初始化是 C++11 引入的一种可以防止窄化转换的特别语法，它可以用于直接初始化或拷贝初始化，取决于是否使用等号。希望这次解释能更准确地帮助你理解这些术语。

## 2.auto关键字简介(后面章节会深入讨论)

​	auto关键字其实在C++98中就已经有了，只是那时候这个关键字没什么作用，但是到了C++11中，auto被赋予了全新的含义——变量的自动类型推断。

​	auto可以在声明变量的时候根据变量初始值的类型自动为此变量选择匹配的类型（这表明在声明变量的同时也要给变量初始值）。auto的自动类型推断发生在编译期，所以使用auto并不会造成程序运行时效率的降低。

​	换句话说，在定义一个变量的时候，如果变量类型能够由系统推断出来，就不需要显示指定类型。看看如下范例：

```cpp
auto bvalue = true;
auto ch = 'a';
auto dv = 1.2;
auto iv = 5;
auto ff = 5.2f;// 被推断为什么？
```

​	有些类型名很长，如后面要学习到的泛型，那么，使用auto就能避免书写很长的类型名。暂时先掌握这么多，后面会不断深入学习auto。

## 3.头文件防卫式声明

​	C/C++头文件中有关于#ifndef、#define、#endif的用法(前面《15.编译预处理详解》中提到过)。那么，看一看在这里如何使用。

​	通过下面的语言描述创建一个范例：

（1）头文件head.h中有如下定义：

```cpp
int g_globalh1 = 8;
```

（2）头文件head2.h中有如下定义：

```cpp
int g_globalh2 = 5;
```

（3）在主源文件（MyProject.cpp）中需要用这两个全局变量，代码如下：

```cpp
#include "head.h"
#include "head2.h"
#include <iostream>
using namespace std;
int main()// 主函数
{
    cout << g_globalh1 << endl;// 8
    cout << g_globalh2 << endl;// 5
}
```

执行上面这段代码，目前为止并没有什么问题。

（4）随着项目的增大，需要定义更多复杂的数据类型，假如现在因为一些原因需要在头文件head2.h中包含头文件head.h，于是头文件head2.h内容修改如下：

```cpp
#include "head.h"
int g_globalh2 = 5;
```

此时编译，出现重定义错误。这是因为在源文件MyProject.cpp文件中有如下内容：

```cpp
int g_globalh1 = 8;
int g_globalh1 = 8;
int g_globalh2 = 5;
```

显然globalh1被定义了两次，因此编译的时候提示出现重定义错误。

这非常让人头疼，因为保不准哪个头文件就#include了其他头文件，也保不准哪个.cpp源文件无意中就#include两次同一个头文件，上面这种是间接通过head2.h重复#include了head.h，那直接重复#include也是不可以的。例如如下代码，系统编译时也会报错：

```cpp
#include "head.h"
#include "head.h"
```

既然重复#include的问题时有发生，无法避免，那么如何解决这个问题呢？这就要从.h头文件本身入手，通过使用#ifndef、#define、#endif解决这个问题。

首先，改造头文件head.h。改造后的内容如下：

```cpp
#ifndef __HEAD__
#define __HEAD__
int g_globalh1 = 8;
#endif
```

接着，改造头文件head2.h。改造后的内容如下：

```cpp
#ifndef __HEAD__
#define __HEAD__
int g_globalh1 = 8;
#endif
```

有一点必须说明：每一个.h头文件的#ifndef后面定义的名字都不一样，不可以重名。

如此修改后再次编译，不难发现，编译通过并能成功执行，奥妙在哪里？就在于通过使用#ifndef、#define、#endif的组合，避免了.h头文件中的内容被多次#include。例如当head.h第一次被#include到MyProject.cpp中时，`#ifndef __HEAD__`条件成立，因此下面两行代码都被#include到MyProject.cpp中：

```cpp
#define __HEAD__
int g_globalh1 = 8;
```

但是假如第二次head.h被#include到MyProject.cpp中时，`#ifndef __HEAD__`  条件就不成立（因为`#define __HEAD__`代码行的存在），这样，上面两行内容就不会再次被#include到MyProject.cpp中，从而避免了重定义等错误的发生。

所以要求读者在书写.h头文件的时候，要习惯性地在文件头部增加#ifndef、#define语句行，在文件末尾增加#endif语句行。出现在.h头文件中的这三行代码，被习惯性地称为“头文件防卫式声明”。

## 4.引用

​	引用是为变量起的另外一个名字（别名），一般用“&”符号（以往看到过该符号，但含义与这里并不相同）表示。之后，该引用和原变量名代表的变量看成是同一个变量。所以，在理解时要理解成：定义引用并不额外占用内存。或者也可以理解成，引用和原变量占用的是同一块内存。当然，有细致的研究者通过研究编译器，认为引用是占内存的，但是作为学习者，只需要理解成引用不额外占用内存即可。

看看如下范例：

```cpp
int value = 10;
// refval就是引用(其类型是引用类型)
int& refval = value;// value的别名是refval, &在此不是取地址运算, 而是起标识作用
refval = 13; // 就等价于value = 13;
```

定义引用类型的时候必须进行初始化，不然给哪个变量起别名呢？看看如下范例，找找代码行中的错误：

```cpp
int& refval2;// 错误,定义用于类型时必须初始化
int& refval3 = 10;// 引用必须绑定到变量或对象上，不能绑定到常量上
int bvalue = 89;
float& refbvalue = bvalue;// 错误，类型要相同
```

​	*以上的代码需要自己运行看看实际效果是什么，待完成。(完成后删除本句)*

看看如下范例，注意比较，看看“&”作为引用和作为取地址符时的使用区别：

```cpp
int a = 3;
int &b = a;// 引用，注意&符号在=(赋值运算符)的左侧
int *p = &a;// 取地址符，注意&符号在=(赋值运算符)的右侧
```

再看一个比较完整的范例——引用作为函数形参：

```cpp
void func(int& ta, int& tb)// 形参类型都是引用类型(整形引用)
{
    ta = 4;
    tb = 5;
}
int main()// 主函数
{
    int a = 13;
    int b = 14;
    func(a,b);
    cout << a << "  " << b << std::endl;// 4  5
    return 0;
}
```

## 5.常量

常量就是不变的量。前面讲解的常量一般都是具体的数值，如10、23.5等。

### 1．const关键字

​	该关键字有很多作用，但这里不准备多介绍，主要是先熟悉一下。const表示不变的意思。定义变量时，可以在前面增加const关键字，一旦增加该关键字，该变量的值就不可以发生改变。看看如下范例：

```cpp
const int var = 17;// 一种承诺,表示这个变量的值不会发生改变
var = 18;// 修改其值，导致编译的时候就会报错，编译器会检查这个const承诺
```

​	那么，var的值到底是否可以修改？实际上可以修改，但强烈建议不要这样做，以免产生问题，既然承诺为const，就不要修改它的值。但作为探索，如何修改var值，看如下代码：

```cpp
const int var = 17;
int &var2 = (int&)var;
var2 = 5;
```

​	上面代码如果通过设置断点观察，能够看到var的值已经变成了5，但有意思的是，如果增加下面两行代码来分别输出var和var2的值，发现实际输出的var值和调试时看到的var值不一样：

```cpp
std::cout << var << std::endl;// 17
std::cout << var << std::endl;// 5，这从侧面论证引用实际上不是别名这么简单
```

再看一例：

```cpp
int func()
{
    return 3;
}
int  main()
{
    int v1 = 12;
    const int v2 = v1 + func();// 运行的时候求职也是可以的，但很少人会这样写代码吧
    return 0;
}
```

### 2．constexpr关键字(下面这部分对于《32.1.constexpr关键字》含没有讨论到的内容,待补充讨论)

这是C++11引入的关键字，也代表一个常量的概念，意思是在编译的时候求值，所以能够提升运行时的性能。编译阶段就知道值也会带来其他好处，例如更利于做一些系统优化工作等。

看这个范例：

```cpp
constexpr int var = 1;// 正常
int b = 5;
constexpr int var2 = b;// 编译报错(为什么报错？原理是什么？)
```

再看如下范例：

```cpp
constexpr int var1 = 1;
constexpr int var2 = 11 * func1(12);
```

​	上面代码用到了func1函数，那func1函数要怎样写呢？这里必须注意，因为var2是常量，初始化时调用了func1函数，所以func1也得定义成constexpr。代码如下：

```cpp
constexpr int func1(int abc)
{
    abc = 16;
    int a3 = 5;
    return abc * a3;
}
```

但是，在书写func1函数时必须小心，其中的代码尽可能简单。而且，某些代码出现在func1函数中还会导致编译无法通过。例如，在func1函数中定义一个未初始化的变量就会导致编译出错，必须在定义的时候初始化：

```cpp
int unvar;
```

​	再如，如果下面的for循环语句出现在func1函数中，那么for循环中的printf语句也同样会引发编译错误，读者可以自行尝试：

```cpp
for (int i = 0; i < 100; i++)
{
    // 这句printf语句会导致编译不过，不是这个函数有问题，而是因为加了constexpr关键字所导致的问题
    printf("good");
}
```

还可以进行一些尝试：

```cpp
constexpr int func1(int abc)
{
    abc = 16;
    int a3 = 5;
    return abc * a3;
}

int k = 3;
constexpr int var = 11 * func1(k);// 编译错误，不可以用变量k作为参数
int k2 = func1(k);// 用变量k作为参数时调用constexpr函数不会有问题，
				// 此时该函数相当于普通函数，结果当然也是在执行期间产生
```

​	可以看到，加了constexpr修饰的函数不但能用在常量表达式中，也能用在常规的函数调用中。

​	再看一段比较奇怪的代码：

```cpp
constexpr int var = 3;
std::cout << var << std::endl;
int& var2 = (int&)var;
var2 = 5;// 该值也能修改,通过设置断点调试可以看到var值也被修改为了5
std::cout << var2 << std::endl;// 5
std::cout << var << std::endl;//3,但实际输出结果时var输出为3
```

如果再接着写这样的判断代码：

```cpp
if (var == var2){...}
```

​	不难发现，尽管设置断点调试时，var和var2看起来值相等，但是上面这个条件却不成立，这几乎可以肯定是编译器内部进行了一些特殊的处理。虽然在Visual Studio 2019中var和var2代表同一块内存（跟踪调试时观察到的），但应该只是假象，原变量（var）应该和别名（var2）处于不同的内存中。

​	常量表达式概念要重视，例如在switch语句中，其里面的case语句后面跟随的值在语法上要求必须提供一个常量表达式。换句话说，有些场合，语法要求必须提供常量表达式而不是变量。

​	目前，对const和constexpr关键字只需要进行简单了解和认识，无须深究，随着日后学习的深入和更进一步的时候，也许会有更多的认识和体会。

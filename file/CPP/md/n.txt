待办：

手机上内容放到这里来()

书上遗留问题内容(C语言结束后来加到此处来) 以及语雀内容C语言结束后过一遍
语雀上针对c的补充内容
md文档中的代码要跑一遍

培训时做的疑问笔记(C部分)

函数的形参内存分配，堆栈等 、给函数调用分配一些内存来保存提到的这些信息（局部变量、函数参数、函数调用关系等）   详细的解释描述说明等
找出来

编译过程除了预处理之外的其他更为详细步骤也补充进来
“静态存储区”和“动态存储区”的概念以及所属的两个分类的内存划分弄明白
数组名不能被赋值或者修改，如果将数组名赋值给指针呢？好像没什么问题啊
============================

从C++部分开始，对照着之前的笔记开始复习
语雀上针对c++的补充内容  书上的笔记也要参考

、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、

std::ref


培训时做的疑问笔记

uint8_t*到const uint8_t*的转换是隐式的   将所有的隐式非隐式等的概念、举例全部列举出来

std::endl 与 缓冲区的讨论， fprint()的缓冲区    日志库常用哪个函数



c++中提到了将函数返回的对象直接被新定义的对象接管其作用域内存空间，注意这个东西实际上是怎样的。





把C++语言的  运行时内存分布知识理解清楚，从以前看的牛客网的那个面试题中寻找对应的问题---对应有两个分类的描述来着，都弄明白(以及常量区是属于哪个分类，以及常量区中放着什么东西呢？)
深层次的关于数据类型的(有符号无符号)范围计算，我记得四大件还是csapp中有详细的计算方法以及原理



`std::thread`、`std::async`、`std::future`和`std::promise`是C++11引入的几个用于多线程编程的重要工具，它们使得并发编程在C++中变得更加直接和安全。 **std::async**: 这是一个用来启动异步任务的函数模板，它可以返回一个 `std::future` 对象，该对象将在未来某个时刻持有异步操作的结果。当你使用 `std::async` 时，可以指定启动选项，如 `std::launch::async` 或 `std::launch::deferred`，或者两者的组合。      详细全面弄懂

培训时做的疑问笔记(C++ 、对象模型的疑问)
================
类的构造函数被设置为protected意味着什么？
ChatGPT
将类的构造函数设置为 protected 意味着这个构造函数不能被类外的代码直接调用。这种做法主要有以下几个目的和影响：

限制对象的创建：当一个类的构造函数被声明为 protected，这意味着只有这个类本身及其子类可以调用这个构造函数。这通常用于控制对象创建的方式，确保对象只能以某种特定方式被创建（例如，通过工厂方法或通过继承）。
促使使用工厂模式：在某些情况下，可能希望通过静态方法（常见于工厂模式）来控制对象的实例化过程，而不是直接通过构造函数。将构造函数设置为 protected 可以强制外部代码通过工厂方法来创建实例，这样可以在创建对象之前进行额外的逻辑处理，例如检查条件、初始化特定资源或应用某些配置。
设计为基类（抽象类）：在设计框架或库时，有时会创建一些基础类，这些类本身并不意图直接实例化，而是作为其他类的基类。通过将构造函数设置为 protected，可以防止这些基类被直接实例化，确保它们只能被继承和扩展。
支持继承：由于子类的构造过程中可能需要访问父类的构造函数，将构造函数设置为 protected 而不是 private 确保了子类能够正常调用父类的构造函数进行初始化。
总的来说，将构造函数设置为 protected 是一种面向对象设计中的技巧，用于控制类的实例化方式，强化使用特定的设计模式，或者制定更加严格的类继承策略。

==============

c++语言完成后，几个容器实现一遍，几个智能指针也要实现一遍深入弄懂

几个常用容器

最终的总复习，所有的内容都要在编译器上验证一遍

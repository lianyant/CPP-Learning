# 循环控制语句

## 1.循环控制语句简介

​	在C和C++中，循环控制语句是用于执行重复操作的语句，直到满足特定条件为止。循环控制结构允许我们将代码块执行多次而无需重复写相同的代码。C和C++提供了几种类型的循环控制语句：

### 1. for循环

`for` 循环是一种迭代控制结构，用于重复执行一段代码固定的次数。它的一般形式如下：

```cpp
for (initialization; condition; increment) {
    // 循环体
}
```

- **initialization**：初始化表达式，通常用于设置循环计数器的初始值。
- **condition**：循环继续的条件。如果条件为真（非零），循环继续；如果条件为假（零），循环结束。
- **increment**：每次循环迭代后执行的表达式，通常用于更新循环计数器。

### 2. while循环

`while` 循环只要其条件表达式为真（非零），就会重复执行代码块。它的基本形式如下：

```cpp
while (condition) {
    // 循环体
}
```

在每次循环开始之前，都会评估条件表达式。

### 3. do-while循环

`do-while` 循环至少执行一次循环体，然后只要条件表达式为真（非零），就会继续执行。它的基本形式如下：

```cpp
do {
    // 循环体
} while (condition);
```

与 `while` 循环不同，`do-while` 循环的条件表达式在循环体的末尾进行评估。

### 循环控制语句的选择

- **for循环**：当你事先知道循环必须执行的次数时，使用 `for` 循环是最好的选择。
- **while循环**：如果你不知道循环需要执行多少次，但有一个继续循环的条件，那么 `while` 循环是合适的。
- **do-while循环**：当循环体至少需要执行一次，之后可能根据某个条件继续执行时，使用 `do-while` 循环。

每种循环都有其特定的使用场景，选择哪种循环取决于具体的编程需求和循环执行条件的性质。

## 2.goto语句

`goto` 语句是C和C++中提供的一种跳转控制语句，它允许程序无条件地跳转到同一函数内的标记位置。使用 `goto` 语句可以从程序的一个部分跳转到另一个部分，但这种跳转破坏了程序的结构化流程，使得代码难以阅读和维护。因此，`goto` 语句的使用在现代编程实践中通常是被鼓励避免的。

### 语法

```c
goto label;
...
label: statement;
```

这里，`label` 是用户定义的标记，可以放在函数内的任何位置。程序执行到 `goto label;` 语句时会直接跳转到标记为 `label` 的语句处继续执行。

### 使用场景

尽管 `goto` 语句的使用通常是不推荐的，但在某些特定场景下，它可以提供便利，例如：

- **从多层嵌套的循环或条件语句中直接跳出**：在深层嵌套的循环或条件语句中，使用 `goto` 语句可以直接跳出到外层，而不需要设置和检查多个条件变量。
- **错误处理**：在一些底层编程或系统编程中，特别是需要清理资源并从多个不同的错误点返回时，使用 `goto` 语句可以简化错误处理的代码。

### 使用场景进一步说明

​	`goto` 语句在C和C++中的主要用途确实受到限制，主要由于它与结构化编程原则相违背。尽管如此，在某些特定情况下，`goto` 语句的使用可能是合理的，主要包括：

1. **从多层嵌套结构中直接跳出**：在深层嵌套的循环或条件判断中，如果需要从内部某个点直接跳出到外层，使用 `goto` 可以比较直接地实现，而不需要引入额外的控制变量或进行复杂的条件判断。
2. **错误处理和资源清理**：在处理错误和进行资源清理时，特别是在函数中需要释放多个资源的情况下（如内存、文件句柄、锁等），使用 `goto` 可以统一跳转到清理代码段，避免代码重复和可能的遗漏。
3. **状态机实现**：在某些情况下，`goto` 可以用于实现状态机（State Machine），使状态转换逻辑更加明显。但是，这种用法相对罕见，且需要谨慎使用，以免造成代码难以维护。

​	除了上述情况，几乎所有其他用途都有更好的、结构化的解决方案，如使用循环结构、条件结构、函数调用等。

### 例子

#### 从多层循环中跳出

```c
#include <stdio.h>

int main() {
    for (int i = 0; i < 5; i++) {
        for (int j = 0; j < 5; j++) {
            printf("%d, %d\n", i, j);
            if (i == 2 && j == 2) {
                goto end;
            }
        }
    }

end:
    printf("Jumped out of the loop.");
    return 0;
}
```

这个例子中，当 `i` 和 `j` 都等于2时，使用 `goto` 语句跳出了嵌套循环。

#### 错误处理

```c
#include <stdio.h>

int main() {
    FILE *file = fopen("nonexistent.txt", "r");
    if (!file) {
        goto error;
    }

    // 文件处理代码...

    fclose(file);
    return 0;

error:
    perror("Failed to open the file");
    return 1;
}
```

这个例子中，如果文件打开失败，则使用 `goto` 语句跳转到错误处理代码。

### 注意事项

​	尽管 `goto` 语句在某些情况下可能看似方便，但它的使用应该是极其谨慎的，因为它使得代码流程变得难以追踪，降低了程序的可读性和可维护性。在大多数情况下，可以通过其他结构化的控制流语句（如循环、条件语句、函数调用）来代替 `goto` 语句。

​	goto 语句不能用于跨函数跳转。goto 只能在同一个函数内部跳转，因为它跳转到的标签必须位于同一函数内部的某个位置。尝试跨函数使用 goto 会导致编译错误，因为这样的跳转会破坏函数的调用栈，且无法保证跳转目标点的上下文环境与预期一致。跨函数跳转的需求通常可以通过函数调用、回调函数、或者设置函数指针等方式实现，这些方法都是结构化且安全的编程实践，既满足了功能需求，又保持了代码的清晰度和可维护性。

## 3.while与do...while语句

### 3.1 综述

`while` 循环和 `do-while` 循环的本质区别和用法：

#### while语句（当型循环结构）

`while` 语句是一种“当型”循环结构（Pre-test Loop），这意味着它会在每次循环迭代之前检查其条件。如果条件为真（即满足循环条件），则执行循环体内的代码；如果条件为假，则循环终止，继续执行循环之后的代码。这种结构的关键是，循环体的代码在条件第一次不满足时甚至可能一次都不执行。

#### do-while语句（直到型循环结构）

与 `while` 语句相反，`do-while` 语句是一种“直到型”循环结构（Post-test Loop），它保证循环体内的代码至少执行一次。在 `do-while` 循环中，循环体的代码首先被执行，然后才检查循环条件。如果条件为真，则循环继续；如果条件为假，则循环终止。因为条件的检查是在循环体的代码执行后进行的，所以无论条件初次是否满足，循环体内的代码总是至少被执行一次。

#### 示例

while 语句示例

```c
int count = 5;
while (count > 0) {
    printf("%d\n", count);
    count--;
}
```

这个例子中，只有当 `count` 大于0时，循环体内的代码才会执行。

do-while 语句示例

```c
int count = 5;
do {
    printf("%d\n", count);
    count--;
} while (count > 0);
```

在这个例子中，即使 `count` 的初始值不满足循环条件，循环体内的代码也会至少执行一次。但如果从初始值为5开始，这段代码的行为与 `while` 循环示例相同，不同之处在于，如果 `count` 初始值小于或等于0，`do-while` 循环仍会执行一次打印操作，而 `while` 循环则不会执行循环体内的代码。

通过这种方式，`while` 和 `do-while` 循环各自适用于不同的场景，选择哪一种循环结构取决于代码块是否需要至少执行一次。



### 3.2 while语句

`while` 语句是一种基本的循环控制结构，用于在给定条件为真（即条件表达式的值为非零）时重复执行一段代码块。它是最简单的循环形式之一，在C和C++中广泛使用。

#### 语法

`while` 语句的基本语法如下：

```c
while (condition) {
    // 循环体
}
```

这里，`condition` 是每次循环迭代之前评估的表达式。如果条件为真（非零），则执行循环体内的语句；然后再次检查条件，如果仍为真，继续执行循环体，如此循环往复，直到条件为假（零），循环结束。

#### 使用场景

`while` 循环适用于以下几种典型场景：

- **当你不知道循环需要执行多少次时**：例如，读取文件直到文件结束，或者等待用户输入特定的命令。
- **需要持续检查某个条件的场合**：比如等待某个事件发生或者某个操作完成。
- **简单的循环计数**：尽管 `for` 循环更常用于这种场景，但是当循环逻辑相对简单时，`while` 循环同样适用。

#### 示例

#### 读取输入直到用户输入特定字符

```c
#include <stdio.h>

int main() {
    char ch;
    printf("Enter characters, 'q' to quit.\n");
    while ((ch = getchar()) != 'q') {
        putchar(ch); // 显示输入的字符
    }
    printf("\nFinished.\n");
    return 0;
}
```

这个例子中，程序会持续读取用户的输入直到用户输入字符 'q'。这演示了在不知道循环次数，但知道终止条件的情况下如何使用 `while` 循环。

#### 等待事件发生

假设有一个函数 `checkEvent()`，用于检查某个事件是否已经发生（返回1表示发生，0表示未发生），以下是使用 `while` 循环等待该事件发生的示例：

```c
while (!checkEvent()) {
    // 可能还需要执行一些操作，如更新界面，打印日志等
}
// 事件发生后的处理
```

这个例子演示了如何使用 `while` 循环等待某个条件成立。

#### 注意事项

在使用 `while` 循环时，需要确保循环条件最终能够变为假，否则可能导致无限循环，使得程序不能继续向下执行。因此，循环体内通常需要有某种操作或者外部事件影响，能够改变循环条件的值。



### 3.3 do...while语句

​	`do...while` 语句是一种后测试循环结构，在C和C++中用于在至少执行一次循环体后，基于给定的条件决定是否继续执行循环。这意味着无论循环条件初次是否满足，循环体内的代码至少被执行一次，之后再根据条件判断是否需要继续执行循环。

#### 语法

`do...while` 语句的基本语法如下：

```c
do {
    // 循环体
} while (condition);
```

- 循环体首先被执行一次，然后条件表达式被评估。
- 如果条件为真（非零），则循环继续，循环体再次执行。
- 如果条件为假（零），则循环结束，程序继续执行循环之后的代码。

#### 使用场景

`do...while` 循环特别适用于以下场景：

- **至少执行一次循环体**：当需要确保循环体内的代码无论条件初次是否满足都至少执行一次时，如用户输入验证、菜单系统等。
- **用户输入和验证**：在需要从用户获取输入，并且至少需要处理一次输入，之后根据某些条件（如输入验证失败）要求用户重新输入时。

#### 示例

用户输入验证

下面的例子使用 `do...while` 循环来实现一个简单的用户输入验证场景，要求用户输入一个大于0的数字，如果用户输入不满足条件，则要求用户重新输入。

```c
#include <stdio.h>

int main() {
    int number;
    do {
        printf("Enter a number greater than 0: ");
        scanf("%d", &number);
    } while (number <= 0);

    printf("You entered: %d\n", number);
    return 0;
}
```

这个例子确保无论用户的首次输入如何，都会至少询问一次。如果用户首次输入满足条件（大于0），则循环结束；如果不满足条件，则重复提示用户输入，直到输入一个满足条件的数字。

### 注意事项

在使用 `do...while` 循环时，应当确保更新循环条件相关的变量，以避免造成无限循环。由于循环条件是在循环体执行后检查的，因此这种循环结构非常适合处理至少需要执行一次操作，然后根据结果决定是否继续执行的情况。



## 4.for语句

​	`for` 语句是C和C++中用于循环执行一段代码块的一种控制结构，特别适用于当你知道循环必须执行的确切次数时。它将循环的初始化、条件测试和迭代步骤组合在一行内，使得循环结构更加紧凑和易于管理。

### 语法

`for` 语句的基本语法如下：

```c
for (initialization; condition; increment) {
    // 循环体
}
```

- **initialization**：通常用于设置循环计数器的起始值，只在循环开始前执行一次。
- **condition**：在每次循环迭代之前评估。如果条件为真（非零），则执行循环体；如果条件为假（零），则终止循环。
- **increment**：在每次循环迭代后执行，通常用于更新循环计数器。

### 使用场景

`for` 循环特别适合以下几种场景：

- **确定次数的循环**：当你事先知道需要执行循环的确切次数时。
- **遍历数组或容器**：用于按顺序访问数组或容器中的每个元素。
- **计数器控制的循环**：当循环执行依赖于计数器变量时。

### 示例

#### 确定次数的循环

打印数字1到10：

```c
#include <stdio.h>

int main() {
    for (int i = 1; i <= 10; i++) {
        printf("%d\n", i);
    }
    return 0;
}
```

#### 遍历数组

遍历数组并打印每个元素的值：

```c
#include <stdio.h>

int main() {
    int numbers[] = {2, 4, 6, 8, 10};
    int length = sizeof(numbers) / sizeof(numbers[0]);

    for (int i = 0; i < length; i++) {
        printf("%d\n", numbers[i]);
    }
    return 0;
}
```

#### 嵌套 for 循环

使用嵌套 `for` 循环打印一个5x5的星号矩阵：

```c
#include <stdio.h>

int main() {
    for (int i = 0; i < 5; i++) {
        for (int j = 0; j < 5; j++) {
            printf("* ");
        }
        printf("\n");
    }
    return 0;
}
```

### 注意事项

尽管 `for` 循环提供了一个紧凑的循环结构，但在处理复杂的循环条件或迭代步骤时，代码可能变得难以理解。在这种情况下，可能需要考虑使用 `while` 或 `do...while` 循环以提高代码的可读性。此外，在使用 `for` 循环遍历数据结构时，特别是在并行编程环境中，要注意循环依赖和迭代器失效等问题。

### 额外说明

在C和C++中的`for`语句中，`initialization`、`condition`、和`increment`部分都可以省略，但保留分号（`;`）是必须的。省略某些部分会影响循环的执行方式：

- **initialization**：通常用于初始化循环计数器。可以是任何有效的表达式，包括变量声明。如果省略，循环开始前不进行额外的初始化操作，但前面的代码对变量的初始化或之前的`for`循环中变量的残留值将被使用。
- **condition**：是循环继续执行的条件。可以是任何返回布尔值的表达式。如果省略，条件默认为真（即循环会无限执行），除非循环体内有`break`语句或其他退出循环的逻辑。
- **increment**：每次循环迭代结束时执行的表达式，通常用于更新计数器。可以是任何有效的表达式，包括增加或减少计数器的值。如果省略，循环结束时不执行任何操作，因此更新循环变量的责任转移到循环体内。

#### 讨论

对于for循环的另一个定义为：

```c
for(表达式1;表达式2;表达式3) 内嵌的语句;
```

​	针对这个for循环的定义，我是否可以理解，于表达式1中定义出来的变量，只能在for循环中使用，不能在for循环之后来使用。

​	具体能否在 `for` 循环外部使用在循环中定义的变量，还取决于变量的定义方式和编程语言的版本。在C++中，如果在 `for` 循环的初始化部分（表达式1）定义了一个变量，那么这个变量的作用域确实仅限于 `for` 循环内部。一旦循环结束，该变量就会超出其作用域，因此在循环之外使用它会导致编译错误。

**示例说明**

在C++中的使用示例：

```cpp
for (int i = 0; i < 10; i++) {
    // 循环内可以使用变量i
    cout << "Value of i is: " << i << endl;
}
// 循环结束后尝试使用i将导致错误
// cout << "Value of i outside loop is: " << i << endl;  // 这行会导致编译错误
```

​	在这个例子中，变量 `i` 在 `for` 循环的初始化部分定义，其作用域仅限于 `for` 循环本身。尝试在循环外部访问 `i` 将导致编译错误，因为 `i` 在那里不再是一个有效的标识符。

**C语言的情况**

在C语言（特别是C99标准之前的版本）中，情况稍有不同。在C99及更高版本中，允许在 `for` 循环的初始化部分声明变量，行为与C++相似。但在C89标准中，必须在 `for` 循环之外先声明变量：

```c
int i;  // 在C89中，需要在循环外声明i
for (i = 0; i < 10; i++) {
    // 循环内使用变量i
    printf("Value of i is: %d\n", i);
}
// 在C89中，可以在循环外继续使用i
printf("Value of i outside loop is: %d\n", i);
```

**结论**

​	在C++和现代C（C99及以后）中，通常推荐在 `for` 循环内部声明循环变量，这样做可以限制变量的作用域，提高代码的安全性和清晰度。这种作用域限制有助于避免变量在循环外意外被访问的问题，从而减少潜在的编程错误。

#### `for`循环的执行流程

```c
for (initialization; condition; increment) {
    // 循环体
}
```

1. **initialization**：首先执行初始化部分，且只在循环开始前执行一次。
2. **condition**：接着评估条件表达式。如果条件为真（非零），则执行循环体；如果条件为假（零），则跳过循环体，`for`循环结束。
3. **Loop Body**：如果条件为真，执行循环体内的语句。
4. **increment**：循环体内的语句执行完毕后，执行增量表达式。
5. 返回步骤2，再次评估条件表达式。

#### 例子及详解

考虑打印从1到5的数字：

```c
#include <stdio.h>

int main() {
    for (int i = 1; i <= 5; i++) {
        printf("%d\n", i);
        // 循环体结束
    }
    return 0;
}
```

执行流程如下：

1. **初始化（initialization）**：`int i = 1`，声明变量`i`并初始化为1。
2. **条件判断（condition）**：检查`i <= 5`。对于首次迭代，`1 <= 5`是真的，所以继续执行。
3. **执行循环体**：执行`printf("%d\n", i);`，打印当前的`i`值。
4. **执行增量（increment）**：执行`i++`，`i`的值增加1。
5. 回到步骤2，此时`i`为2。重复步骤2-4，直到`i`值为6。在`i`为6时，条件`i <= 5`为假，循环结束。

​	通过这个例子，可以看出`for`循环如何通过初始化、条件判断、执行循环体和执行增量表达式的步骤来控制循环的执行。在循环体内部，你可以执行任何操作，包括进一步的条件判断、使用`continue`来提前跳至下一个迭代、或使用`break`来完全终止循环。

### for循环中的++效率问题

在C和C++中，当讨论到循环控制变量的增加（如 `++i` vs `i++`）时，效率问题经常被提起。理论上，这两种形式在 `for` 循环的上下文中可能有微小的效率差异，尤其是在某些特定的编译器和旧的编译器优化级别上。但在现代编译器中，这两者之间的效率差异几乎可以忽略不计。

**后置与前置增量的差异**

- **后置增量（`i++`）**：意味着增量操作发生在使用当前值之后。在非循环语境中，后置增量通常需要将原始值存储在临时位置，以便在增加原始变量之后返回原始值。这个过程可能涉及额外的存储和复制操作。
- **前置增量（`++i`）**：意味着增量操作发生在变量使用之前。前置增量直接增加变量的值，并返回增加后的值，通常不需要额外的存储或复制。

**循环中的使用**

在 `for` 循环的增量阶段，你通常不需要关心 `++i` 和 `i++` 的差异，因为循环控制变量的增加值并不直接用于任何赋值或返回操作。例如：

```c
for (int i = 0; i < n; i++) {
    // 循环体
}
```

与

```c
for (int i = 0; i < n; ++i) {
    // 循环体
}
```

在这两种情况下，`i` 的值在每次循环结束时都被简单地增加，不涉及任何需要区分前置和后置语义的操作。因此，任何现代编译器都会生成几乎相同的代码。

**实际效果**

​	对于简单的整型和内置类型，现代编译器足够智能，能够在编译期间优化这类看似微小的差异。只有在操作重载的 `++` 操作符涉及到复杂类型时（如迭代器或自定义类型），选择前置增量 (`++i`) 通常更推荐，因为它避免了潜在的临时对象的创建和复制（采用前置++的主要原因）。

**结论**

对于基本类型的 `for` 循环控制变量，在 `++i` 和 `i++` 之间的选择基本上不会影响性能。但是，按照一般的最佳实践，推荐使用前置增量（`++i`），尤其是在涉及复杂类型或迭代器时，这样做可以确保即使在非优化编译环境中也能保持最佳性能。这一习惯可以统一代码风格并避免在复杂场景下的潜在效率问题。

# 初始化、赋值讨论

## 1.初始化讨论(需要验证/没什么意义,全部在定义是初始化就行了啊)

### 1.数组初始化：

#### C语言下数组初始化：

1. 局部非静态数组

- **字符数组**：如果部分初始化，未明确初始化的部分将自动填充为 `'\0'`。这种行为确保了即使数组不是完全初始化，也可以作为有效的C风格字符串使用。这是因为字符数组通常用于存储字符串，而字符串在C中需要以 '\0' 结尾。(在C和C++中，`'\0'` 是空字符的常用表示，它实际上是一个数值为0的字符。在字符数组中，`'\0'` 用作字符串的终结符，标志着字符串的结束。)

- **非字符数组(除去结构体数组)**：未明确初始化的部分保持未定义，它们的初始值取决于内存中的现有内容。

- **结构体数组**：如果只初始化了数组中一部分结构体的字段，那么只有显式初始化的字段将被设置为指定的值。其他所有未被显式初始化的字段将保持未定义状态。如果结构体数组中的某个成员或嵌套结构体的成员未被显式初始化，它们的值将是未定义的。==》**有问题：这里明明在讨论结构体数组中没有被初始化的元素(这个整体)，但是这里却在讨论元素中的字段了，走远了。不对！！！！下面几个地方也是如此，以后有空来讨论，现在不浪费时间了**  

  

  示例：

```c
// 不含有嵌套的结构体成员
typedef struct {
    int id;
    double balance;
} Account;

void function() {
    Account accounts[2] = {{1, 1000.0}};
    // accounts[0] 被初始化为 {1, 1000.0}
    // accounts[1] 的 id 和 balance 均为未定义
}
```

2. 全局数组、全局静态数组、局部静态数组

- **任意类型（包括字符和非字符数组,除去结构体数组）**：未明确初始化的部分将自动填充为相应类型的零值。对于字符数组，这意味着未初始化的部分将被设置为 `'\0'`；对于整型或浮点数组，这意味着未初始化的部分将被设置为 `0` 或 `0.0`。
- **结构体数组**：全局变量和静态变量一致，全局和静态结构体数组中的每个字段/成员，包括嵌套的结构体成员，无论是否显式初始化，都会自动初始化为相应类型的零值。这意味着整数类型成员初始化为 0，浮点类型成员初始化为 0.0，指针类型成员初始化为 NULL，嵌套的结构体成员也会逐个字段自动初始化为零值。看两个示例：

```c
// 例子1,不含有嵌套的结构体成员
Account global_accounts[2];  // 全局数组
// 所有 global_accounts 中的 id 和 balance 都初始化为 0

void function() {
    static Account static_accounts[2];
    // 所有 static_accounts 中的 id 和 balance 也都初始化为 0
}

// 例子2,含有嵌套的结构体成员
typedef struct {
    int partNumber;
    double cost;
} Part;

typedef struct {
    Part part;
    int quantity;
    double totalPrice;
} InventoryItem;

// 全局静态数组
static InventoryItem inventory[5];/*
在这个例子中，inventory 数组中的每个 InventoryItem 实例以及其内部的 Part 实例的所有成员都将自动初始化为零。这包括：
part.partNumber 初始化为 0。
part.cost 初始化为 0.0。
quantity 初始化为 0。
totalPrice 初始化为 0.0。
*/
```

为什么这样区分？

- **局部非静态数组(除去结构体数组)**：在C语言的执行模型中，局部非静态变量（包括数组）存储在栈上，这是一种“自动存储类别”，它们在函数调用时被创建，在函数返回时被销毁。由于性能考虑和历史原因（C语言的设计旨在尽可能低的运行时开销），这些变量不会自动初始化，以避免不必要的运行时开销。
- **全局数组和静态数组(除去结构体数组)**：存储在程序的数据段，它们在程序启动时一次性初始化，通常由操作系统在加载程序时清零，这样做可以简化程序的初始状态管理，并增加程序的可预测性。
- **局部非静态结构体数组**：这些数组在栈上分配内存，并且不自动初始化以避免不必要的性能开销。这是因为栈操作需要快速执行，而自动初始化可能会显著增加函数调用的开销。
- **全局和静态结构体数组**：这些数组在程序的数据段或特定的静态内存区域分配内存，由操作系统或运行时环境在程序加载时一次性清零，这确保了数据的确定性和安全性。

​	无论结构体中的成员是否包含其他结构体，或者是基本数据类型、指针等，全局和静态结构体数组的初始化行为都遵循相同的规则。

总结

正确理解和应用数组的初始化规则是编写可靠、可维护C程序的关键。为了避免潜在的bug：

- 明确初始化所有局部非静态数组，确保代码的行为明确且可预测。
- 利用全局和静态数组的自动初始化行为，但要清楚这是由于它们的存储类别导致的。

这种详细分类确实更加准确，并帮助程序员更好地理解不同存储类别和类型的数组在C语言中是如何被处理的。

#### C++语言下数组初始化的不同之处

​	在C++中，数组的初始化规则与C语言非常相似，但C++提供了更多初始化选项和更强的类型安全。尽管基本原理相同，C++在一些方面有更明确的行为，特别是关于默认构造函数和类类型数组的初始化。

1.局部非静态数组

- 基本类型数组（如 int, char等）：

  - 如果部分初始化，未初始化的部分行为在标准C++中也是未定义的，与C语言一致。

- 类类型数组：

  - **对于未初始化部分,每个元素都将调用默认构造函数进行初始化**：
    - 如果类类型有显式定义的默认构造函数，或者编译器能够为其生成默认构造函数（即所有成员包括基本类型、类类型、和结构体类型成员都可以默认构造，且没有引用或常量成员需要在构造函数中显式初始化），则每个数组元素都会调用这一构造函数。
    - 对于包含其他类类型或结构体类型的成员，这些成员将通过它们各自的默认构造函数进行初始化，如果这些成员类/结构体自身定义了默认构造函数或编译器能为它们生成默认构造函数。
  - **对于未初始化部分,编译器无法生成默认构造函数时的处理**：
    - 如果类类型的构造函数无法由编译器生成（如因为存在需要显式初始化的引用或常量成员，或者成员类/结构体中包含需要显式初始化的成员），则必须显式定义一个默认构造函数。否则，编译将失败，因为数组的初始化需要构造每个元素。
    - 特别是，如果类中的结构体成员或其他嵌套的类成员没有可用的默认构造函数，并且需要显式初始化（例如，成员类型本身需要显式初始化如引用、常量或没有默认构造函数的复杂类型），这将要求在类的构造函数中显式处理这些初始化。
  - 示例：

  ```cpp
  class Inner {
      int x;
  public:
      Inner(int initX) : x(initX) {}  // 需要显式初始化的构造函数
  };
  
  class Outer {
      Inner inner;
      int y;
  public:
      // 显式定义构造函数以初始化内部复杂类型成员
      Outer() : inner(10), y(0) {}
  };
  
  Outer outers[5];  // 类类型数组，每个元素通过 Outer 的显式构造函数初始化
  
  /*在这个示例中，Outer 类包含一个 Inner 类的实例作为成员。由于 Inner 类没有无参数的默认构造函数，因此 Outer 类必须在其构造函数中显式初始化 inner 成员。*/
  ```

- 局部非静态结构体数组

  - 对于未初始化部分，针对基本类型成员：

    - 如果部分初始化，未初始化的部分行为在标凈C++中也是未定义的，这与局部非静态基本类型数组相同。

  - 对于未初始化部分，针对类类型成员：

    - **通过默认构造函数初始化**：如果结构体中的类类型成员已定义其对应的默认构造函数，或者成员是内置类型，它们将通过其默认构造函数进行初始化。
    - **编译器无法生成默认构造函数时的处理**：如果成员类没有显式的默认构造函数，且编译器也无法生成一个（如成员类中包含需要显式初始化的引用或常量成员），则该类类型成员必须显式提供一个构造函数。否则，编译将失败。

  - 对于未初始化部分，针对结构体类型成员：

    - 在C++中，如果一个结构体包含另一个结构体作为成员（称为嵌套结构体），则这些嵌套结构体成员的初始化行为依赖于是否有显式初始化提供。对于局部非静态结构体数组如果包含嵌套结构体作为成员且没有提供显式初始化，则嵌套结构体成员的初始化行为遵循C++的默认构造规则。这里的处理取决于嵌套结构体成员是否具有可访问的默认构造函数。以下是详细讨论：

      - #### **嵌套结构体有默认构造函数**

        - 如果嵌套结构体定义了一个默认构造函数（无论是显式定义的还是编译器隐式生成的），则该构造函数将被调用以初始化每个数组元素中的嵌套结构体成员。这确保了所有嵌套结构体成员都被适当初始化。

      - #### **嵌套结构体没有默认构造函数**

        - 如果嵌套结构体没有可访问的默认构造函数，并且其所有成员也不能进行无参数初始化（例如，成员类型本身需要显式初始化），则编译器将报错，因为它无法自动创建这些成员的实例。这种情况通常要求程序员提供一个显式的构造函数或在结构体内部提供足够的成员初始化器。

        


    - 示例：
    
    ```cpp
    struct Inner {
        int x;
        Inner() : x(0) {}  // 显式默认构造函数
    };
    
    struct Outer {
        Inner inner;
        int y;
        // 未提供显式默认构造函数
    };
    
    // 然后你定义一个局部非静态结构体数组：
    void function() {
        Outer outerArray[2];  // 将会调用Inner的默认构造函数初始化inner
        // outerArray中每个元素的inner.x将被初始化为0
        // outerArray中每个元素的y将是未定义的，因为Outer没有提供默认构造函数来初始化y
    }
    
    /*
    在这个例子中，每个 Outer 结构体的 Inner inner 成员通过 Inner 的默认构造函数初始化。然而，Outer 结构体的 int y 成员将保持未定义，因为 Outer 没有为其提供默认构造行为。
    */
    ```
    
    - 总结：在C++中，局部非静态数组的嵌套结构体成员会尝试通过其默认构造函数进行初始化，如果没有提供显式初始化。这显示了C++对对象构造的严格性，以确保所有对象在使用前都正确初始化，减少未定义行为的风险。在实际开发中，建议总是显式定义所需的构造函数，或确保所有成员都可以安全地默认初始化，以避免潜在的初始化错误。


​    

2.全局数组和静态数组

​	在C++中，全局和静态数组的初始化确保了所有元素都被适当地初始化以避免未定义行为，无论它们的类型如何。

- 任意类型数组(除去结构体类型数组)：
  - 与C语言相同，全局和静态数组的元素自动初始化为零。对于基本类型，这意味着数字类型初始化为 `0`，指针类型初始化为 `nullptr`(注意指针的初始化在老版本C++中是 `NULL` 而不是 `nullptr`)。对于类类型数组，对于未显示初始化的类对象元素将调用对应的默认构造函数(无论是自定义的还是由编译器自动生成(由编译器自动生成需要建立在没有其他构造函数阻止生成默认构造函数的情况下才成立,上同)的)。
- 结构体类型数组
  - 左边的描述不尽人意

3.字符数组特殊性

- **C++中的字符数组**初始化与C语言相同。如果部分初始化，未指定的部分将自动填充为 `'\0'`。

类类型数组的特殊情况

​	C++中类类型数组的初始化尤其值得关注。如果数组类型是一个类，并且该类有一个默认构造函数（无论是显式定义还是编译器生成的），则数组的每个元素都会被这个默认构造函数初始化。这保证了所有对象都处于有效状态，避免了C语言中未初始化内存可能导致的未定义行为。

​	在C++中，数组的初始化确实依赖于元素类型的构造需求，但全局和静态数组与局部数组在初始化时的行为有所不同：

1. **全局和静态数组**：全局和静态数组的元素会自动初始化。如果数组的元素是基本数据类型，它们会被初始化为零。如果元素是类类型，且该类具有默认构造函数，那么会自动调用默认构造函数来初始化每个元素。如果类没有默认构造函数且编译器无法自动生成一个，这将导致编译错误。
2. **局部非静态数组**：局部非静态数组的元素不会自动初始化（除非显式地进行初始化）。如果数组的元素是基本数据类型，那么它们的初始值是未定义的。如果元素是类类型，并且需要默认构造函数来初始化，但类没有可用的默认构造函数，那么同样会导致编译错误。

​	因此，C++中数组初始化的关键区别不仅在于元素类型的构造需求，还在于数组是否为全局/静态或局部/非静态。全局和静态数组保证了初始化，而局部非静态数组的基本类型元素则不会自动初始化，这可能导致未定义行为。这是C++中关于初始化行为的一个重要细节。

#### 编译器的处理

​	在某些开发环境和编译器设置中（尤其是在调试模式下），可能会看到即使是非静态局部变量也被初始化为零的行为。这通常是为了帮助开发者识别使用未初始化变量的问题，但不应依赖于此行为进行程序设计，因为它不是C/C++标准所规定的。

#### 特殊情况

​	如果一个类有其他构造函数且没有显式定义一个无参的默认构造函数，而编译器由于这些存在的构造函数不能自动生成一个默认构造函数，那么在尝试自动初始化类类型的数组时，会遇到问题(在C++对象模型中来详细讨论哪些情况下编译器会自动生成默认构造函数；哪些情况下不会)。

​	在C++中，如果试图创建这样一个类的数组，而该类缺乏一个无参的默认构造函数，编译器将报错，因为它无法自动初始化数组中的每个元素。这种情况下，编译器需要调用默认构造函数来初始化数组中的每个对象，如果没有可调用的默认构造函数，编译就会失败。

​	例如，考虑以下类：

```cpp
class Example {
public:
    Example(int x) { /* 构造函数实现 */ }
};

```

​	这个类有一个接受 `int` 参数的构造函数，但没有默认构造函数。如果你尝试创建这个类的数组，如：`Example arr[10];`这将导致编译错误，因为编译器需要但找不到一个无参的默认构造函数来初始化这个 `arr` 数组中的 `Example` 对象。

解决这种问题的方法通常包括：

- 明确定义一个默认构造函数。
- 使用数组的初始化列表明确每个元素的构造方式（如果适用）。
- 如果类的设计不允许无参构造，可能需要重新考虑是否使用动态分配或其他数据结构（如 `std::vector`），这些结构可以在运行时指定构造参数。



2.结构体变量初始化(C和C++下需要分开讨论)

针对C++下，如果结构体的自定义的构造函数只初始化了部分的成员且成员可能是其他类类型/结构体类型时？

3.类对象初始化问题

还是上面说到过的，如果自定义的构造函数只初始化了部分的成员且成员可能是其他类类型/结构体类型时？



以及还有一个现象：就是针对结构体或者类类型如果 自定义的无参构造函数中只初始化了部分成员，这种初始化又该怎么看待呢？编译器自动生成的默认构造函数，会初始化掉类中的所有普通数据成员嘛？当然这个问题需要建立在确定哪些情况下才会编译器自动生成默认构造以及默认构造中初始化了哪些成员(哪些成员会被初始化哪些不会)



10.赋值问题

两个类对象之间的赋值、两个结构体变量之间的赋值。成员会如何？



如两个string对象赋值、vector对象之间的赋值？
结构体、类对象之间的赋值且成员中有指针的情况会如何？
# 结构体数组与结构体指针

​	C语言中，声明结构体类型本身不会为其分配内存空间，仅仅是定义了一个模板。这个模板说明了该类型的结构体将包含哪些成员及其类型。只有当您根据这个类型声明了变量时，内存才会被分配。

所以，这段代码：

```c
struct student {
    int num;
    char name[100];
    // ... 其他成员 ...
};
```

定义了一个名为 `student` 的结构体类型，但没有创建任何 `student` 类型的变量。

而这段代码：

```c
struct student {
    int num;
    char name[100];
    // ... 其他成员 ...
} stu1, stu2;
```

​	不仅定义了 `student` 结构体类型，还定义了两个 `student` 类型的变量 `stu1` 和 `stu2`。在这种情况下，`stu1` 和 `stu2` 将占用内存空间，每个变量包含一个 `int` 类型的 `num` 成员和一个长度为100的字符数组 `name` 成员，以及声明中可能包含的任何其他成员。



## 1.结构体数组

​	结构体数组是一个数组，其每个元素都是同一类型的结构体。它允许存储和操作具有相同属性集但各自持有不同数据的多个实体。

### 结构体数组的声明

​	声明结构体数组与声明标准数组类似，但数组的每个元素都是一个结构体类型。例如：

```c
struct student {
    int num;
    char name[100];
    // ... 其他成员 ...
} st_array[3];

// 或者下面这种方式
struct student {
    int num;
    char name[100];
    // ... 其他成员 ...
};// 这种方式只是定义出来了
struct student st_array[3];
```

这里 `st_array` 是一个包含3个 `student` 结构体的数组。

### 结构体数组的初始化

​	（1）结构体数组可以在声明时进行(顺便)初始化。可以为数组中的每个结构体元素提供一个初始化列表：

```c
struct student st_array[3] = {
    {1001, "学生一", /* 其他成员的初始值 */ },
    {1002, "学生二", /* 其他成员的初始值 */ },
    {1003, "学生三", /* 其他成员的初始值 */ }
};
```

​	每个花括号内的列表对应结构体类型的一个实例的初始化。

​	（2）定义的时候初始化还可以不指定数组元素个数，此时系统根据初始化 的这些值自动推断出数组的元素是多少个：

```c
struct student st_array[] = {
    {1001, "学生一", /* 其他成员的初始值 */ },
    {1002, "学生二", /* 其他成员的初始值 */ },
    {1003, "学生三", /* 其他成员的初始值 */ }
};
```

​	那么定义时的初始化的一般形式为：`struct student st_array[] = {{...}, {...}, {...}, ...};`

### 结构体数组的引用

​	引用结构体数组中的元素时，可以使用数组索引来定位特定的结构体，然后使用点操作符来访问该元素的成员(像使用普通结构体变量一样使用结构体数组)。例如：

```c
st_array[0].num = 1001; // 访问数组第一个元素的num成员
strcpy(st_array[0].name, "学生一"); // 访问数组第一个元素的name成员
```

通过上述操作，我们为 `st_array` 数组的第一个 `student` 元素赋了新的值。

### 示例

图片中提供的示例展示了如何声明结构体数组并进行初始化，同时展示了如何单独访问结构体数组中元素的成员变量并赋值：

```c
struct student st_array[3] = {
    {1001, "王五", 1, 18, "第1街道", 12, 30, 2000},
    {1002, "李四", 0, 20, "第2街道", 11, 15, 1998},
    {1003, "赵六", 1, 22, "第3街道", 10, 15, 1996}
};

// 单独访问结构体数组的成员并赋值
st_array[1].age = 19; // 更改数组中第二个元素的age成员
printf("Name = %s\n", st_array[1].name); // 打印数组中第二个元素的name成员
printf("Age = %d\n", st_array[1].age); // 打印数组中第二个元素的age成员
```

​	在这个例子中，我们首先声明并初始化了一个包含三个 `student` 结构体的数组 `st_array`。随后，代码演示了如何更改数组中第二个元素的 `age` 成员，并打印了这个元素的 `name` 和 `age` 成员。

### 结论

​	结构体数组是处理相同类型的多个数据项的有效方式，它结合了结构体的组织能力和数组的顺序存储能力，适用于各种数据集合的管理和操作。通过示例代码，可以清楚地看到结构体数组的声明、初始化和成员访问的具体方法。



## 2.结构体指针

​	所谓结构体指针，就是结构体变量的指针，用于指向该结构体变量所占据的内存的起始地址。当然，结构体变量的指针也可以指向结构体数组中的元素，因为结构体数组中的每个元素就相当于一个结构体变量。



### 结构体指针的声明和使用

声明一个指向结构体的指针，然后通过这个指针来访问结构体的成员。

假设有以下结构体定义和变量：

```c
struct student {
    int num; // 学号
    char name[100]; // 姓名
    // ... 其他成员 ...
};

struct student stu; // 定义结构体变量stu
struct student *p; // 定义指向结构体的指针p
```

可以通过如下方式使用指针 `p` 来访问 `stu` 的成员：

```c
p = &stu; // 指针p指向结构体变量stu的地址

// 通过结构体指针访问num成员并赋值（何通过结构体变量指针来访问结构体变量的成员：用指向结构体成员运算符“->”）
p->num = 1008;// 箭头运算符（->）（也叫指向结构体成员运算符(->)），这是专门为通过结构体指针访问成员而设计的。当写 p->num 时，它意味着“获取指针 p 指向的结构体的 num 成员”。
////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

// 通过结构体指针访问num成员并赋值（何通过结构体变量指针来访问结构体变量的成员：用结构体成员运算符“.”）
(*p).num = 1008;
// 解引用运算符（*）和点运算符（.）(也叫结构体成员运算符(.)) 	首先使用解引用运算符 * 来获取指针 p 指向的结构体变量，然后使用点运算符 . 来访问其 num 成员。

/*
解引用运算符和点运算符必须一起使用，因为单独的 *p.num 是无效的，它会被解释为尝试访问名为 num 的指针 p 指向的值的地址。原因是：点运算符（.）的优先级高于解引用运算符（*），这就是为什么在使用 (*p).num 的时候需要在 p 周围加上括号。如果没有括号，就会先尝试访问 p.num，这不符合语法，因为 p 是一个指针而不是结构体变量。*/


////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////
strcpy(p->name, "John Doe"); // 通过结构体指针访问name成员并赋值
// 或strcpy((*p).name, "John Doe"); // 通过结构体指针访问name成员并赋值
```

### 结构体数组和结构体指针数组

内容还讲解了结构体数组和指针数组的概念，以及它们是如何被声明和初始化的。

如果有一个结构体数组，可以这样声明和初始化：

```c
struct student stuArr[3] = {
    {1001, "学生一", /* 其他成员的初始值 */},
    {1002, "学生二", /* 其他成员的初始值 */},
    {1003, "学生三", /* 其他成员的初始值 */}
};
```

可以用指针来遍历数组：

```c
for (int i = 0; i < 3; i++) {
    printf("Name: %s\n", stuArr[i].name);
}
```

或者使用结构体指针：

```c
struct student *pStu;
pStu = stuArr;

for (int i = 0; i < 3; i++) {
    printf("Name: %s\n", pStu->name);
    pStu++;//++意味着一次跳过一个数组元素所占用的字节数,指向了结构体数组中的下一个元素了
}
```

或者使用结构体指针数组：

```c
struct student *pStuArr[3];
pStuArr[0] = &stuArr[0];
pStuArr[1] = &stuArr[1];
pStuArr[2] = &stuArr[2];

for (int i = 0; i < 3; i++) {
    printf("Name: %s\n", pStuArr[i]->name);
}
```



### 访问结构体数组的成员

当有一个结构体数组时，可以直接通过数组索引来访问每个元素的成员，也可以通过结构体指针数组来访问。

使用指针访问结构体数组中的第一个元素的成员：

```c
p = stuArr; // 指针p指向结构体数组stuArr的第一个元素
printf("%d\n", p->num); // 访问第一个元素的num成员
```

​	结构体变量和结构体指针在使用时具有不同的内存大小，结构体变量的大小等于所有成员大小之和，而指针的大小则是指针本身的大小。

### 特殊场景

```c
struct student *pStu1 = stuArr;
printf("%d\n",(++pStu1)->num);//此时打印的结果是1002,++在pStu1之前表示先加后用,且本语句执行完毕后pStu1仍然指向的是1002
```

```c
struct student *pStu1 = stuArr;
printf("%d\n",(pStu1++)->num);//此时打印的结果是1001,++在pStu1之后表示先用后加,且本语句执行完毕后pStu1指向的是1002
```

​	指针ps定义为指向struct student类型变量的指针,它只能指向一个结构体类型的变量或者指向一个结构体类型数组中的某个元素，不能指向其中的具体某个成员。如下：

```c
struct student {
    int num; // 学号
    char name[100]; // 姓名
    // ... 其他成员 ...
}stu1;
struct student *ps = &stu1;// 正确,指向的是结构体变量
// 或者struct student *ps = stuArr;// 正确,指向的是结构体数组中的第一个元素
// 或者struct student *ps = &stuArr[0];// 正确,指向的是结构体数组中的第一个元素

ps = &stu1.num;// 错误,不能指向结构体类型变量的某个成员(因为 &stu1.num 取的是 stu1 中 num 成员的地址，它的类型是 int *，不是 struct student *。)
// 或者ps = &stuArr[0].num;// 错误,不能指向结构体数组中的第一个元素的某个成员
// 或者ps = stuArr.num;// 错误,不能指向结构体数组中的第一个元素的某个成员


// 正确做法：
int *pnum = &stu1.num;
// 或者 int *pnum = &stuArr[0].num;
// 或者 int *pnum = stuArr.num;
```



### 指针操作的规则

- 当指针指向结构体数组时，通过递增指针，可以遍历数组中的每个元素。
- 结构体数组中的每个元素都可以被视为独立的结构体变量，因此可以使用相同的方式通过指针访问其成员。
- 结构体数组的名字（如 `stuArr`）可以直接作为指向数组第一个元素的指针使用，不需要取地址操作。

## 3.用指向结构体的指针作为函数参数

​	一种是通过传递结构体指针给函数，另一种是通过传递结构体值（复制）给函数。同时也提到了这两种方法在功能上的差异，特别是在修改结构体成员时的不同效果。

### 结构体指针作为函数参数

​	下面这个例子演示了如何通过指针修改结构体成员的值。当结构体指针作为参数传递给函数时，函数内的任何修改都会反映到原始结构体变量上，因为传递的是地址。

#### 示例代码：

```c
void func1(struct student *p) {
    p->age = 118; // 通过指针修改结构体成员age的值
}

int main() {
    struct student stuArr[1]; // 声明结构体数组
    struct student *ps;       // 声明结构体指针
    ps = stuArr;              // 指针指向结构体数组的第一个元素
    func1(ps);                // 调用函数，传递指针
    printf("stuArr[0].age = %d\n", stuArr[0].age); // 输出修改后的age值
    return 0;
}
```

​	在这个例子中，`func1` 接受一个指向 `struct student` 的指针，并将 `age` 成员设置为 `118`。在 `main` 函数中，通过传递数组的第一个元素的地址来调用 `func1`，结果显示 `stuArr` 数组的第一个元素的 `age` 成员被成功修改。

### 结构体值作为函数参数

​	下面这个例子演示了通过值传递结构体给函数。当结构体值（而非指针）作为参数传递给函数时，函数内部的修改不会反映到原始的结构体变量上，因为传递的是该变量的一个复制（副本），而非其本身。

#### 示例代码：

```c
void func1(struct student d) {
    d.age = 118; // 尝试修改传入的结构体副本的age成员
}

int main() {
    struct student stuArr[1]; // 声明结构体数组
    stuArr[0].age = 12;       // 初始化数组第一个元素的age成员
    func1(stuArr[0]);         // 调用函数，传递结构体副本
    printf("stuArr[0].age = %d\n", stuArr[0].age); // 输出未被修改的age值
    return 0;
}
```

​	在这个例子中，尽管在 `func1` 中将 `age` 设置为 `118`，但这个变化只影响局部变量 `d`，不会改变 `main` 函数中数组 `stuArr` 的第一个元素的 `age` 成员。因此，当 `func1` 函数返回时，`stuArr[0].age` 的值仍然是初始化之前的值 `12`。

### 总结

​	这部分内容强调了在函数中通过指针传递结构体时能够修改原始结构体变量的成员，而通过值传递结构体时只能修改其副本，不会影响原始变量。这展示了在C语言中使用指针的强大功能，特别是当我们想要在函数外部保留修改时。通过对结构体变量的指针进行操作，可以有效地修改和管理复杂数据结构。




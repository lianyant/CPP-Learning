# 字符数组

## 1.字符数组的定义

​	字符数组在C和C++中是一种特殊的数组类型，用来存储字符序列。这种数组的每个元素都是一个字符，通常用来存储和操作字符串。字符数组其实也是一维数组。(字符数组，表示每一个数组元素中保存的是字符。)

## 2.字符数组的初始化

​	在C和C++中，字符数组（通常用于存储字符串）可以通过多种方式初始化。这些初始化方式不仅适用于静态存储期的字符数组，也适用于自动存储期的字符数组（例如，在函数内部声明的局部数组）。以下是一些常见的字符数组初始化方式：

### 1. 使用字符串字面量

直接使用字符串字面量初始化字符数组时，编译器会自动在字符串末尾加上`\0`（空字符）作为字符串的结束标记。

```c
char str[] = "Hello, world!";
```

这里，`str`数组的大小会被自动计算为字符串长度加1（为`\0`留出空间）。

### 2. 逐字符初始化

可以显式地逐个指定字符数组中每个元素的值。如果选择这种方式，需要手动添加`\0`作为字符串的结束标记。

```c
char str[14] = {'H', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!', '\0'};
```

这种初始化方式较为繁琐，通常用于非字符串字面量的情况。

### 3. 部分初始化

当字符数组在初始化时没有指定所有元素的值，未指定的元素会自动初始化为`\0`。

```c
char str[50] = "Hello";
// 或
char str[50] = {'H','e','l','l','o'};
```

在这个例子中，数组`str`的前5个字符被初始化为`"Hello"`，其余字符都自动初始化为`\0`。

### 4. 指定初始化器（C99和C11）

在支持C99或C11标准的编译器中，可以使用指定初始化器来初始化数组的特定元素。

```c
char str[10] = {[0] = 'H', [1] = 'i', [9] = '\0'};
```

这将初始化`str`的第一个元素为`'H'`，第二个元素为`'i'`，最后一个元素为`\0`，其余元素自动初始化为`\0`。

### 5.如果初值个数大于数组长度，则做语法错误处理

```c
char c[8] = {'I',' ','a','m',' ','h','a','p','p','y'};// 编译时会报错
```

### 注意事项

- 初始化字符数组时，确保为字符串的结束标记`\0`留出空间，这对于字符串的正确处理至关重要。
- 当字符数组被用作字符串时，使用字符串字面量进行初始化是最直接和常见的方式，因为它自动处理了结束标记。
- 在处理字符数组时，要注意数组的大小，避免在字符串操作中产生溢出。

​	字符数组的初始化方式提供了灵活性，允许在定义字符数组时立即给出其内容，或者部分初始化然后在程序运行过程中修改其内容。



#### 看这个示例代码：

```c
char a[10] = "I am happy";// 错误
```

​	在C和C++中，当您声明并初始化一个字符数组时，数组的大小应该足够包含初始化字符串（包括结尾的空字符`\0`）。在上面这个例子中，字符串 `"I am happy"` 实际上包含了9个可见字符和1个结尾的空字符 `\0`，总共需要10个字符的空间来存储。因此，声明 `char a[10]` 只提供了恰好的空间来存储字符，没有额外的空间来存放结尾的 `\0`。为了避免潜在的缓冲区溢出和确保字符串正确存储，数组的大小应该至少为字符串长度加1（为结尾的 `\0` 留出空间）。正确的声明应该是：

```c
char a[11] = "I am happy";
```

```c
char a[] = "I am happy";
```

​	这样，编译器会分配足够的空间来存储包括结尾的 `\0` 在内的整个字符串。不正确地为字符串分配空间可能导致未定义的行为，特别是当字符串操作（如复制、连接或修改）依赖于 `\0` 来确定字符串的结束时。如果没有足够的空间存储 `\0`，这些操作可能会读取或写入数组边界之外的内存，导致数据损坏、程序崩溃或安全漏洞。总之，确保为字符串分配足够的空间是防止常见编程错误的重要一步。在定义字符数组时，考虑字符串的实际长度加上结尾的空字符是一个好习惯。其根本的原因是：

​	在C和C++中，**字符串字面量是以空字符 `\0` 结尾的**。这意味着当您使用双引号定义一个字符串时，编译器会自动在字符串的末尾添加一个 `\0` 字符。这个空字符用来标记字符串的结束，使得函数如 `strlen`、`strcpy` 等能够确定字符串的边界。例如，当声明一个字符串字面量如下：`char str[] = "hello";`编译器实际上存储的内容是 `{'h', 'e', 'l', 'l', 'o', '\0'}`。数组 `str` 将包括5个字符加上一个结尾的空字符，总计6个字符。

​	使用 `\0` 作为字符串的终结符是C语言设计中的一个重要特性，这有助于：

1. **字符串操作的安全**：标准库中的许多字符串操作函数，如 `strcpy()`、`strcmp()` 和 `strlen()` 等，都依赖于 `\0` 来识别字符串的结束。没有 `\0`，这些函数就会继续读取内存，直到偶然遇到一个 `\0`，这可能导致超出数组边界的访问，从而引发安全漏洞或程序崩溃。
2. **与其他数据结构的兼容性**：许多历史悠久的函数和库，包括操作系统的API，都是基于C字符串的，这些函数和库需要 `\0` 结尾的字符串来正常工作。

​	当手动处理字符数组时，特别要注意确保为 `\0` 留出空间，以防止潜在的运行时错误。

#### 继续特殊讨论：

​	无论字符串字面量中的内容如何，包括无论字符串中已经有一个或多个 '\0' 字符的存在于任何位置（开头、中间或末尾）；或者即便字符串中的内容是空的情况下，编译器总是会在字符串字面量的最后添加一个额外的 '\0' 字符以确保字符串的正确终结。这是确保字符串被正确处理的一个标准做法。

**为什么会这样处理**

​	在C和C++中，字符串字面量被定义为以 '\0' （空字符）结尾的字符数组。这个终结符是必需的，因为它标识了字符串的结束，这对于大多数字符串操作函数来说是必需的，以避免超出字符串的实际存储区域。这包括标准库函数如 `strlen()`、`strcpy()` 等，这些函数依赖于 '\0' 来确定何时停止操作。

**示例说明**1

```c
char str1[] = "Hello\0World";
```

这个字符串字面量中，尽管在 `"Hello"` 和 `"World"` 之间已经明确地插入了一个 `\0`，它实际存储在内存中的形式将是：

```c
{'H', 'e', 'l', 'l', 'o', '\0', 'W', 'o', 'r', 'l', 'd', '\0'}
```

这里最后的 `\0` 是编译器自动添加的，确保字符串字面量的定义完整。

**示例说明**2

```c
char str3[] = "";
```

存储在内存中的数据为：`{'\0'}`。即使字符串字面量为空，编译器也会添加一个 `\0`。

**结论**

​	无论字符串字面量中是否已经包含一个或多个 '\0'，编译器都会在其末尾添加一个 '\0'。这样做保证了字符串的处理逻辑和内存安全性得以维护，同时也符合C和C++对字符串字面量的定义。

## 3.字符串和字符串结束标记

​	'\0'称为字符串结束标志。

​	在C语言中，字符串被定义为一个以空字符`'\0'`（null terminator，ASCII值为0）结束的字符序列。这个结束标记不是字符串内容的一部分，而是标记字符串结束的标志。因此，字符串“hello”在字符数组中实际上占用6个字符的空间：'h'、'e'、'l'、'l'、'o' 和 '\0'。

​	来看两种初始化方式：

```c
// 方式一
char c[] = {'I',' ','a','m',' ','h','a','p','p','y'};
// 方式二
char c[] = {"I am happy"};
char c[] = "I am happy";
```

**打印时的输出结果**

​	对于这两种方式来说输出可能是一样的：I am happy

​	方式一这种方式初始化的字符数组`c`**没有自动包含空字符**`'\0'`作为字符串的结束标记。因此，数组`c`正好包含10个字符，对应于每个初始化时列出的字符。如果你使用`printf("%s", c);`来打印这个数组，可能会导致未定义行为(见针对打印输出结果的进一步说明)，因为`printf`函数寻找`'\0'`来确定字符串的结束位置，而这个数组没有提供。

​	方式二这种方式初始化的字符数组`c`**自动包含了空字符**`'\0'`作为字符串的结束标记。字符串字面量`"I am happy"`在内存中实际上是`{'I', ' ', 'a', 'm', ' ', 'h', 'a', 'p', 'p', 'y', '\0'}`，因此，这个数组包含11个字符，包括结尾的空字符。

**针对打印输出结果的进一步说明**

​	当使用`printf("%s", c);`来打印方式一初始化的字符数组时，因为数组没有以空字符`'\0'`结束，`printf`会继续读取内存直到偶然遇到空字符为止。这意味着它可能会打印出“I am happy”之后内存中紧接着的内容，直到遇到一个空字符`\0`。

​	这种行为是未定义的，因为它依赖于数组`c`之后内存的内容，这可能包含任意数据。在最好的情况下，紧跟在数组后面的内存恰好是一个`\0`，那么打印结果就仅仅是数组中的内容。然而，在其他情况下，可能会打印出垃圾数据，直到遇到一个`\0`字符。在最坏的情况下，这种越界访问可能导致程序崩溃。

​	为了避免这种未定义行为，确保以字符串形式使用的字符数组以空字符`\0`结尾是非常重要的。如果你想使用方式一并且以字符串的形式处理数组，你应该手动在数组的末尾添加一个`\0`：

```c
char c[] = {'I',' ','a','m',' ','h','a','p','p','y','\0'};
```

​	这样，`printf("%s", c);`就能安全地打印出"I am happy"，不会引发未定义行为。

**内存中方式一占用的字节数小于方式二**。

- 方式一：数组大小为10字节，因为直接列出了10个字符，没有包括字符串结束的空字符。
- 方式二：数组大小为11字节，自动包括了字符串结束的空字符`'\0'`。

方式二（使用字符串字面量）由于包含了结束的空字符，所以占用的空间比方式一更大。

**为什么会这样：**

​	在C和C++中，字符串是通过在末尾加上空字符`'\0'`来标记结束的。这对于字符串处理函数（如`printf`等）是必须的，以便它们知道何时停止处理字符串。当直接使用字符数组并列出元素时，如果不手动添加`'\0'`，编译器不会自动添加。但是，当使用字符串字面量初始化字符数组时，编译器会自动在末尾添加`'\0'`。

### 打印字符数组

​	为了安全地打印方式一中的字符数组，应该确保不越界访问并手动处理字符串结束，或者在初始化时包含`'\0'`。如果你打算用`printf`来打印字符数组作为字符串，最好确保字符串以空字符结尾。

## 4.字符数组中'\0'单独说明

​	在C和C++中，字符数组用于存储字符串时，是否包含空字符`'\0'`对其使用有重要的影响。空字符作为字符串的结束标记，在处理字符串时起着至关重要的作用。下面是有`'\0'`和没有`'\0'`时对于使用字符数组来存储字符串的影响和区别：

### 有`'\0'`

- **字符串的正确终止**：字符串操作函数（如`printf("%s", str);`、`strcpy`、`strlen`等）依赖于`'\0'`来确定字符串的结束位置。如果字符数组以`'\0'`结束，这些函数可以正确地操作字符串，不会读取或写入数组边界之外的内存。
- **安全性**：包含`'\0'`的字符数组在使用标准字符串函数进行操作时更安全，因为这避免了潜在的越界访问和未定义行为。
- **内存利用**：字符数组需要额外的一个字节来存放`'\0'`，所以实际可用于存储字符的空间比数组的总大小少一个字节。

### 没有`'\0'`

- **未定义行为**：如果字符数组用于存储字符串但不以`'\0'`结束，尝试使用标准的字符串处理函数（期望以`'\0'`结尾的字符串）可能会导致未定义行为。函数可能会继续访问数组后的内存，直到偶然遇到`'\0'`，这可能导致读取垃圾数据，或更糟糕的是，程序崩溃。
- **手动管理**：在没有`'\0'`的情况下，你需要手动管理字符数组的长度，并在使用它时小心处理，以避免越界。例如，你可能需要传递一个额外的参数来指定数组的有效长度。
- **非字符串用途**：如果字符数组不是用来作为字符串处理，而是仅仅作为字符的集合（例如，处理固定长度的编码数据），那么结尾的`'\0'`可能不是必需的。

### 结论

​	当字符数组用于存储字符串时，确保它以空字符`'\0'`结束是非常重要的，以兼容C和C++的标准字符串操作函数，并确保程序的安全和可靠。如果数组不包含以`'\0'`结尾的字符串，就必须非常小心地手动管理和使用这些数组，以避免可能的错误和安全问题。在设计程序时，最佳实践是始终在使用字符数组存储字符串时包含结束的空字符，除非有充分的理由并采取了适当的预防措施。

## 5.字符数组的输入/输出

​	字符数组可以通过标准输入输出函数进行读写。例如，使用`scanf`函数和`printf`函数来输入和输出字符串。

#### 输入

```c
char str[50];
printf("Enter a string: ");
scanf("%s", str);
```

​	这里要注意`scanf`使用`%s`格式化读取字符串时，会在字符串末尾自动添加`\0`结束标记。但是，`scanf`会在遇到空格、制表符或换行符时停止读取，因此它无法用于含有空格的字符串输入。对于包含空格的字符串，可以使用`fgets`函数：

```c
fgets(str, sizeof(str), stdin);
```

​	

​	对输入时的单独说明：当使用 `scanf("%s", str);` 读取字符串时，必须小心防止缓冲区溢出，这是因为 `scanf` 不会检查目标数组的大小，从而可能导致写入超出数组界限的数据，引起未定义行为，包括程序崩溃。

​	为了安全地使用 `scanf` 读取字符串到字符数组，你可以使用宽度说明符来限制可以读入的字符数量，以防止越界。宽度说明符应该设置为目标数组大小减去1（为字符串结束的空字符`'\0'`留出空间）。

​	假设你有一个大小为50的字符数组 `str`，那么可以这样使用 `scanf`：

```c
char str[50];
printf("Enter a string: ");
scanf("%49s", str);
```

​	在这个例子中，`%49s` 告诉 `scanf` 最多只能读取49个字符，并且会自动在读取的字符串后面添加一个空字符作为结束标记。这样就保证了即使用户输入的字符串长度接近或达到数组的最大容量，程序也不会因为数组越界而产生未定义行为。

​	关于缓冲区溢出：如果用户输入的字符超过了 `scanf` 允许的最大数量（在这个例子中是49个字符），那么超过的部分将不会被读取，可能留在输入缓冲区中，影响程序后续的输入操作。处理这种情况的一个常见做法是读取并丢弃输入缓冲区中剩余的字符，例如：

```c
int c;
while ((c = getchar()) != '\n' && c != EOF) { /* 丢弃剩余的字符 */ }
```

​	这个循环会读取并丢弃输入缓冲区中直到下一个换行符（或文件结束符，如果是从文件中读取的）的所有字符。

​	结论：使用 `scanf` 时，应该始终使用宽度说明符来限制读取的字符数量，以避免缓冲区溢出。这是一种基本的安全最佳实践，有助于保护你的程序免受因输入过长而导致的潜在问题。此外，对于需要包含空格的字符串输入，考虑使用 `fgets` 等更安全的函数。

#### 输出

​	当使用`printf`来输出字符数组时，使用`%s`格式说明符与使用`%c`格式说明符遇到空字符`'\0'`时的处理方式是不同的。

使用`%s`

- 当使用`%s`格式说明符输出字符串时，`printf`会从指定的内存地址开始输出字符，直到遇到第一个空字符`'\0'`为止。空字符`'\0'`标记了字符串的结束，因此`printf`在遇到`'\0'`时停止输出。这意味着如果字符数组以`'\0'`开始，使用`%s`将不会输出任何字符。

使用`%c`

- 当使用`%c`格式说明符输出字符数组时，`printf`会输出指定的单个字符，即使这个字符是空字符`'\0'`。`%c`格式说明符用于输出数组中的单个字符，不会因为遇到`'\0'`而停止输出。如果你想通过`%c`逐个字符输出整个字符串，需要在循环中手动检查`'\0'`并决定是否继续输出。

​	示例假设有以下字符数组：

```c
char str[] = {'h', 'e', 'l', 'l', 'o', '\0', 'w', 'o', 'r', 'l', 'd'};
```

- 使用`%s`：

```c
printf("%s", str);
```

这将输出`"hello"`，在遇到第一个`'\0'`时停止。

- 使用`%c`在循环中输出：

```c
for (int i = 0; i < sizeof(str)/sizeof(str[0]); i++) {
    printf("%c", str[i]);
}
```

这将输出`"hello\0world"`中的所有字符，包括空字符`'\0'`（虽然空字符在控制台上不可见）。如果你的目标是模拟`%s`的行为，你需要在循环中检查`'\0'`并相应地中断循环：

```c
for (int i = 0; i < sizeof(str)/sizeof(str[0]); i++) {
    if (str[i] == '\0') break; // 遇到'\0'停止
    printf("%c", str[i]);
}
```

结论

`%s`和`%c`在处理遇到`'\0'`时的行为不同：`%s`会在遇到`'\0'`时停止输出，而`%c`会继续输出直到明确告诉它停止为止。这种区别在处理包含或可能包含空字符的字符数组时尤为重要。

## 6.字符串处理函数

C标准库（`<string.h>`）提供了一系列操作字符串的函数：

- `strlen(str)`：返回字符串`str`的长度（不包括`\0`）。
- `strcpy(dest, src)`：复制字符串`src`到`dest`。
- `strcat(dest, src)`：将字符串`src`追加到`dest`的末尾。
- `strcmp(str1, str2)`：比较两个字符串`str1`和`str2`。如果`str1`==`str2`，返回0；如果`str1`<`str2`，返回负数；如果`str1`>`str2`，返回正数。
- `strncpy(dest, src, n)`：复制最多`n`个字符从`src`到`dest`。
- `strncat(dest, src, n)`：将最多`n`个字符从`src`追加到`dest`的末尾。
- `strncmp(str1, str2, n)`：比较字符串`str1`和`str2`的前`n`个字符。

总复习时将所有的函数都举例出来。且参照书上内容例子(6.3.5 字符串处理函数)，待完成。

### (1.)strlen函数简单讨论

​	`strlen` 是C语言标准库中的一个函数，用于计算字符串的长度。这个函数定义在 `<string.h>`（在C++中是 `<cstring>`）头文件中，它返回字符串中字符的数量，不包括终结的空字符（`\0`）。

**函数原型**

`strlen` 函数的原型如下：

```c
size_t strlen(const char *s);
```

- 参数:
  - `s`: 指向以 null 结尾的字符串的指针。

**返回值**

​	`strlen` 返回字符串的长度，这个长度不包括字符串结束的空字符。返回值的类型是 `size_t`，这是一个无符号整型，用于表示大小和长度。

**工作原理**

​	`strlen` 函数通过遍历字符串，从指定的起始地址开始，直到遇到第一个空字符为止，计数过程中不包括这个空字符。这意味着如果字符串正确以 `\0` 结束，`strlen` 能够返回正确的字符数。如果字符串没有正确结束，`strlen` 会继续计数直到遇到随机的 `\0`，这可能导致未定义行为，包括访问非法内存区域。

**使用注意**

​	在使用 `strlen` 时，必须确保传递给它的字符串指针指向一个以 `\0` 结尾的有效字符串。如果字符串没有以 `\0` 结尾，`strlen` 的行为是未定义的，这可能导致程序崩溃或安全问题。

**示例代码**

下面是使用 `strlen` 的一个简单示例：

```c
#include <stdio.h>
#include <string.h>

int main() {
    char str[] = "Hello, world!";
    size_t len = strlen(str);

    printf("Length of '%s' is %zu.\n", str, len);

    return 0;
}
```

在这个例子中，`strlen` 会返回字符串 `"Hello, world!"` 的长度，即13，因为它不计算字符串结尾的空字符。

​	`strlen` 是一个基本但非常有用的字符串函数，用于获取不包括终结空字符的字符串长度。正确使用它需要保证输入的字符串是以 `\0` 结尾的。由于它会遍历整个字符串以寻找结束符，因此在处理非常长的字符串时，其性能可能会是一个考虑因素。始终确保字符串正确初始化和结束以避免安全隐患。



**对于下面这个举例：**

```c
char c[] = {'I',' ','a','m',' ','h','a','p','p','y'};
char c1[] = {"I am happy"};// 可以省略{}
const char *p = "I am happy";
char c2[] = {'I',' ','a','m',' ','h','a','p','p','y','\0'};
char c3[] = "I am h\0appy\0";
```

当使用strlen进行打印时：

**字符串数组 `c`**

```c
char c[] = {'I',' ','a','m',' ','h','a','p','p','y'};
```

- **描述**: 这是一个字符数组，其中没有明确包含结束的空字符 '\0'。
- **`strlen` 结果**: 使用 `strlen` 函数计算 `c` 的长度会导致未定义行为，因为 `strlen` 将会继续在内存中读取，直到遇到一个随机的 '\0'。因此，这种情况下使用 `strlen` 是不安全的。

**字符串数组 `c1`**

```c
char c1[] = {"I am happy"}; // 可以省略{}
```

- **描述**: 这是一个正确定义的字符串字面量，自动包含了末尾的 '\0'。
- **`strlen` 结果**: `strlen(c1)` 将返回 `9`，因为字符串 "I am happy" 由9个可见字符组成。

**指针 `p`**

```c
const char *p = "I am happy";
```

- **描述**: `p` 指向一个包含末尾 '\0' 的字符串字面量。
- **`strlen` 结果**: `strlen(p)` 同样会返回 `9`，与 `c1` 相同。

**字符数组 `c2`**

```c
char c2[] = {'I',' ','a','m',' ','h','a','p','p','y','\0'};
```

- **描述**: 这是一个包含了显式结束符 '\0' 的字符数组。
- **`strlen` 结果**: `strlen(c2)` 会返回 `10`，计算从开始到 '\0' 之前的所有字符。

**字符数组 `c3`**

```c
char c3[] = "I am h\0appy\0";
```

- **描述**: 字符串中包含了一个嵌入的 '\0'，后面的字符将被 `strlen` 忽略。
- **`strlen` 结果**: `strlen(c3)` 将返回 `6`，因为它会在 "I am h" 中的 '\0' 处停止计数。

**总结**

​	每个例子中 `strlen` 的行为依赖于字符串中第一个 '\0' 的位置。如果字符数组没有包含 '\0'，使用 `strlen` 可能会导致读取超出数组边界的内存，这是非常危险的。正确的字符串声明应该总是确保包含一个 '\0'，除非用于其他特定目的且不使用依赖于 '\0' 的标准字符串函数。

### (2.)strcpy函数简单讨论

​	`strcpy` 是一个在C语言中常用的标准库函数，用于复制字符串。它的原型定义在 `<string.h>`（在C++中是 `<cstring>`）头文件中。该函数将一个以 null 结尾的字符串（也就是C字符串）从源地址复制到目标地址，包括结束的空字符（`\0`）。

**函数原型**

`strcpy` 函数的原型如下：

```c
char *strcpy(char *dest, const char *src);
```

- 参数:
  - `dest`: 指向目标数组，即将要复制内容到其中的字符数组。这个数组必须有足够的空间来容纳被复制的字符串，包括结尾的空字符。
  - `src`: 指向源字符串的指针，这个字符串应该是以 null 结尾的。

**返回值**

`strcpy` 函数返回一个指向目标字符串 `dest` 的指针。

**使用注意**

​	使用 `strcpy` 函数时需要特别注意目标数组 `dest` 必须足够大，能够存放源字符串 `src` 的所有字符，包括结尾的 `\0`。如果 `dest` 数组不够大，就会发生缓冲区溢出，这可能导致程序崩溃或安全漏洞。

**示例代码**

下面是一个使用 `strcpy` 的简单示例：

```c
#include <stdio.h>
#include <string.h>

int main() {
    char src[] = "Hello, world!";
    char dest[50]; // 确保有足够的空间

    strcpy(dest, src);
    printf("Copied string: %s\n", dest);

    return 0;
}
```

**安全替代**

​	因为 `strcpy` 不检查目标缓冲区的大小，使用它时容易引发安全问题。因此，很多情况下推荐使用更安全的替代函数，如 `strncpy`，它允许指定最大复制长度，从而避免缓冲区溢出：

```c
strncpy(dest, src, sizeof(dest) - 1);
dest[sizeof(dest) - 1] = '\0'; // 确保字符串以 '\0' 结束
```

​	使用 `strncpy` 时，确保手动设置字符串的结束符是很重要的，因为当目标缓冲区大小小于源字符串长度时，`strncpy` 不会自动追加 `\0`。

​	总的来说，`strcpy` 是一个非常基本但必须小心使用的字符串操作函数。在现代C编程中，考虑到安全性，经常推荐使用其它更安全的函数来代替它。



**对于下面这个举例：**

```c
char str1[10] = "one1234";
sizeof(str1);// 10
char str2[15] = "two";
sizeof(str2);// 15
```

​	执行strcpy(str1,str2);语句，讨论如下：

​	使用 `strcpy(str1, str2);` 将 `str2` 的内容复制到 `str1` 中。在分析复制的结果之前，我们先看一下初始化的内容和数组的大小。

### 初始状态

1. `char str1[10] = "one1234";`

​	这个声明和初始化意味着 `str1` 是一个有10个字符空间的数组，初始化为字符串 `"one1234"`。字符串 `"one1234"` 包括7个字符加上一个自动添加的结尾空字符 `\0`，总共8个字符。因此：

- **初始化为**：`{ 'o', 'n', 'e', '1', '2', '3', '4', '\0' }`
- **后面的内容**：这个数组总共有10个位置，字符串和 `\0` 占用了8个，因此**剩下的2个字符将自动被初始化为 `\0`**。这是C语言在数组初始化时的行为——未明确初始化的部分将被设为0。
- 字符 `'\0'` 在 C 语言和其他一些编程语言中被用作字符串的终止符，它实际上是一个值为 0 的字符。这意味着在 ASCII 编码中，`'\0'` 的整数值是 0。这个字符通常被称为 NUL 字符或空字符。在字符串数组中，它用来标记字符串的结束位置。

2. `char str2[15] = "two";`

​	这个声明和初始化表示 `str2` 是一个有15个字符空间的数组，初始化为字符串 `"two"`。字符串 `"two"` 包括3个字符加上一个自动添加的结尾空字符 `\0`，总共4个字符。因此：

- **初始化为**：`{ 't', 'w', 'o', '\0' }`
- **其余部分**：数组总共有15个位置，字符串和 `\0` 占用了4个，**剩下的11个字符将自动被初始化为 `\0`**。这同样是基于C语言数组初始化的默认行为。

​	两个数组的剩余位置都将被自动初始化为 `\0`，而不是“未定义内容”或保持空白。这确保了数组的其余部分在默认情况下是干净的，不会有随机数据。在C语言中，当一个数组在声明时部分初始化时，未明确初始化的部分会根据数组的类型被填充为零值。对于不同类型的数组，这个“零值”有所不同(详细讨论见《30.初始化、赋值讨论》)。

**使用 `strcpy` 执行复制**

当执行 `strcpy(str1, str2);` 时，`str2` 中的内容（包括字符串末尾的 `\0`）将被复制到 `str1` 中。复制过程会继续直到遇到 `str2` 的字符串终止符 `\0`。

#### 结果

- **str1 的内容**：复制后，`str1` 的内容将变为 `{ 't', 'w', 'o', '\0' }`，后面跟着 `str1` 原有内容的未使用部分。因为原来的 "one1234" 已被覆盖，且复制终止于 `str2` 的终止符 `\0`。由于 `str1` 初始化长度为10，剩下的字符（原来位置上的 '1', '2', '3', '4' 及其后的空格）依然存在，直到数组的原始界限。

​	str1数组的完整内容为：`str1`: `{ 't', 'w', 'o', '\0', '1', '2', '3', '4', '\0', '\0' }`

- **sizeof(str1)**：`sizeof` 运算符返回的是数组分配的总大小，而不是字符串的有效长度。因此，`sizeof(str1)` 仍然是 `10`，这没有变化。
- str2数组保持不变，其内容为：`str2`: `{ 't', 'w', 'o', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }`

### 重要注意点

使用 `strcpy` 时没有进行边界检查，这可能导致溢出，特别是当目标数组无法容纳源数组时。在这个例子中，目标数组足够大，可以安全地容纳源数组的数据。但在实际编程中，推荐使用 `strncpy` 或其他更安全的函数，如 `strlcpy`（如果可用），来避免潜在的溢出风险。

### 总结

- `strcpy(str1, str2);` 后，`str1` 中的内容将是 "two" 后跟 `\0` 和原数组中的剩余部分。
- `sizeof(str1)` 返回的是分配的数组大小，即 `10`，不受字符串实际内容的影响。

​	字符数组的大小在声明时就已经固定，由数组的长度决定。字符数组中包含多少个 `'\0'`（空字符）不会影响这个数组的总大小。数组的大小是由其声明时分配的元素数量决定的，不受数组内容的影响。例如，无论数组内容如何变化，`char array[10]` 的大小始终是10个字节。

## 7.注意事项/总结

- 当使用字符数组存储字符串时，总是要确保为`\0`结束标记留出空间。
- 在使用字符串处理函数时，要确保目标数组有足够的空间来存放结果，以避免溢出。
- 字符串函数中涉及的所有指针都必须指向有效的字符序列，以`\0`结束。

通过字符数组和字符串处理函数，可以实现字符串的各种操作，包括输入/输出、复制、拼接、比较等。正确和安全地使用这些工具是编写C和C++程序中的一个重要方面。



## 8.单独讨论：输出问题

```c
const char *p = "I am happy";
char c1[] = "I am happy";
```

​	关于C/C++中字符串和数组输出处理方式的讨论如下：

### 为什么打印字符串可以直接使用指针名或数组名？

在C/C++中，字符串可以被视为字符数组的指针，特别是当它们被定义为字符串字面量时。字符串字面量如 `"I am happy"` 在内存中以 null-terminated 字符序列的形式存储，即以 `\0` 结尾的字符数组。

1. **指针 `const char \*p = "I am happy";`**：
   - 这里 `p` 是一个指向常量字符的指针，它指向字符串字面量 `"I am happy"` 的首字符。
   - 在使用 `printf` 或 `std::cout` 打印时，只需传递指针 `p`。这是因为这些函数查找由指针指向的地址开始，直到遇到字符串的终止符 `\0` 为止。
2. **字符数组 `char c1[] = "I am happy";`**：
   - 在这种情况下，`c1` 实际上是数组的名称，它在表达式中（如传递给函数时）被转换（退化）为指向数组首元素的指针。
   - 所以当 `c1` 用于 `printf` 或 `std::cout` 时，实际上传递的是指向数组首元素的指针，和传递指针 `p` 的情况类似。

### 为什么整型数组不能以同样方式打印？

​	整型数组如 `int a[5] = {1,2,3};` 与字符数组不同，因为整型数组不是以 null-terminated 方式存储。当 `a` 被传递到 `printf` 或 `std::cout` 时，它退化为指向首元素的指针，但这些函数无法确定数组的长度，并且不会像处理字符串那样寻找终止符。

- 使用 `printf` 或 `std::cout`打印整型数组的内容需要显式遍历数组元素：

  ```c
  for (int i = 0; i < 5; ++i) {
      printf("%d ", a[i]);
  }
  printf("\n");
  ```

  或使用 C++ 的 `std::cout`：

  ```cpp
  for (int i = 0; i < 5; ++i) {
      std::cout << a[i] << " ";
  }
  std::cout << std::endl;
  ```

### 结论

- 字符数组（字符串）可以直接使用数组名或指针名打印，因为它们是以 null-terminated 的方式存储，所以打印函数能够确定何时结束。
- 整型数组不包含结束符，所以需要显式地通过索引遍历来打印每个元素。不提供内置机制自动打印整个数组，因为打印函数不能自动识别数组长度。

### 原理

​	在 C 和 C++ 中，使用 `printf` 的 `%s` 格式化选项或 `std::cout` 来打印字符串涉及到字符串的内部表示和如何处理这些字符串的内部机制。下面是具体的解释：

#### 1. `printf` 函数中使用 `%s`

在 C 语言中，字符串被存储为字符数组，以空字符 `\0` 结束。这意味着每个字符串都会在数组的最后一个字符之后有一个 `\0` 字符，标记字符串的结束。这种表示方法称为 C 字符串或空终止字符串。

当使用 `printf` 函数并通过 `%s` 格式指定符来打印字符串时，`printf` 会从提供的地址（即字符串的起始地址）开始输出字符。`printf` 继续读取并打印每个连续字符，直到遇到空字符 `\0`。遇到 `\0` 时，`printf` 停止打印，因为它标志着字符串的结束。

示例代码：

```c
#include <stdio.h>

int main() {
    const char* str = "Hello, world!";
    printf("%s\n", str);  // 打印 Hello, world!
    return 0;
}
```

#### 2. `std::cout` 在 C++ 中

在 C++ 中，`std::cout` 是标准输出流对象，用于输出操作。当使用 `std::cout` 来输出一个 C 字符串（即以 `\0` 结尾的字符数组）时，其工作原理与 `printf` 类似：从字符数组的起始地址开始输出，一直到遇到 `\0`。

此外，C++ 还提供了 `std::string` 类型的字符串。`std::string` 是一个类，封装了字符数据和相关的操作。当使用 `std::cout <<` 输出 `std::string` 对象时，`std::cout` 使用 `std::string` 类提供的重载的 `operator<<` 来正确输出字符串的内容，而不必担心 `\0`，因为 `std::string` 内部管理了数据的长度。

示例代码：

```cpp
#include <iostream>
#include <string>

int main() {
    std::string str = "Hello, world!";
    std::cout << str << std::endl;  // 打印 Hello, world!
    return 0;
}
```

#### 为什么输出整个字符串而不是单个字符？

​	这是因为字符串的设计初衷是代表字符的序列，而不仅仅是单个字符。函数如 `printf` 和 `std::cout` 的设计使其能够理解并遵循字符串的这种表示方式，按顺序打印字符直到遇到结束符号。这种设计允许程序员方便地操作和打印整个文本消息，而不是仅处理单个字符，极大地增强了编程的表达能力和方便性。

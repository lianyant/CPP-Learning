# 变量的指针和指向变量的指针变量

## 1.指针变量的定义

​	变量的指针就是变量的地址，谁的内存中保存着某个变量的地址，谁就是指向该变量的指针变量。

​	指针变量是一种特殊的变量类型，其存储的是内存地址，这个地址指向某种类型的数据。定义指针变量需要指明指针所指向的数据类型，这样编译器能够知道如何解释指针指向的内存内容，以及指针的移动应该跳过多少内存。

**语法**：

```c
type *pointer_name;
```

- `type` 是指针指向的数据类型。
- `*` 表示这是一个指针。
- `pointer_name` 是指针变量的名称。

**示例**：

```c
int *ptr; // 指向整数的指针
char *c; // 指向字符的指针
float *fp; // 指向浮点数的指针
```

​	在这些示例中，`ptr`、`c`、和`fp`分别被初始化为指向 `int`、`char` 和 `float` 类型数据的指针。

### 指针变量定义和使用的基本规则

1. **指针变量定义时的`*`号**：
    - 在声明指针变量时使用的`*`号，表示该变量为指针类型。这个符号是类型的一部分，表明该变量存储的是一个地址，该地址指向一个特定类型的数据。
    - 示例：`int *ptr;` 这里，`ptr` 是一个指向整型数据的指针。
2. **使用指针变量时的`*`号**：
    - 使用指针变量时，如果前面带有`*`号，这代表对指针进行解引用操作，即访问指针所指向的内存地址中存储的数据(代表该指针变量所指向的变量)。
    - 示例：`*ptr = 10;` 这里，`*ptr` 访问 `ptr` 指向的内存地址，并将该地址中存储的整数值设置为10。
    - 在没有`*`号的情况下提及指针变量，如直接使用`ptr`，表示的是指针本身的值（即一个地址）。
3. **指针类型的一致性**：
    - 一个指针变量只能指向宣告时指定的类型的变量。这是为了确保通过指针进行的内存操作符合数据类型的大小和解释方式。
    - 示例：`int *ptr;` 这里，`ptr` 只能指向`int`类型的变量。

### 指针声明的语法风格

您提到的关于指针声明的四种风格，在C语言中都是有效的，这些风格的选择通常取决于个人或团队的编码习惯：

- `type *pointer_name;` // 最常见，推荐使用，清晰表明*是指针的一部分
- `type* pointer_name;` // 有些开发者偏好将*紧靠类型，表明是类型的一部分
- `type*pointer_name;` // 较少使用，可读性不佳
- `type * pointer_name;` // 清晰，但较为冗长

### 总结

​	在C语言中，理解和正确使用指针是非常重要的。指针的声明方式虽有多种，但关键在于保持一致性和清晰性，以提高代码的可读性和可维护性。正确地理解`*`在声明和使用时的不同含义，可以有效避免常见的编程错误。这也有助于开发者更好地管理内存和执行复杂的数据操作。

## 2.指针变量的引用

​	指针变量中只能存放地址（指针），不要将一个整型变量 （或任何其他非地址类型的数据）赋值给一个指针变量。

​	一旦定义了指针变量，你可以使用它来访问或修改其指向的内存地址中存储的数据。

### 地址操作符（&）

- **又称为取地址运算符**，用于获取变量的内存地址。例如，如果有一个整型变量 `int a;`，使用 `&a` 将返回这个变量的内存地址。这个运算符常用于初始化指针变量，使指针指向特定的数据。

### 解引用操作符（*）

- **又称为指针运算符或间接访问运算符**，用于访问指针指向的内存地址中存储的数据。这使得程序可以通过指针间接地操作变量。例如，如果 `int *p = &a;` 是一个指向整型变量 `a` 的指针，使用 `*p` 可以访问或修改 `a` 的值。

**示例**：

```c
int val = 23;
int *ptr = &val; // ptr 现在指向 val 的地址
int value_stored = *ptr; // 解引用 ptr，获取 val 的值
*ptr = 30; // 通过 ptr 修改 val 的值
```

​	在这个例子中，`ptr` 被赋值为 `val` 的地址，然后通过 `*ptr` 对 `val` 进行读取和修改。



### 特殊的指针操作

1. **&\*p1**
    - `&*` 这对操作符在一起使用时，`*` 表示解引用操作，`&` 表示取地址。因此，`&*p1` 首先解引用 `p1` 得到 `p1` 指向的变量，然后再取这个变量的地址。这实际上等于 `p1` 本身，因为这两个操作相互抵消。
2. **\*&a**
    - 同理，`*&` 操作首先取 `a` 的地址，然后再解引用这个地址。这操作结果就是 `a` 本身，因此 `*&a` 等同于 `a`。
3. **(\*p1)++**
    - 这表示先解引用 `p1` 得到它指向的变量，然后对这个变量执行自增操作。假如 `p1` 指向变量 `a`，则 `(*p1)++` 相当于 `a++`。
4. **p1++**
    - 这是指针的递增操作，但在C语言中对指针的递增操作意味着指针会向前移动它所指类型的完整大小。例如，如果 `p1` 是一个指向 `int` 的指针，而 `int` 在当前平台上是4字节，那么 `p1++` 会使 `p1` 的值增加4，从而指向下一个 `int` 类型的位置。
    - `*p1++` 等价于 `*(p1++)`，表示先取 `p1` 当前指向的值，然后将 `p1` 移动到下一个位置。这是个“先取值再递增指针”的操作。

### 理解指针的自增

- 当 `p1` 指向一个整型变量（如 `a`）时，`p1++` 的效果是使 `p1` 指向内存中紧接着 `a` 的下一个整型位置。如果 `a` 的地址是1000，且每个整型占4字节，则执行 `p1++` 后，`p1` 将指向地址1004。

### 实际应用和代码示例

​	在实际的编程中，理解这些指针操作对于高效地使用指针、避免错误和优化程序性能至关重要。建议通过编写和调试测试代码来加深理解，并实践如何在复杂程序中安全地使用指针。

​	解引用操作符（*）和地址操作符（&）都是一元运算符，并且它们具有相同的优先级，但这并不意味着它们的效果相同或者它们的应用没有特定的顺序。在没有括号改变运算顺序的情况下，它们按照从右到左的顺序解析和执行。

​	尽管解引用操作符（*）和地址操作符（&）有相同的优先级并且都是从右到左结合，它们在实际使用中会根据上下文相互抵消或者产生特定的数据访问效果。理解这些操作符如何互动是掌握C语言指针操作的关键部分。

### 特别说明

​	在C和C++中使用指针时，确保指针指向一个具体的对象或者明确地指向`nullptr`（在C++11及更高版本中）或`NULL`（在C和早期的C++版本中）是非常重要的。这样可以避免指针悬挂（dangling）或野指针（wild pointer）的问题，从而提高程序的稳定性和安全性。以下是这种做法的一些关键点：

1. **具体指向的对象**：指针可以指向变量、数组、动态分配的内存（如使用`malloc`或`new`分配的内存）等。这意味着指针持有有效内存地址，可以安全地进行读写操作。

    ```c
    int a = 10;
    int* p = &a;  // p指向变量a
    ```

2. **指向`nullptr`或`NULL`**：当指针不指向任何有效对象时，将其初始化为`nullptr`（C++）或`NULL`（C）是一种良好的编程习惯。这样可以在使用指针之前检查其有效性，避免野指针导致的不确定行为。

    ```c
    int* p = nullptr;  // C++中使用nullptr
    ```

    ```c
    int* p = NULL;     // C中使用NULL
    ```

3. **未初始化的指针**：声明一个指针但不初始化是危险的，因为它可能指向任意位置，其值是未定义的。使用这样的指针进行读取或写入操作可能导致程序崩溃或不可预测的行为。

    ```c
    int* p;  // 未初始化，指向未知
    *p = 10; // 危险操作，行为未定义
    ```

​	总结来说，确保指针要么指向一个具体的对象，要么明确地设置为`nullptr`或`NULL`，这是使用指针时的一个重要准则，有助于编写更安全、更可靠的代码。

​	如果定义了一个指针但在程序中从未使用它，那么无论它指向何处，实际上都不会产生直接的错误或问题，因为没有任何操作尝试访问该指针所指向的内存。然而，这种做法通常不被推荐，因为它可能引入潜在的风险和不良的编程习惯。

**为什么避免使用未初始化的指针**

即便指针未被使用，未初始化的指针也有以下几个潜在问题：

1. **代码维护难度增加**：未来代码可能会被修改或扩展，那时未初始化的指针可能被误用，从而导致不可预测的行为。
2. **代码审查和质量控制**：在代码审查过程中，未初始化的指针可能会被视为潜在的风险点，增加审查成本。
3. **程序扩展和重构风险**：如果代码在未来被其他开发者修改或扩展，存在未初始化的指针可能会被误解为一个待使用的有效指针，从而误导开发者进行不安全的内存操作。

**最佳实践**

因此，最佳实践是总是初始化指针，无论是将其设置为指向一个具体的对象，还是设置为`nullptr`（在C++中）或`NULL`（在C中）。这样做的好处包括：

- **提高代码安全性**：初始化指针可以预防未来可能的野指针或悬挂指针问题。
- **增强代码可读性和维护性**：清晰地表明指针的初始状态有助于代码的阅读和维护。
- **防止未来错误**：即使当前代码中未使用该指针，初始化也可以防止未来修改时引入错误。

​	即使在当前的使用场景中，指针未被使用且看似不初始化没有造成任何问题，良好的编程习惯仍然推荐进行明确的初始化，这是一种预防性的安全措施。

## 3.指针变量作为函数参数

​	指针作为函数参数使得函数能够直接修改传入的变量的值，或处理数据数组而无需复制数据。

**传递指针的好处**：

- 允许函数修改调用者的数据。
- 减少数据复制，提高效率，特别是对于大型数据结构。

**示例**：

```c
void swap(int *x, int *y) {
    int temp = *x;
    *x = *y;
    *y = temp;
}

int main() {
    int a = 5, b = 10;
    swap(&a, &b);
    printf("a = %d, b = %d\n", a, b); // 输出：a = 10, b = 5
}
```

​	在这个例子中，`swap` 函数接受两个整型的指针作为参数，并通过指针交换了两个变量的值。这演示了如何通过指针在函数中修改参数的值。



### 指针变量作为函数参数

​	在C语言中，将指针变量作为函数参数传递可以允许函数内部修改指针所指向的数据，即便是在函数调用结束后，这些修改也仍然有效。这种方式是通过传递变量的地址来实现的，而非变量的副本。

### Swap函数示例

​	swap函数展示了如何使用指针参数交换两个变量的值：

- **参数传递**: 函数通过接受两个指针参数（`pdest1` 和 `pdest2`），直接访问并修改这两个指针所指向的变量。
- **交换过程**: 函数内部通过一个临时指针（`ptemp`）帮助完成实际数据的交换操作，确保 `pdest1` 和 `pdest2` 指向的值被有效交换。

### 内存操作的细节

- **指针的直接操作**: 通过指针赋值（如 `pdest1 = pdest2`）实际上只是改变了指针的指向，而不会影响指针指向的原始数据。这种操作仅在函数内部改变指针的指向，不影响外部变量。
- **值的交换**: 真正的值交换是通过解引用指针并使用临时变量来完成的，如 `temp = *pdest1; *pdest1 = *pdest2; *pdest2 = temp;`。这样确保了 `pdest1` 和 `pdest2` 所指向的值被交换。

### 指针变量错误用法

- **未初始化的指针**: 使用未初始化的指针进行解引用是危险的，因为这可能导致不确定的行为甚至程序崩溃。指针在使用前应总是被明确地初始化指向一个合法的内存区域。

### 总结

​	通过指针作为函数参数，可以有效地在函数之外修改数据，这是通过指针提供的间接访问机制实现的。使用指针时，应特别注意指针的初始化和在函数间传递的效果，以避免常见的错误，如野指针和内存泄漏。在实践中，透彻理解和正确应用指针是高效利用C语言的关键。这种通过指针间接修改数据的能力是C语言提供的强大而灵活的特性之一。
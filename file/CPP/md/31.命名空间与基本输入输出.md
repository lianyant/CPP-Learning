# 命名空间与基本输入输出(复习时结合书上的手写笔记和语雀以及结合chatgpt和Claude以及敲代码验证)

## 1.命名空间简介

​	设想一种场景：要做一个很大型的项目，项目中包含数百个.cpp文件（源代码文件）。这数百个.cpp文件当然不是一个人开发的，项目经理把这些文件分配给了10个人，每个人负责开发其中的几个.cpp文件。

​	但是发生了很尴尬的事，张三写了一个函数，起了个名字叫radius，李四也写了一个函数，名字也叫radius，当编译的时候，可以发现，因为这两个radius（）函数不但同名，而且参数和返回值完全相同，所以无法成功编译。

​	怎么办呢？将函数名定义的长点，如zhangsan_radius、lisi_radius？虽然也解决了问题，但是整体感觉这种解决方法不太让人满意——这么长的名字，书写和阅读都很不便。

​	不但函数名面临同名的问题，类名、变量名同样存在同名问题。那能否引入一种更好的处理同名实体的一种机制呢？有，这就叫“命名空间”。

​	*（注意:这里说的函数同名描述的是函数重定义（或命名冲突）的情况，而不是函数重载。在编程中，**函数重载**指的是在同一个作用域（如一个类或命名空间）内定义多个具有相同名称但参数列表不同（类型或数量）的函数。这样做允许函数根据传入的参数类型或数量来调用相应的实现，是一种(静态)多态的体现。而**函数重定义**或**命名冲突**是指在相同的作用域内，存在两个或多个具有完全相同的函数名和参数列表的函数。这通常会导致编译错误，因为编译器无法区分这些函数。命名空间正是为了解决这种函数重定义的问题而引入的。通过将不同的代码片段放入不同的命名空间，即使函数名和参数列表完全相同，它们也不会相互冲突，因为它们属于不同的命名空间。）*

​	命名空间就是为了防止名字冲突而引入的一种机制。系统中可以定义多个命名空间，每个命名空间都有自己的名字，不可以同名。可以把命名空间看成一个作用域，这个命名空间里定义的函数与另外一个命名空间里定义的函数，即便同名，也互不影响（因为命名空间名不同）。有几点说明：

（1）命名空间定义：

```cpp
namespace 命名空间名
{
    void radius(){
        
    }
}// 这里无需分号结尾
```

（2）命名空间定义可以不连续，可以写在不同的位置，甚至写在不同的源文件中。如果以往没有定义该命名空间，那么这就相当于定义了一个命名空间，如果以往已经定义了该命名空间，那这就相当于打开已经存在的命名空间并为其添加内容。

（3）外界访问某个命名空间中的实体的方法：

访问格式如下，其中两个冒号叫“作用域运算符”：

```cpp
命名空间名::实体名
```

看看如下范例，现在希望在main函数中调用命名空间NMZhangSan中的radius函数和调用NMLiSi命名空间下的radius函数：

```cpp
//main.cpp源代码如下：
namespace NMZhangSan
{
    void radius(){
        printf("NMZhangSan::radius()函数被执行\n");
    }
}
int main()// 主函数
{
    NMZhangSan::radius();// 调用NMZhangSan命名空间下的radius函数
    NMLiSi::radius();// 调用NMLiSi命名空间下的radius函数
}

//MyProject.cpp源代码如下：
namespace NMLiSi
{
    void radius(){
        printf("NMLiSi::radius()函数被执行\n");
    }
}
```

此时进行编译，会报错从而无法导致调用成功，系统不认识NMLiSi命名空间下的radius函数。为什么？

- 在main中调用NMZhangSan::radius之所以成功，是因为该函数和main函数处于同一个文件（main.cpp）中。

- 但是NMLiSi::radius函数却在MyProject.cpp文件中，所以main中调用NMLiSi::radius会失败（因为缺少该函数的声明）。

为了能够调用成功NMLiSi::radius，就需要对源代码进行细致认真的组织，组织得好，看起来和用起来就都方便，也能够体现出开发者的整体开发素质，所以，请一定要重视源代码的组织。该如何进行源代码的组织呢？

（1）把函数声明，包括以后学习类，要把类的定义等内容放到一个头文件中。

这里新建立一个MyProject.h的头文件，内容如下：

```cpp
namespace NMLiSi
{
    void radius();
}
```

（2）在main.cpp文件开头增加如下代码把MyProject.h这个头文件包含进来：

```cpp
#include "MyProject.h"
```

再次编译链接整个项目，成功，并能够正确执行。

（3）现在在main函数中可以成功调用NMLiSi::radius函数，但是每次调用都要在函数名之前写NMLiSi::前缀，感觉比较多余。是否可以简化书写，当然是可以的，通过using namespace来声明NMLiSi这个命名空间，声明后，调用NMLiSi命名空间中的函数就不再需要使用NMLiSi::前缀了。using namespace的使用格式如下：

```cpp
using namespace NMLiSi;
```

此时，把main函数中的“NMLiSi::radius()；”修改为“radius()；”，发现也能正确地调用NMLiSi命名空间中的radius函数。

当前完整的示例代码为：

```cpp
// MyProject.h内容:
namespace NMLiSi
{
    void radius();
}

//MyProject.cpp源代码如下：
namespace NMLiSi
{
    void radius(){
        printf("NMLiSi::radius()函数被执行\n");
    }
}

//main.cpp源代码如下：
#include "MyProject.h"
namespace NMZhangSan
{
    void radius(){
        printf("NMZhangSan::radius()函数被执行\n");
    }
}

using namespace NMLiSi;
int main()// 主函数
{
    NMZhangSan::radius();// 调用NMZhangSan命名空间下的radius函数
    // NMLiSi::radius();// 调用NMLiSi命名空间下的radius函数
    radius();// 调用NMLiSi命名空间下的radius函数
}
```

（4）试想，现在在“using namespace NMLiSi；”代码行的下面增加如下代码行，会出现什么情况呢？

```cpp
using namespace NMZhangSan;

// main.cpp源代码最终如下：
#include "MyProject.h"
// 标记为X处
namespace NMZhangSan
{
    void radius(){
        printf("NMZhangSan::radius()函数被执行\n");
    }
}
using namespace NMLiSi;
using namespace NMZhangSan;/* 如果将这两行移动到X位置处，也是可以的。因为：
将using namespace NMLiSi; 和 using namespace NMZhangSan;移动到namespace NMZhangSan的定义之前，对于解决歧义和函数调用的结果没有影响。这是因为using namespace的作用是在当前文件的全局范围内引入命名空间，使得该命名空间内的所有名称（例如函数、变量等）都可以在全局范围内被访问而无需命名空间前缀。

原因：
1.作用域层级：using namespace指令在哪里声明并不改变其影响范围，它依然是对整个文件有效，除非它被放置在另一个命名空间或局部作用域中。
2.编译器解析：不论using namespace出现在文件的哪个位置，编译器在处理文件时会考虑到整个文件的范围。因此，无论这些指令出现在文件的任何位置，它们都使得两个命名空间中的名称在全局范围内可见。*/
int main()// 主函数
{
    NMZhangSan::radius();// 调用NMZhangSan命名空间下的radius函数
    // NMLiSi::radius();// 调用NMLiSi命名空间下的radius函数
    radius();// 调用NMLiSi命名空间下的radius函数
}
```

​	此时编译代码，就会报错，报错的源头是main函数中的“radius()；”代码行。因为在NMZhangSan命名空间和NMLiSi命名空间中都包含radius函数，而通过using namespace既声明了NMLiSi命名空间又声明了NMZhangSan命名空间，此时，系统就无法分辨出到底调用NMLiSi命名空间中的radius函数还是NMZhangSan命名空间中的radius函数。所以，①要么不要同时声明两个命名空间；②要么不同命名空间中的函数不要同名；③要么调用radius函数时增加诸如“NMLiSi::”前缀。



## 2.基本输入/输出

### (1).前置知识：

​	C++标准库的内容和结构(C++标准库的组成部分)：

​	下面是C++标准库的一些关键组成部分的更精确描述，

1. **输入输出流库**（I/O Streams）：这部分库提供了一套丰富的输入输出功能，包括文件操作和内存流处理。

2. **语言支持库**：包括异常处理、初始化和类型信息等支持库。

3. **诊断库**：提供异常处理和断言支持。

4. **通用实用库**：包括动态内存管理、时间日期处理、随机数生成等实用功能。

5. **字符串库**（`<string>`）：提供对字符串操作的全面支持，如字符串的创建、修改、查询等。

6. **本地化库**：支持多语言和区域设置，包括货币、数字格式、日期时间格式等本地化处理。

7. **容器库**：是标准模板库（STL）的核心部分，提供了一系列如 `vector`, `list`, `map`, `set` 等容器。

8. **迭代器库**：提供了一系列用于访问STL容器如 `vector`, `list` 的迭代器，支持容器的遍历和元素访问。

9. **算法库**：提供了广泛的算法操作，如排序、搜索、变换和其他复杂操作，这些算法大多设计为模板函数。

10. **数值库**：提供数学函数和复数运算等数值处理功能。

另外，还应该注意到标准库中的一些其他组件，如多线程支持库，包括线程管理、同步原语（如互斥锁和条件变量）等。

这些库共同构成了C++的强大功能，支持从基础数据结构操作到复杂的系统编程。

### (2).基本输出

C语言中，通常往屏幕上输出一条信息会用到printf函数，但在C++中，通常不用printf进行输出，而是用C++提供的标准库，这样才显得专业。

特别提醒：在学习C++语言的过程中，不要排斥C++标准库，不要把针对C++语言的学习和针对C++标准库的学习割裂开来，而是要把学习C++标准库当作学习C++语言的重要组成部分。许多程序功能都要通过标准库来实现，所以，从现在起，每学习一个标准库功能，就是一个新的收获，就往更高水平又迈进了一步。

> C++标准库是C++语言标准的一部分。它提供了一组预定义的类和函数，用于处理常见的程序任务，如输入输出操作、字符串处理、数值计算和数据结构操作等。这些库功能大大增强了语言的表达能力和效率。
>
> C++标准库的设计紧密与C++语言的核心特性相结合，如对象导向编程、泛型编程和模板。库中的组件，如STL（标准模板库）的容器和算法，利用了C++的模板机制，提供了高度的灵活性和效率。
>
> **标准库和语言标准**
>
> - **语言核心**：定义了C++的基础语法和语义，如数据类型、控制结构、函数、类和模板。
> - **标准库**：提供实用的库功能，这些功能是用C++编写的，且符合C++的语言标准。
>
> C++标准库的引入是为了确保C++程序能够在不同的平台和编译器上具有一致的行为，同时也减少了程序员在实现常见任务时的编程工作量。例如，不需要从头开始实现排序算法或复杂的数据结构，因为标准库已经提供了这些。
>
> 随着C++语言的版本更新（如C++11、C++14、C++17、C++20等），标准库也在不断增加新的功能和改进现有功能，以反映现代编程的需求和实践。例如，C++11大幅增强了多线程支持和智能指针功能，这些都是作为标准库的一部分提供的。
>
> 因此，C++标准库是C++语言不可分割的一部分，是任何符合标准的C++环境的核心组成。

C++中输入/输出用的标准库是iostream库（输入/输出流）。什么叫流？流就是一个字符序列。那怎样在程序中使用这个标准库呢？只需要包含一个头文件就可以了：

```cpp
#include <iostream>  // C++中包含的许多头文件并不带拓展名
```

> <cstdio>和<iostream>的区别与联系：
>
> 在C++中，`cstdio` 和 `iostream` 是两个用于输入输出操作的标准库头文件，但它们属于不同的库，有不同的设计和使用方式：
>
> ### 1. `cstdio`：
> - **来源与功能**：`cstdio` 是C++中包含C标准I/O库函数的头文件。这个头文件是C语言中 `stdio.h` 头文件的C++版本。它提供了C风格的输入输出函数，如 `printf()`, `scanf()`, `fgets()`, 和 `fputs()` 等。
> - **命名空间**：在C++中，`cstdio` 将所有的C标准I/O库函数放在 `std` 命名空间中，虽然这些函数仍然可以在全局命名空间中访问，但推荐使用 `std::printf()`, `std::scanf()` 等形式来调用这些函数。
>
> ### 2. `iostream`：
> - **设计与实现**：`iostream` 是专门为C++设计的输入输出库，提供了面向对象的输入输出机制。这个库包括了如 `std::cin`, `std::cout`, `std::cerr`, 和 `std::clog` 等对象，这些都是用于处理标准输入、标准输出和标准错误的流对象。
> - **特点**：`iostream` 使用流操作符（`<<` 和 `>>`）来实现数据的输入和输出，支持对多种数据类型的操作，可以方便地与C++中的其他对象和数据结构（如STL容器）一起使用。此外，`iostream` 提供的I/O操作是类型安全的，这是它与C风格I/O函数的一个重要区别。
>
> ### 关系与区别：
> - **互操作性**：虽然 `cstdio` 和 `iostream` 都可用于输入输出操作，但它们通常不建议混合使用，因为 `iostream` 是类型安全的，而 `cstdio` 是基于C语言的，可能会引起类型错误或安全问题。
> - **性能**：通常情况下，`iostream` 的性能可能稍逊于 `cstdio`，因为流对象和类型安全的操作涉及更多的抽象。但是，对于现代编译器和优化，这种性能差异通常不显著。
> - **用途**：在C++编程中，推荐使用 `iostream`，因为它更符合C++的风格和面向对象的设计原则。而 `cstdio` 主要用于与C代码的兼容性或者是一些特定情况下需要使用C风格的I/O函数。
>
> 总的来说，`cstdio` 和 `iostream` 虽然都提供I/O功能，但它们的设计理念、使用方式以及与C++语言的整合程度有所不同。在C++中，推荐优先使用 `iostream` 来进行输入输出操作。

看如下范例：

```cpp
#include <iostream>
int main()
{
    std::cout << "很高兴大家一起学习C++\n";
    return 0;
}
```

请注意，上面代码中使用std::cout来输出一条信息（这个函数的功能是往屏幕输出字符。相当于printf函数）。如果不想在cout前面每次都写“std::”（显然std也是一个系统定义的命名空间名），可以在源代码文件开头位置增加下面代码行：

`using namespace std;`

分析一下`std::cout`这条语句。

(1).std：这是标准库中定义的一个命名空间。

(2).cout：是一个对象，一个与iostream相关的对象。cout对象被称为“标准输出”，一般用于向屏幕输出一些内容，索性把cout当成屏幕也是可以的。

​	也许在这里不太理解cout是怎样定义出来的，看看如下范例，该范例定义了一个叫作cout1的对象，借此理解cout是如何定义的：

```cpp
struct student// 定义一个c++中的结构体
{
    char name[10];
    int number;
}
namespace std
{
    int itest;
    struct student cout1;// 定义了一个叫做cout1的对象，后续可以使用cout1了
}
// 使用方法：
std::cout1.number = 100;
```

(3).<<：C语言中讲到位运算时看到过——左移运算符("<<")。但与std::cout一起使用的时候，就不再是左移运算符了，而是一个“输出”运算符。在C++中，`<<` 符号用于 `std::cout` 语句中被称为(流)插入操作符（insertion operator）。这是一种重载的操作符，用于将数据发送到输出流中，如标准输出流（`std::cout`）。在 `std::cout << "aaaaa";` 这个表达式中，字符串 `"aaaaa"` 被插入到 `std::cout`，从而使得字符串可以在标准输出设备（通常是终端或命令行窗口）上显示。

​	后面学习“类”时，会看到如何在类中写一个运算符，就好像写一个类中的成员函数一样。所以看到运算符“≪”时，可以看成是一个函数调用。既然是函数调用，那这个“<<”就有参数。可以把左侧的std::cout（对象）当成是“<<”的第一个参数，把"很高兴大家一起学习C++\n"当成是“<<”的第二个参数，“≪”运算符就是把第二个参数写到第一个参数里去。第二个参数是一个字符串，第一个参数是一个标准输出对象（屏幕）。所以，就把这个字符串输出到屏幕上了。

(4).\n：换行符，在C语言中已经多次用到过了。

看看如下范例，演示一下输出运算符的连用：

```cpp
int x = 3;
std::cout << x << "x的平方是" << x * x << "\n";// 3的平方是9
x++;
std::cout << x << "x的平方是" << x * x << "\n";// 4的平方是16
```

将上述范例换一种写法，不再使用\n来换行，而是使用endl。例如：

```cpp
int x = 3;
std::cout << x << "x的平方是" << x * x << std::endl;// 3的平方是9
x++;
std::cout << x << "x的平方是" << x * x << std::endl;// 4的平方是16
```



std::endl是一个函数模板名，相当于函数指针，建议暂时理解成函数，以后会详细讲解函数模板。有两点可以总结一下：

（1）一般来讲，能看到std::endl的地方都有std::cout的身影。

（2）std::endl一般都在语句的末尾，有两个作用。

·　输出换行符\n。

·　刷新输出缓冲区，调用flush（理解成函数）强制输出缓冲区中所有数据（也叫刷新输出流，目的就是显示到屏幕），然后把缓冲区中数据清除。

什么叫输出缓冲区？可以理解成一段内存，使用std::cout输出的时候实际上是往输出缓冲区中输出内容。那么输出缓冲区什么时候把内容输出到屏幕上呢？有如下几种情况：

（1）缓冲区满了。

（2）程序执行到main函数中的return，要正常结束了。

（3）使用std::endl了，因为使用后会调用flush（）。

（4）系统不太忙的时候，会查看缓冲区内容，发现新内容就正常输出。所以有时使用std::cout时，语句行末尾是否增加std::endl都能将信息正常且立即输出到屏幕。

（5）可能还有其他情况，这里不做进一步探讨。

读者可能还有一个疑问，为什么要有这个输出缓冲区？用std::cout直接输出信息到屏幕时，缓冲区的作用体现的不太明显，那如果是输出信息到一个文件中，那么输出缓冲区作用就明显了，总不能输出一个字符，就写一次文件，因为文件是保存在硬盘上，速度和内存比实在是慢太多了，所以很有必要将数据临时保存到输出缓冲区，然后一次性地将这些数据写入硬盘。

还有一个问题可能让读者不解：为什么一行代码中可以带很多个“≪”呢？如下面这行代码：

```cpp
std::cout << x << "x的平方是" << x * x << std::endl;
```

不防看一看“≪”的定义，看不懂也没关系：

```cpp
ostream& operator<<(ostream& os, const SomeType& value);
```

​	这个函数不是 `std::ostream` 对象（如 `std::cout`）的成员函数，而是定义为全局函数或者作为某个类的友元函数。这样设计是为了使得任何类型（如自定义类）都可以利用 `<<` 操作符输出到任何 `ostream` 派生类对象，包括 `std::cout`。在 C++ 中，`std::cout` 是 `std::ostream` 类的一个实例，而 `<<` 运算符是通过重载为 `std::ostream` 类（及其派生类）提供的。通常，`<<` 运算符被实现为 `std::ostream` 类的友元函数，这样它就能访问流的内部状态。这些友元函数通常会接受一个 `std::ostream` 引用和一个要输出的值，然后返回这个引用以支持链式调用。

注意到“≪”的返回值了吗？它返回的是ostream&，这里每一个 `<<` 操作符都调用相应的重载函数，每次调用都返回 `std::cout` 的引用，从而允许下一个 `<<` 连续执行。这是因为每个 `<<` 运算符的返回类型是 `ostream&`（对应就是std::cout` 的引用），从而实现了链式调用。所以第一个“<<”运算符的结果就成了第二个“≪”运算符左侧的运算对象：

```cpp
std::cout << x << "x的平方是" << x * x << std::endl;
```

等价于：

```cpp
(std::cout << x) << "x的平方是" << x * x << std::endl;
```

等价于：

```cpp
((std::cout << x) << "x的平方是" )<< x * x << std::endl;
```

等价于：

```cpp
(((std::cout << x) << "x的平方是" )<< x * x) << std::endl;
```



​	另外，类似下面这行std::cout代码，可以注意到，又能输出整型数，又能输出字符串。为什么呢？

```cpp
std::cout << x << "x的平方是" << x * x << std::endl;
```

之所以std::cout可以支持很多种不同类型数据的输出，是因为：

1. **运算符重载**: `<<` 运算符对于 `std::ostream` 类（和其派生类，如 `std::ofstream` 或 `std::ostringstream`）是重载的(理解此句话见X处的补充)。可以将这些重载视为类中的成员函数，但更常见的做法是将它们实现为友元函数，这样可以提高灵活性并允许第一个操作数（左操作数）不必是类的对象。
2. **多重定义/重载**：对于 `std::ostream`，`<<` 运算符确实有多个重载版本，用于接受不同类型的参数，如 `int`、`double`、`char`、`const char*`（字符串字面量），以及用户定义的类型。这些重载允许 `std::cout` 输出不同类型的数据。

**代码解释**

```cpp
std::cout << x << "x的平方是" << x * x << std::endl;
```

在这行代码中，`std::cout` 通过多个 `<<` 运算符重载来支持不同类型的数据输出：

- 首先，`std::cout << x` 使用适合 `x` 类型（假设 `x` 是整型）的 `<<` 重载。
- 紧接着，`<< "x的平方是"` 使用接受 `const char*` 类型的 `<<` 重载，用于输出字符串。
- 再之后，`<< x * x` 又一次使用适合整型的 `<<` 重载，输出 `x` 的平方。
- 最后，`<< std::endl` 调用接受 `std::ostream&` 类型参数并返回 `std::ostream&` 的重载，用于插入换行符并刷新缓冲区。

​	注意 `<<` 运算符通常被定义为友元而非成员函数，以便更广泛地支持各种数据类型的输出。这种灵活的重载机制使得 `std::cout` 能够混合输出多种不同类型的值，而且能够在连续的表达式中使用，极大地增强了 C++ 的表达力和灵活性。

### X处补充

理解 "`<<` 运算符对于 `std::ostream` 类是重载的" 这句话的关键在于理解 C++ 中的**运算符重载**概念，以及如何将这一概念应用于标准输出流对象如 `std::ostream`。

#### 运算符重载基本概念

在 C++ 中，运算符重载允许为已有的运算符提供额外的功能，使其能够对用户定义的类型进行操作。重载一个运算符意味着你可以定义或改变该运算符对某些特定类型数据的操作方式。对于内置类型，运算符的行为是预定义的，但对于用户定义的类型（例如类），你可以自由定义运算符的行为。

#### 应用在 `std::ostream`

对于 `std::ostream` 类，C++ 标准库通过重载 `<<` 运算符，使其能够处理各种不同的数据类型，例如整型、浮点型、字符串等。重载通常通过编写一系列的函数来实现，这些函数可以接受不同类型的参数，从而使得 `std::ostream` 类的对象（如 `std::cout`）能够接受并正确处理多种类型的数据输出请求。

#### 举例说明

例如，`std::ostream` 类拥有多个版本的 `<<` 运算符重载，每个重载版本都能处理不同类型的数据：

```cpp
std::ostream& operator<<(std::ostream& os, int num);
std::ostream& operator<<(std::ostream& os, double num);
std::ostream& operator<<(std::ostream& os, const std::string& str);
std::ostream& operator<<(std::ostream& os, const char* s);
```

每个这样的函数都接受 `std::ostream` 对象的引用作为第一个参数（这通常是 `std::cout`），并接受另一种类型的数据作为第二个参数。这些函数的工作是将第二个参数的数据格式化为字符串，然后写入到与 `std::ostream` 对象关联的输出缓冲区中。

#### 实现细节

在实际的 C++ 标准库实现中，这些运算符通常作为友元函数实现，这意味着它们虽然不是 `std::ostream` 类的成员函数，但可以访问该类的私有和保护成员。通过这种方式，运算符重载函数能够直接操作输出流的内部状态，如其缓冲区。

#### 结论

因此，当我们说 "`<<` 运算符对于 `std::ostream` 类是重载的"，意味着 `std::ostream` 类通过一系列重载的 `<<` 运算符，提供了一种灵活的方法来接收并输出不同类型的数据，从而极大地增加了编程的便利性和输出的灵活性。这使得例如 `std::cout` 这样的对象能够通过简单的语法输出多种类型的数据。

### (3).基本输入

​	cin也是一个对象，被称为“标准输入”。在C语言部分曾经讲过scanf函数，用于从键盘输入一些数据，在C++中，cin对象同样能够做这件事。看看如下范例：

```cpp
std::cout << "请输入两个数" << std::endl;
int value1 = 0,value2 = 0;
// C中用scanf时需要地址符&，但此处不需要
std::cin >> value1 >> value2;// 输入多个值之间用空格分开
// 可能的结果为：12和15相加的结果为：27
std::cout << value1 << "和" << value2 << "相加的结果为：" << value1 + value2 << std::endl;
```

有几点说明：

（1）cin也是一个iostream相关对象，被叫作“标准输入”，可以理解成键盘。

（2）≫：在C语言中讲到位运算时看到过——右移运算符。但与cin一起使用的时候，就不是右移运算符，而是一个“输入”运算符，在C++中，`>>` 符号用于 `std::cin` 语句中被称为(流)提取操作符（extraction operator）。这是一种用于从输入流中提取数据的重载操作符，常用于从标准输入流（`std::cin`）获取数据并存放到指定的变量中。输入流 `std::cin` 会接受用户的输入，并将其存储到字符串变量 `data` 中。

“≫”的左侧运算对象是cin（键盘），也就是把从键盘上输入的数据放入了“＞＞”右侧的变量中，于是，变量便有了值。

“≫”返回其左侧运算对象作为其计算结果，所以

```cpp
std::cin >> value1 >> value2;
```

等价于

```cpp
(std::cin >> value1) >> value2;
```

​	因为“≫”返回其左侧运算对象作为其结算结果，所以可以把多个要输入的数据都用“＞＞”连起来写到一个std::cin语句中。详细原理：`>>`，流提取运算符，用于从输入流中读取数据。当使用如 `std::cin >> variable` 的表达式时，`std::cin` 试图从标准输入（通常是键盘输入）中读取与变量 `variable` 类型相匹配的数据。与 `<<` 类似，每次使用 `>>` 操作符时，都会调用一个重载的 `operator>>` 函数。这个函数的设计是接收一个 `std::istream` 类型的引用（例如 `std::cin`）和一个要读取数据的变量的引用。完成数据的读取后，这个函数返回对其输入流（`std::istream` 的引用）的引用。因为每个 `>>` 操作的返回类型是 `istream&`（即对应的输入流的引用，如 `std::cin`），所以可以连续地从同一个输入流调用多个 `>>` 运算符。这允许在一行代码中顺序读取多个变量，每个操作符都依赖于前一个操作的返回值来继续执行。使用 std::cin >> value 时，std::cin 尝试从输入流中读取与 value 的类型相匹配的数据。完成后，它返回对其自身的引用（即 std::cin）。这使得流提取操作可以连续进行，形成一个链。 链式调用: 因为每个 >> 操作返回输入流本身（std::cin），所以可以连续地从同一个输入流调用多个 >> 运算符。这使得读取多个变量可以在一行代码中完成。

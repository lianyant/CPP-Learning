# noexcept关键字

​	noexcept 关键字是在 C++11 中引入的，它用来指示一个函数是否会抛出异常。使用 noexcept 可以让编译器优化掉那些通常为处理异常而保留的代码，从而可能提升性能。下面详细介绍 noexcept 的使用方法、场景和不同C++标准中的变化。

## 基本用法

noexcept 关键字可以跟在函数的参数列表后面。它可以有两种形式：

- noexcept：当不带任何参数时，默认为 noexcept(true)，表示该函数不会抛出异常。
- noexcept(expression)：当带有表达式时，如果表达式结果为 true，则表示函数不会抛出异常；如果结果为 false，则表示函数可能会抛出异常。
  例如：

```cpp
void func() noexcept; // 表示 func 不会抛出异常
void risky_func() noexcept(false); // 表示 risky_func 可能会抛出异常
```

## 使用场景

### 性能优化：

在知道函数不会抛出异常的情况下使用 noexcept，可以帮助编译器生成更优化的代码。例如，移动构造函数和移动赋值操作通常应该标记为 noexcept，这样容器（如 std::vector）在重分配内存并移动对象时可以安全地使用这些操作，而不是使用拷贝构造函数和拷贝赋值操作。

### 异常安全保证：

noexcept 明确指出函数的异常安全级别，有助于其他开发者理解代码，减少不必要的异常处理或检查。

### 接口设计：

在设计库或API时，使用 noexcept 可以明确函数的异常策略，使得库的使用者能够更清楚地知道哪些操作是保证不抛出异常的。

### C++11 和后续标准的差异：

C++11 中引入了 noexcept 关键字，以及基于此的一些优化和用法，例如在移动操作中使用 noexcept。
C++17 中增加了 noexcept 操作符的功能，允许在模板或其他复杂场景中检查函数是否标记为 noexcept。

例如：
```cpp
template <typename T>
void swap(T& a, T& b) noexcept(noexcept(std::swap(a, b))) {
    std::swap(a, b);
}
```

这样的模板可以保证只在被交换的操作是 noexcept 的情况下，自身也是 noexcept 的。

## 小结

noexcept 是一个重要的现代C++特性，它有助于改善程序的性能和可预测性，同时提供更清晰的异常安全承诺。在设计系统和库接口时，合理使用 noexcept 可以提高代码的质量和表达力。对于现代C++开发者来说，理解和正确使用 noexcept 是一项重要的技能。

## 额外讨论1

### 提问：

noexcept(true)时，try-catch就无法捕获到此函数的异常了。对吗？

### 回答：


实际上，对于使用 noexcept 或 noexcept(true) 标记的函数，这意味着该函数保证不抛出任何异常。如果一个 noexcept 函数确实抛出了异常，那么这并不是导致异常被静默捕获或忽略，而是会直接调用 std::terminate() 来结束程序。这是因为 noexcept 的语义是告诉编译器和运行时系统该函数不会抛出异常，如果违背了这一承诺，就无法正常处理异常，只能终止程序。

### noexcept 的作用：

当你声明一个函数为 noexcept，你是在告诉编译器这个函数不会抛出任何异常。编译器可能会基于这个信息进行优化，例如省略一些异常处理相关的代码。

### 异常抛出的后果：

如果一个标记为 noexcept 的函数抛出了异常，标准的行为是立即调用 std::terminate()，这将导致程序的非正常退出。

### 考虑以下示例代码：

```cpp
void test() noexcept {
    throw std::runtime_error("Error occurred");
}

int main() {
    try {
        test();
    } catch (const std::runtime_error& e) {
        std::cout << "Caught an exception: " << e.what() << std::endl;
    }
    return 0;
}
```

​	在这个例子中，尽管 main() 函数中有一个 try-catch 块试图捕获从 test() 抛出的异常，由于 test() 被标记为 noexcept，当异常被抛出时，程序将不会进入 catch 块，而是直接调用 std::terminate()。

### 小结

​	因此，如果你的函数可能会抛出异常，你不应该将其标记为 noexcept。只有当你确信函数在任何情况下都不会抛出异常时，才应使用 noexcept。这对于确保代码的正确性和可维护性非常重要。

​	简而言之，noexcept(true) 并不是阻止异常被捕获，而是防止函数抛出异常。如果违反了这一规定，程序会直接终止。

## 额外讨论2

### 提问：

你的意思是即便函数noexcept(true)了，也能被try-catch捕获到异常？

### 回答：


如果我之前的解释有误导，请允许我澄清：

​	如果一个函数被标记为 noexcept（等同于 noexcept(true)），意味着这个函数承诺不会抛出任何异常。在这种情况下，如果函数内部确实抛出了异常，异常不会被传递到调用者的 try-catch 块中去。相反，如果异常真的被抛出了，程序将直接调用 std::terminate() 函数来终止程序的执行。这意味着异常不会被外部的 try-catch 结构捕获，而是导致程序直接退出。

因此，确实是这样的：

​	当函数标记为 noexcept 并抛出异常时：不会触发常规的异常捕获机制，而是直接导致程序终止。
try-catch 无效：在函数内部抛出异常时，即便调用该函数的外部有 try-catch 语句，也无法捕捉到异常，因为程序已经被 std::terminate() 终止了。
​	这种行为确保了当开发者或库的作者标记函数为 noexcept 时，他们必须非常确信函数不会抛出任何异常。这样做的目的是为了让编译器和运行时环境可以依赖这个承诺进行优化，例如在某些操作中移除额外的异常处理代码。同时，这也是一种设计策略，用来强化函数的异常安全性质，确保高性能和稳定的执行行为。
# 函数

## 概念

​	在C和C++中，函数是一种将代码封装以便重用和组织的方式。函数可以接受输入（参数），执行一系列操作，然后可能返回输出（返回值）。使用函数，可以使代码更模块化、更易于理解和维护。

1. **封装性**：函数可以将一个特定的功能封装起来，使得这个功能可以在程序的多个地方被重复利用。
2. **调用**：通过函数名和所需的参数（如果有的话）来执行函数中定义的代码。
3. **参数（Parameters）与实参（Arguments）**：函数定义时指定的参数称为参数，调用函数时传递的值称为实参。
4. **作用域**：函数内定义的变量（局部变量）只在函数内部可见，这有助于避免不同部分的代码之间的命名冲突。



## 定义

函数的定义一般包含以下几个部分：

- **返回类型**：函数执行完成后返回给调用者的数据类型。如果不返回任何值，则使用 `void` 类型。
- **函数名**：标识函数的唯一名称。
- **参数列表**：括号内列出零个或多个参数，每个参数由类型和名称组成，参数之间用逗号分隔。如果没有参数，则括号内为空或者包含`void`。
- **函数体**：大括号内包含的是函数的具体执行语句。

```c
返回类型 函数名(参数类型1 参数名1, 参数类型2 参数名2, ...) {
    // 函数体
    // 可以包含返回语句
}
```



## 返回值

- **有返回值的函数**：如果函数声明了返回类型（除了`void`），那么它应该通过`return`语句返回一个该类型的值。`return`语句也会立即结束函数的执行。
- **无返回值的函数**：如果函数的返回类型为`void`，那么它不需要返回任何值。这类函数通常是执行某些操作，如打印输出或修改参数（如果参数是通过引用或指针传递的）。

示例：

```c
#include <stdio.h>

// 定义一个返回int类型的函数，接收两个int类型的参数
int add(int num1, int num2) {
    return num1 + num2; // 返回两个参数的和
}

int main() {
    int result = add(5, 3); // 调用函数并接收返回值
    printf("Result: %d\n", result);
    return 0;
}
```

在这个例子中，`add`函数接收两个`int`类型的参数，返回这两个参数的和。在`main`函数中，我们调用了`add`函数并打印了它的返回值。

另外的总结：

1. **形参与实参的内存分配**：当函数被调用时，为其形参（函数定义时指定的参数）分配内存，这些内存在函数调用结束后会被释放。这意味着形参仅在函数内部有效，无法在函数外部访问。
2. **实参的定义和类型**：实参（调用函数时传递给函数的参数）可以是常量、变量、表达式，这部分描述是正确的。
3. **参数传递方式**：当实参是数组名时，由于数组名代表数组的首地址，因此传递给函数的是数组的首地址，而非整个数组的拷贝。这说明了对于数组（以及指针），函数参数传递的行为看似是按引用传递，但严格来说C语言的参数传递是值传递——即使是指针或数组名，传递的也是它们的值（即地址值）。
4. **形参和实参的匹配**：形参和实参的数量与类型必须匹配，这是为了确保函数调用的正确性和数据的正确传递。如果不匹配，程序会编译失败或导致未定义行为。
5. **值传递机制**：C语言通过“值传递”的方式将实参的值复制给形参。这意味着在函数内部对形参的任何修改都不会影响实参。然而，如果传递的是指针或数组名（本质上也是地址），函数内部对指针所指向内容的修改可以影响到实参所指向的数据，因为这种情况下，传递的是内存地址的拷贝。
6. **返回类型的自动转换**：如果函数实际返回的类型与其声明的返回类型不一致，编译器会尝试将返回值类型自动转换为声明的返回类型。虽然这种自动转换可能在某些情况下正常工作，但这是一种不推荐的做法，因为它可能会导致数据丢失或其他不预期的行为。最佳实践是确保函数返回的类型与声明的返回类型一致。

### 返回值类型void讨论

在C和C++中，如果函数的返回类型被指定为 `void`，这意味着函数不期望返回任何值。对于这种类型的函数，编写函数体时您有两种选择：

1. **不写 return 语句**：
   - 在 `void` 类型的函数中，您可以完全省略 `return` 语句。函数会在达到函数体末尾时自动返回到调用者。
   - 这是最常见的方法，因为在 `void` 函数中添加 `return` 语句通常是多余的，除非您需要提前退出函数。
2. **写 `return;` 语句**：
   - 尽管 `return` 语句在 `void` 函数中通常不是必需的，但您可以包含一个不带任何返回值的 `return;` 语句。这在需要提前退出函数的情况下特别有用，例如在检测到某种错误条件时，您可能希望立即停止函数执行并返回。
   - `return;` 在 `void` 函数中的作用仅是控制流，告诉程序立即退出当前函数。

#### 示例说明

下面是一个展示这两种情况的例子：

```cpp
#include <iostream>

void process(int value) {
    if (value < 0) {
        std::cout << "Invalid value, exiting function." << std::endl;
        return;  // 提前退出函数
    }
    // 执行一些操作
    std::cout << "Processing value: " << value << std::endl;
    // 函数将在此自动结束和返回
}

int main() {
    process(10);
    process(-1);
    return 0;
}
```

在这个例子中：

- 当 `process` 函数接收到一个非负整数时，它会处理该值并到达函数体的末尾自动返回。
- 如果传入的值为负，函数会执行 `return;` 语句，立即停止进一步处理并退出，这避免了执行对负值的处理。

#### 结论

`void` 函数中使用 `return;` 语句是完全有效的，但通常不是必须的，除非需要从函数的中间位置提前退出。这样的设计提供了灵活的流程控制，允许程序员根据需要在任何时候退出函数，而不必等到函数自然结束。

## 函数调用方式和嵌套调用

### (1).函数调用的一般形式

​	函数调用的一般形式是通过指定函数名和在括号中提供相应的参数（如果有的话）来实现的。函数调用可以发生在任何表达式中，其中函数的返回值（如果存在）可以用作计算的一部分，或者单纯地执行某个操作而不关心返回值。如果函数没有参数，仍然需要使用空括号`()`。

```c
函数名(参数1, 参数2, ..., 参数N);
// 或者是这样的:
函数名(实参列表);
```

### (2).函数调用的方式

​	在C和C++中，函数调用主要有两种方式：**值传递**和**引用传递**（后者主要通过使用指针在C中实现，而C++提供了引用的概念）。

1. **值传递**：这是最常见的调用方式，其中函数的实参值会被复制到形参中。因此，在函数内部对形参的修改不会影响实参。
2. **引用传递**：通过传递实参的地址（指针）来实现，在函数内对形参的修改会影响到实参。在C中，这是通过明确使用指针类型的形参来实现的；在C++中，可以直接使用引用类型的形参。



​	按照函数调用在程序中出现的位置，把**函数调用方式**分为三类:

(1).把函数调用作为一条语句

如使用`printhello();`来调用`printhello`函数。这是函数调用最基本的形式。在函数调用末尾直接加了个分号，因此就叫做把函数调用作为一条语句。

(2).函数调用出现在一个表达式中，这种表达式称为函数表达式， 此时要求函数带回一个确定的值以参与表达式的运算。比如这个代码：`int result = addtwoshu(3,4) * 100;`

(3).函数调用甚至可以作为另一个函数调用的参数(也叫做函数嵌套调用)

如`result = whichmax(13, whichmax(12,19));`这里的`whichmax`函数被嵌套调用，首先调用`whichmax(12,19)`，然后使用其返回值与`13`作为参数调用。

​	**函数声明与定义**：函数声明是告诉编译器函数的存在，它的名字、返回类型以及参数（不包括具体参数名），如声明`int addtwoshu(int, int);`。函数定义则提供了函数的具体实现，如定义`int addtwoshu(int a, int b) { return a + b; }`。

​	**函数调用的规则**：在调用函数时，不能省略参数，也不能添加未声明的参数。正确的调用必须符合函数声明时的参数列表。这保证了调用的有效性和程序的稳定性。

​	**头文件的包含**：如果函数定义在另一个文件中，需要使用`#include`指令来包含相应的头文件，这样才能在另一个文件中使用这些函数。



### (3).函数声明与函数实现

​	在C和C++语言中，函数声明和函数定义有具体的用途和适用场景：

#### 函数声明（Function Declaration）

​	函数声明通常出现在源文件的顶部或头文件中，它告诉编译器函数的名称、返回类型以及参数列表的类型。函数声明是必要的，特别是在以下情况下：

1. **当函数在调用它的代码之前实现时**：如果你在一个文件中先调用函数，然后在文件的后面才提供函数的实现（定义），那么你需要在调用点之前声明函数。
2. **当函数在另一个文件中定义时**：如果函数的定义在另一个源文件中，你需要在使用该函数的文件中提供函数的声明。通常这通过包含一个头文件来实现，该头文件包含了函数的声明。
3. **在多文件项目中保持一致性**：在大型项目中，通常将函数的声明放在头文件中，这样任何包含了这个头文件的源文件都可以知道函数的签名并调用它。

#### 函数定义（Function Definition）

​	函数定义提供了函数的具体实现。它包括函数的返回类型、名称、参数列表（包括参数名）和包围函数体的大括号。在以下情况中，你需要函数的定义：

1. **在函数被调用时至少存在一次定义**：当编译器遇到函数调用时，它需要能够链接到函数的定义，否则会在链接时期报错，因为没有函数的实现。
2. **如果项目中只使用一次该函数，并且是在其定义之后调用的**：在这种情况下，你可以不用先声明函数，直接在使用前定义函数。
3. **内联函数**：对于小型函数，特别是在C++中，你可能希望将函数定义为内联的，这时通常在头文件中直接提供函数的定义。

​	总结来说，当你在代码中的某个点调用一个函数，而在那个点该函数还未定义时，你需要函数声明。如果函数的定义在它被调用的同一个文件中，并且定义在调用之前，那么你不需要单独的声明。在实际的多文件项目中，一般会把所有函数声明放在头文件中，并在源文件中提供定义。这样，任何需要这些函数的文件只需包含相应的头文件即可。



### (4).函数的嵌套调用

​	在C语言中，函数不能被嵌套定义；所有函数都是在同一级别上定义的，彼此独立。C语言的设计不支持在一个函数内部定义另一个函数，也就是说，C语言不支持函数嵌套定义。所有的函数定义都是全局的，彼此平行，且在任何地方都不能定义在另一个函数的内部。这是C语言与一些其他支持函数嵌套定义的语言（如JavaScript）的不同之处。在C语言中，你可以在一个函数内部调用另一个函数，但不能在其中定义新的函数。

​	函数的嵌套调用指的是从一个函数中调用另一个函数。这种调用可以是直接的，也就是在一个函数的执行体中调用另一个函数；或者间接的，即一个函数调用另一个函数，那个函数又调用第三个函数，依此类推。嵌套调用允许实现复杂的逻辑和算法，同时保持代码的模块化和可读性。

- **直接嵌套调用**：在一个函数内部直接调用另一个函数。

    ```c
    void functionA() {
        // Do something
    }
    
    void functionB() {
        functionA(); // 直接嵌套调用functionA
        // Do something else
    }
    ```

- **间接嵌套调用**：一个函数调用另一个函数，那个函数再调用第三个函数。

    ```c
    void functionA() {
        // Do something
    }
    
    void functionB() {
        functionA(); // functionB间接地通过functionC嵌套调用functionA
    }
    
    void functionC() {
        functionB();
        // Do something else
    }
    ```

​	嵌套调用提高了代码的复用性和组织性，但也需要注意避免过深的嵌套调用，因为这可能导致理解和维护的复杂度增加，特别是在处理递归调用时需要格外小心，以避免无限递归和栈溢出错误。

## 函数递归调用

### 1.函数递归调用的定义

​	函数递归调用是指一个函数直接或间接地调用自身的过程。在直接递归中，函数体内包含了一个直接调用自身的语句；在间接递归中，函数A调用函数B，函数B调用函数C，...，最后一个函数调用函数A。

​	当无限递归调用一个函数且没有出口时，会发现等待一会儿之后就会出现报错、执行崩溃或者程序退出的现象，无论是哪种结果，根本原因是系统的资源（内存）耗尽了，这是因为不断无限次地调用函数自身所导致。很容易想象， 调用函数是要占内存的，每多调用一次函数，系统的内存就要多占用一些，当函数调用完成，从函数中返回时，调用该函数时所占用的内存才能被系统释放掉。

​	在函数调用过程中，不仅是局部变量的内存会在函数执行完成之后才释放，可能还会存在函数参数需要临时保存，一些函数调用关系也要记录，这样函数调用返回的时候才知道返回到哪个函数里。对于函数嵌套调用来讲，只需要记住，系 统会给函数调用分配一些内存来保存提到的这些信息（局部变量、函数参数、函数调用关系等），但分配的内存大小是固定和有限的，一旦超过这个内存大小，程序执行就会出现崩溃或者异常退出的情况。

​	在递归调用中，函数的局部变量和参数在每一次递归调用时都会创建新的副本。递归调用必须有一个基案，即一个明确的条件来终止递归，否则会导致无限递归。递归函数在执行时，会不断地把新的调用实例压入调用栈，每一层调用都会消耗栈空间，如果递归层次过深，可能会造成栈溢出。

​	递归调用就是一个函数在它的函数体内部调用它自身。执行递归函数将反复调用其自身，每调用一次就进入新的一层，递归函数必须有结束条件（递归调用的出口），从而引出下一个话题：递归调用的出口。

### 2.递归调用的出口

​	递归的出口，也称为基案（base case），是递归函数中非常重要的部分，它定义了递归调用何时停止。递归出口是递归函数中一个不再自我调用的条件语句，确保递归调用最终能够终止，避免无限循环和潜在的栈溢出错误。

​	举例：

```c
#include <stdio.h>

// 递归函数来计算n的阶乘
unsigned long long factorial(int n) {
    // 递归出口：如果n等于0，则阶乘为1
    if (n == 0) {
        return 1;
    } else {
        // 递归调用：n不为0时，n的阶乘为n乘以(n-1)的阶乘
        return n * factorial(n - 1);
    }
}

int main() {
    int number = 5;
    unsigned long long result;

    // 调用递归函数
    result = factorial(number);

    // 输出结果
    printf("Factorial of %d is %llu\n", number, result);

    return 0;
}

```

​	在这个例子中，函数`factorial`通过递归调用自身来计算一个数的阶乘。递归出口是检查`n`是否为`0`，因为`0`的阶乘被定义为`1`。如果`n`不为`0`，函数就会继续递归调用自己，每次都将`n`的值减`1`，直到`n`为`0`，然后所有的调用开始依次返回其结果。**要使递归能够结束，必须在函数的递归调用之前设置一个退出条件。**

### 3.递归的优缺点及是否必须用递归

**优点**：

1. **简化代码**：对于某些问题，递归提供了一种简洁清晰的解决方案，可以用几行代码表达复杂的逻辑。
2. **直观**：对于树形或分治策略的问题，递归方法可以直观地表达问题的本质，如快速排序和归并排序。

**缺点**：

1. **效率低下**：每次函数调用都会增加新的层级到调用栈上，这可能导致大量的内存使用，并且有栈溢出的风险。
2. **性能问题**：递归可能涉及大量的重复计算，特别是没有正确使用缓存（memoization）或者动态规划技术的情况下。
3. **调试困难**：由于调用栈较深，调试递归函数可能比迭代解决方案更加困难。

**是否必须用递归**

​	并非所有问题都必须使用递归来解决。很多使用递归的问题也可以用迭代的方法来实现。选择递归或迭代取决于特定问题的性质、易读性、效率以及程序员的偏好。有时迭代方法更有效，特别是当涉及到大量数据时。

### 4.递归的实际运用简介

递归在许多算法和数据结构中都有运用，尤其是那些与自然递归结构相关的问题，例如：

- **算法**：快速排序、归并排序、二叉树遍历（前序、中序、后序）、图的深度优先搜索（DFS）。
- **数据结构**：在像二叉搜索树、堆、trie等树形结构的操作中经常用到递归。
- **数学问题**：计算阶乘、斐波那契数列、汉诺塔问题等。

​	递归方法有时比迭代方法更易于理解和实现，尤其是当解决方案直接映射到递归过程时。然而，也必须考虑到性能和资源的限制，有时需要将递归重写为迭代形式以优化性能和内存使用。

### 5.递归和迭代的区别

递归和迭代是解决问题的两种基本方法，它们在结构和性能方面都有不同的特点：

#### 递归（Recursion）：

1. **定义**：递归是一个函数直接或间接地调用自身的过程。
2. **调用栈**：每次函数调用自身，都会在调用栈上增加一个新的层次，每个层次都有自己的局部变量和参数的副本。
3. **出口条件**：必须有一个或多个基案（递归出口），当满足这些条件时递归才能停止。
4. **内存占用**：递归可能会消耗大量内存，因为每次函数调用都需要保存状态。
5. **易读性**：递归可以使得某些算法的实现更加简洁和易于理解，尤其是那些本质上就是递归的问题，如树的遍历。
6. **效率问题**：如果递归过深，可能会导致栈溢出。并且，递归可能会有重复计算的问题，除非使用了缓存（例如，动态规划或memoization）。

#### 迭代（Iteration）：

1. **定义**：迭代是使用循环结构来重复执行代码直到满足某个条件为止。
2. **内存占用**：迭代通常只需要少量的内存，因为它不需要调用栈来保存多个函数调用的状态。
3. **效率**：迭代往往在性能上更优，特别是在处理大量数据时，因为它避免了递归的大量内存消耗和潜在的栈溢出问题。
4. **易读性**：迭代可能在表示某些递归逻辑时不如递归直观，尤其是那些自然适合递归描述的问题。
5. **控制结构**：迭代使用循环结构（如`for`、`while`循环），必须手动控制循环的开始和结束，以及循环变量的更新。

**递归与迭代的选择**：

- 如果问题的定义是自然递归的，递归可能是一个更直接的解决方案。
- 如果对内存使用和性能有严格的要求，特别是当问题规模很大时，迭代可能更合适。
- 递归的代码通常更简洁，但如果递归逻辑不当或者深度太深，可能会导致性能问题和栈溢出错误。
- 迭代通常在硬件上更为高效，因为现代计算机的CPU和内存管理都是为迭代结构优化的。

​	在某些情况下，可以将递归算法转换为迭代算法，尤其是利用栈来模拟递归调用的方式，或者使用尾递归优化来减少调用栈的占用。



## 数组作为函数参数

### 数组元素作为函数实参

​	当数组的单个元素作为函数实参传递时，它们就像任何其他变量一样按值传递。这意味着函数接收的是元素的一个副本，对副本的修改不会影响原始数组中的元素。

**例子**：

```c
#include <stdio.h>

void printValue(int num) {
    printf("Value: %d\n", num);
}

int main() {
    int array[] = {1, 2, 3, 4, 5};
    printValue(array[1]); // 传递数组的第二个元素
    return 0;
}
```

​	在这个例子中，`printValue`函数只会打印出`2`，这是数组的第二个元素的值。

### 数组名作为函数实参

​	数组名作为函数实参传递时，实际上传递的是数组首元素的地址，也就是数组的指针。在函数内部，我们可以通过指针访问整个数组的元素。因此，可以说数组是“按引用”传递的，因为函数内部对数组内容的任何修改都会反映到原始数组上。

​	换个说法：将数组名作为函数参数时，就不是“值传递”的概念 了，不再是单向传递，而是把实参数组的开始地址（首地址）传递给了形参，这就相当于实参和形参指向（代表）了同一段内存单元，这其实叫地址传递。也就是说，形参数组中各个元素的值如果发生了改变，就等价于实参数组中元素的值发生了相应的改变。这一点是与普通变量作为函数参 数明显不同的地方。

**例子**：

```c
#include <stdio.h>

void printArray(int arr[], int size) {
    for(int i = 0; i < size; ++i) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main() {
    int array[] = {1, 2, 3, 4, 5};
    printArray(array, 5); // 传递数组名和数组大小
    return 0;
}
```

​	在这个例子中，`printArray`函数会打印出整个数组的内容。

​	**总结：**

1. **数组名作为实参和形参**：当你将一个数组名作为实参传递给函数时，对应的形参通常也应该是数组类型。这是因为在C语言中，数组名在传递给函数时会退化为指向其首元素的指针。
2. **类型一致性**：传递给函数的实参数组和函数中定义的形参数组必须具有相同的数据类型。例如，如果实参数组是整型(`int`)，那么形参数组也应该是整型。不一致的类型可能会导致编译错误或运行时错误。
3. **形参数组大小**：在函数定义中，形参数组的大小可以省略，这是因为C语言的函数在处理数组参数时不会检查数组的实际大小。形参只是一个指针，它接收实参数组首元素的地址。形参的大小即便被指定，也不会影响到实际传递的数组大小，且函数内部处理时应当谨慎，避免超出实参数组界限的访问，否则可能会导致未定义行为，包括程序的崩溃。

例如，可以这样声明和调用一个函数：

```c
void processArray(int arr[], int size); // 形参大小未指定，arr被视为int型指针

int main() {
    int myArray[10];
    processArray(myArray, 10); // 实参数组首地址和大小传递给函数
    return 0;
}
```

​	在这个例子中，`processArray`函数不需要知道`arr`的大小，因为它通过单独的`size`参数接收。这种方式在处理数组时给予了函数更大的灵活性和通用性。然而，函数内部应确保不会访问到`arr`指针之外的内存区域，以避免运行时错误。

### 用多维数组作为函数实参

​	传递多维数组作为函数实参时，通常需要在函数定义中指定除了第一维之外的其他所有维度的大小。第一维是可以省略的，因为它表示的是数组的首指针。

**例子**：

```c
#include <stdio.h>

#define ROWS 3
#define COLS 4

void print2DArray(int arr[][COLS], int rows) {
    for(int i = 0; i < rows; ++i) {
        for(int j = 0; j < COLS; ++j) {
            printf("%d ", arr[i][j]);
        }
        printf("\n");
    }
}

int main() {
    int array[ROWS][COLS] = {
        {1, 2, 3, 4},
        {5, 6, 7, 8},
        {9, 10, 11, 12}
    };
    print2DArray(array, ROWS); // 传递二维数组和行数
    return 0;
}
```

​	在这个例子中，`print2DArray`函数会打印出一个二维数组的内容。

### 总结

​	当数组的单个元素作为函数的实参传递时，它是通过值传递的，而不是指针传递。这意味着函数接收的是那个元素值的副本，这个副本与数组本身的元素是独立的，对这个副本的任何修改都不会影响到原数组中的那个元素。只有当整个数组名作为实参传递给函数时，传递的才是一个指向数组首元素的指针，这种情况下，在函数内部对数组的修改将会影响到原数组。对于多维数组作为参数传递给函数，需要在函数声明中指定除第一维度之外的其他所有维度的大小，这是因为编译器需要这些信息来确定数组的内存布局。然而，第一维度仍然可以省略，因为它是通过指针传递的。



## 局部变量和全局变量

### 1.局部变量

局部变量是在函数内部或者一个代码块内部(也叫做复合语句)定义的变量。它们只在定义它们的函数或代码块中可见，并且它们的生命周期仅限于该函数或代码块的执行期间。

**特点**：

- **作用域**：局部变量只能在定义它们的函数或代码块内部访问。
- **生命周期**：当函数调用时局部变量被创建，函数调用结束时销毁。
- **内存分配**：通常在栈上分配内存。
- **初始化**：如果未初始化，其值是未定义的（在某些语言中）。

**使用场景**：

- 用于函数内的计算，不需要在函数调用之间保留值。
- 当你希望变量不影响程序的其他部分时。

**例子**：

```c
void myFunction() {
    int localVar = 10; // 局部变量，仅在myFunction内部可见
}
```

**说明**：

1. **函数内定义的变量作用域限定**：在`main`函数或任何其他函数中定义的变量（如`m`、`n`、`k`）只在该函数内部有效。这意味着它们是局部变量，只存在于定义它们的函数的生命周期内。因此，如果需要在`main`函数和其他函数（如`func1`函数）之间共享数据，必须通过参数传递的方式。
2. **函数间变量名独立性**：不同的函数可以独立地使用相同的变量名而互不影响。比如，在`func1`函数中定义的`m`、`n`、`k`变量与`main`函数中定义的同名变量是完全独立的，它们占用不同的内存空间，函数间不会相互干扰。这是因为每个函数定义了自己的局部作用域，局部变量的作用域限定在这个作用域内。
3. **形参的局部性**：函数的形式参数（如`func1`中的`tmpvalue`）也被视为局部变量，它们在函数的整个执行过程中都是有效的，但是在函数之外是不可访问的。形参在函数调用时被初始化为传递给函数的实际参数的值，且只在该函数体内部有意义。

​	总结来说，局部变量和形式参数的作用域被限制在定义它们的函数内部，不同函数内部即使使用相同的变量名也不会相互影响。这种作用域规则有助于保持变量的封装性和独立性，简化程序的理解和维护。在函数间共享数据必须通过参数传递，强化了数据封装和函数独立性的编程范式。



### 2.全局变量

​	全局变量是在函数外部定义的变量，它们在整个程序文件，甚至跨文件（通过`extern`关键字）中都是可见的。

**特点**：

- **作用域**：全局变量在定义它们的整个程序文件中都是可见的，可以通过`extern`关键字在其他文件中访问。
- **生命周期**：从程序开始执行时创建，直到程序结束时销毁。
- **内存分配**：在静态存储区域分配内存，有时称为全局存储区。
- **初始化**：如果未显式初始化，它们通常会被自动初始化为0（对于基本数据类型）。

**使用场景**：

- 需要在多个函数之间共享数据时。
- 存储应用程序在其整个生命周期内需要的持久化数据。

**例子**：

```c
int globalVar = 20; // 全局变量，可在整个程序文件中访问

void myFunction() {
    globalVar = 30; // 修改全局变量
}
```

​	全局变量的使用应该谨慎，因为它们会打破函数的封装性，并且容易引起不同函数间的依赖和冲突，增加程序的复杂性和调试难度。全局变量会增加程序的状态管理复杂性，可能导致由于不同部分的程序不正确地改变了这些全局状态而引发的错误。

**优缺点：**

​	全局变量是在整个程序中都可访问的变量，它们在程序的任何位置都可以被读取和修改。虽然全局变量在某些情况下可以简化编程，但它们也带来了潜在的风险和缺点。以下是全局变量的一些优缺点：

**优点**

1. **易于访问**：全局变量可以在程序的任何地方被访问，无需通过参数传递。
2. **数据共享**：全局变量提供了一种在程序不同部分之间共享数据的简单方式，尤其是对于共享配置或状态信息很有用。
3. **减少参数传递**：当多个函数需要访问相同的数据时，使用全局变量可以减少需要传递的参数数量，简化函数调用。

**缺点**

1. **维护难度**：全局变量使得程序状态变得难以追踪，因为任何部分的代码都可能修改它们，这会增加调试和维护的难度。
2. **命名冲突**：在大型项目中，全局命名空间很容易变得拥挤，全局变量可能会与其他全局标识符发生命名冲突。
3. **限制模块化**：全局变量破坏了代码的封装性和模块化，因为它们允许函数跨越其定义的作用域外进行交互。
4. **并发问题**：在多线程环境中，全局变量需要额外的同步机制来防止并发访问时的数据冲突，这可能导致性能下降和复杂性增加。
5. **测试困难**：全局变量使得单元测试更加困难，因为测试需要确保全局变量在每次测试开始时都处于一致的状态。

**说明**

全局变量和`extern`关键字

1. **全局变量定义**：全局变量（或外部变量）是在所有函数外部定义的变量，整个程序中只能定义一次。定义全局变量时，会为其分配内存，并且可以在定义时初始化它的值。
2. **`extern`关键字使用**：如果需要在某个函数中使用另一个位置定义的全局变量，可以在该函数之前(放到头文件中然后包含此头文件或者直接写在函数之前。注意 "直接写在函数之前" 是指的是放到函数的定义之前(不是指函数声明之前)，在函数定义之前使用`extern`可以确保在该函数及其他函数中可以访问该外部变量。)或内部使用`extern`关键字进行外部变量声明。这个声明告诉编译器，所引用的变量已在其他地方定义，不需要再次分配内存，也不允许在声明时初始化变量。
3. **全局变量声明**：尽管通常把全局变量的`extern`声明放在所有函数之外的位置，但理论上也可以在每个需要访问该变量的函数内部进行声明。这种做法虽然合法，但不常见，因为它可能会影响代码的可读性。示例：

```c
void myFunction() {
    extern int g_var;  // 在函数内部声明外部变量
    printf("%d\n", g_var);
}
```

全局变量和局部变量的作用域

1. **作用域覆盖**：在同一个源文件中，如果局部变量和全局变量同名，则在该局部变量的作用范围内，全局变量将被局部变量“覆盖”。这意味着局部变量的操作不会影响到同名的全局变量。

跨文件使用全局变量

1. **多文件项目中的全局变量**：在包含多个源文件的项目中，如果某个源文件定义的全局变量需要在其他源文件中使用，可以在这些其他文件中通过`extern`关键字声明这个全局变量。这样做可以跨文件共享全局变量。

​	总的来说，`extern`关键字在C和C++编程中是用来声明外部变量的，这种机制允许跨文件访问全局变量，同时保证了全局变量的唯一定义。正确地使用全局变量和`extern`关键字可以在保持代码组织和模块化的同时，实现不同程序组件间的数据共享。然而，过度依赖全局变量可能会导致代码维护困难，因此应谨慎使用，并考虑其他如传参或使用模块化设计来实现数据共享。

**总结**

​	虽然全局变量在某些情况下可以提供方便，但它们的使用应当谨慎，尽量避免除非确实需要。为了保持代码的可读性、可维护性和可测试性，推荐使用局部变量、参数传递和封装在类或模块内的数据成员来代替全局变量。当确实需要使用全局变量时，应确保对它们的访问是可控的，并且在多线程环境下适当同步。

### 3.建议

​	通常建议尽量避免使用全局变量，除非确实需要，因为它们会影响代码的可测试性、可维护性和可理解性。相比之下，局部变量是限制在较小作用域内，更容易管理和维护。在需要在不同函数或模块之间共享状态时，考虑使用函数参数、返回值或者封装状态的数据结构。



## 变量的存储和引用与内部和外部函数

### 1.变量的存储类别

1. 从变量存在的时间（生存期）角度来看，变量可划分为“静态存储变量”和“动态存储变量”，这引出了“静态存储方式”和“动态存储方式”两个概念：

    1. **静态存储方式**：是指程序运行期间为变量分配固定存储空间的方式。变量在程序启动时被创建，在程序终止时被销毁。全局变量和静态局部变量采用静态存储方式。
    2. **动态存储方式**：指在程序运行期间根据需要动态分配和回收存储空间的方式。这通常涉及到局部变量和函数调用栈，局部变量包括函数的形参和在函数内定义的变量。这些变量在函数调用时创建，在函数调用结束时销毁。

    综合上述内容，可以根据C语言中的存储类别对变量进行详细总结：

    自动存储类别（auto）

    - 局部变量默认是自动存储类别。
    - 存储在栈上。
    - 生命周期限定于代码块执行期间。
    - 适用于函数内部需要临时存储的数据。

    外部存储类别（extern）

    - 用于全局变量，它们定义在所有函数之外。
    - 存储在静态存储区。
    - 生命周期为程序的整个运行期间。
    - 可以被程序中的所有函数访问。
    - 可以在不同文件之间共享。

    静态存储类别（static）

    - 可用于局部变量和全局变量。
    - 局部变量：在函数的多次调用之间保持其值。
    - 全局变量：作用域限制在声明它们的文件内。
    - 存储在静态存储区，不在栈上。
    - 有助于维持数据的持久化，同时限制了变量的作用域。

    寄存器存储类别（register）

    - 提示编译器尽可能将变量存储在寄存器中。
    - 目的是为了让变量的访问速度更快。
    - 实际上，编译器可能会忽略这个提示，尤其是当寄存器数量有限时。
    - 通常用于循环中频繁访问的变量。

    了解这些存储类别对于编写高效且易于维护的C程序至关重要。静态存储变量提供了在程序的生命周期内持续存在的数据，而动态存储变量则为函数的局部运算提供了灵活性。适当使用这些存储类别有助于优化程序性能和内存使用，同时保持代码的可读性和逻辑清晰。



### 2.局部变量的存储方式

**传统情形：动态存储局部变量**

局部变量通常是自动存储类别（`auto`），也就是说，这些变量的存储空间是动态分配的，具体表现为：

- **存储位置**：它们存储在栈上，这是一种先进后出的数据结构。
- **生命周期**：在函数调用时创建，在函数返回时销毁。
- **管理方式**：存储空间的分配和释放由系统自动处理。
- **作用域**：局部变量的作用域限定在声明它们的函数或代码块内。

**特殊情形：静态存储局部变量**

在某些情况下，程序员可能希望局部变量的生命周期跨越多个函数调用。为此，C语言提供了“静态”存储类别（`static`），这种情况下的局部变量表现为：

- **存储位置**：静态局部变量存储在静态存储区，这与全局变量相似。
- **生命周期**：从程序开始运行时初始化直到程序结束时才被销毁。
- **初始化特性**：静态局部变量在编译时被初始化一次，之后每次函数调用仅保留上次调用结束时的值。
- **默认值**：如果静态局部变量在定义时没有赋值，则会被自动初始化为0。
- **函数内可见**：虽然它们的生命周期延续到程序结束，但只能在定义它们的函数内被访问。

**实例和推论**

通过观察函数内部的普通局部变量和静态局部变量的行为差异，我们可以得出以下几点：

- **局部静态变量与普通局部变量的存储和生命周期有显著差异**。普通局部变量的生存期和作用域严格限定于函数调用期间，而局部静态变量则在多次函数调用间保持状态。
- **局部静态变量应该谨慎使用**，因为它们的长期存在可能导致程序状态不易追踪，减少代码的可预测性和可读性。特别是在多次调用含有局部静态变量的函数时，它们的当前状态可能不清晰，容易引起混淆。
- **局部静态变量不应被过度使用**。尽管它们对于保持状态（如计数器或缓存某种计算结果）很有用，但如果可以通过其他方法（如全局变量、传参、返回值或使用更高级的数据结构）来保持函数的纯净性和预测性，则应优先考虑这些方法。

​	综上所述，局部变量的存储方式影响着它们的作用域、生命周期和程序的整体结构。正确地选择和使用局部变量的存储方式对于编写高效、可维护且容易理解的程序至关重要。

### 3.全局变量跨文件引用

​	全局变量可以在定义它的文件之外通过`extern`关键字引用。在一个文件中定义全局变量时，其他文件可以通过在变量声明前加上`extern`关键字来访问它，这不会创建变量的新实例，而是引用了原始位置的变量。

**全局变量跨文件引用**

- 全局变量可通过`extern`关键字在不同的源文件中引用。
- 全局变量在程序的一个源文件中定义，通过在其他源文件前使用`extern`声明，可以让其他文件访问同一全局变量，而无需重新分配内存。

**避免重复定义**

- 全局变量在所有文件中只能有一次定义，尽管可以在多个地方声明（使用`extern`）。
- 如果多个文件中有相同名称的全局变量且未使用`static`关键字，会导致链接错误。

**限制可见性**

- 使用`static`关键字可以限制全局变量的作用域，使之只在定义它的源文件中可见，防止跨文件引用。
- 这有助于避免全局命名空间污染，并提高代码的封装性。



全局变量定义和引用

1. **全局变量定义**：
    - 全局变量通常在源文件外部定义，其作用域是从定义点开始到文件末尾。
    - 定义全局变量时，可以初始化，且在整个程序执行期间持续存在。
2. **跨文件引用**：
    - 全局变量定义在一个源文件后，可以在其他源文件中使用`extern`关键字声明后引用。
    - 使用`extern`声明全局变量时，告诉编译器该变量在另一个源文件中已经定义，避免重新分配内存。
    - `extern`声明应放在源文件的开始部分，确保声明后的所有代码都可以识别该变量。

**Visual Studio项目和全局变量**

- Visual Studio项目可以包含多个`.c`或`.cpp`源文件。
- 通过编译和链接这些文件，生成Windows下的`.exe`文件或Linux下的可执行文件。
- 当新的源文件加入到项目时，例如通过复制现有文件并重命名，必须确保整个项目中只有一个`main`函数。

**全局变量的作用域和存储**

- 通过在定义全局变量时加`static`关键字，可以限制变量的作用域，使其仅在定义文件内可见，避免其他文件的直接访问。
- 如果两个源文件中定义了同名的全局变量且没有使用`static`，编译器会报告重定义错误。

**extern关键字使用注意事项**

- 将`extern`放在源文件开头是为了确保全局变量在文件中的所有位置都可用。
- 需要谨慎使用全局变量，因为在一个文件中对全局变量的更改会影响到其他文件中使用该变量的函数。

**实践中的考虑**

- 虽然跨文件引用全局变量是一种方便的做法，但要注意全局变量可能导致的维护问题和潜在的错误。
- 应尽量减少全局变量的使用，通过参数传递、返回值或使用其他数据结构来共享数据，以提高程序的模块化和可维护性。
- 当确实需要跨文件共享全局变量时，使用`extern`声明可以有效管理这些变量。

总之，合理的组织全局变量和清晰的使用`extern`关键字，是确保多文件项目代码清晰、可维护性高的关键。同时，限制全局变量的作用域，有助于避免命名冲突和不必要的错误。在实际开发中，这些原则和实践有助于保持代码质量和项目的健康。



### 4.函数的跨文件调用

​	与全局变量类似，函数也可以在定义它的文件之外被调用。如果函数在一个文件中定义，则其他文件可以直接调用该函数（假设有正确的函数声明）。通常，函数声明会放在头文件（`.h`文件）中，并在需要调用函数的文件中包含这个头文件。

​	函数的跨文件调用是编程中常见的情形，尤其是在大型项目中，不同的功能模块可能被分散在不同的源文件中。以下是关于函数跨文件调用的全面详细总结：

**函数的可见性**

1. **内部函数（Static Functions）**：

    - 通过在函数声明前加上`static`关键字来定义内部函数。

    - 内部函数仅在其定义所在的源文件中可见，对其他文件不可见。

    - 这意味着即使不同的源文件中有相同名称的内部函数，它们也不会相互干扰，因为它们的作用域限制在各自的文件内。

    - 使用内部函数有助于避免命名冲突，并增强了模块的封装性。

        ​	即使两个内部函数的返回值类型、函数名和形参列表完全一致，只要它们分别用`static`关键字在不同的源文件中声明和定义，它们也不会相互干扰。在每个源文件的编译过程中，编译器只处理在当前文件中定义的静态函数，而不考虑其他文件中的同名函数。这样做的结果是，每个源文件都有一个独立的函数实现，这些函数互不可见。

        ​	这允许开发者在不同的源文件中定义相同名称的静态函数，而不会导致链接错误或名称冲突。这种技术对于隐藏实现细节和增加代码模块化非常有用。然而，这种方式在多人合作的大型项目中可能会导致可维护性的问题，因为多个同名的函数可能会让人混淆。因此，即便是可以做到，合理的命名和代码组织仍然是编写可维护代码的最佳实践。

2. **外部函数（External Functions）**：

    - 默认情况下，没有`static`修饰的函数是外部函数。
    - 外部函数可以在不同的源文件之间进行调用，前提是正确地声明了这些函数。
    - 在调用外部函数的文件中，需要提供函数的声明，通常这个声明会放在一个头文件（`.h`文件）中。

**跨文件调用的实现**

- 跨文件调用通常需要函数的原型声明，在调用函数之前，源文件中需要包含有函数声明的头文件。
- 一种常见的做法是将所有外部函数的声明放在一个或多个头文件中，并在每个需要调用这些函数的源文件的开头通过`#include`指令包含这些头文件。

**头文件的作用**

- 头文件提供了一个中央位置来管理函数声明，常量定义，宏定义，以及其他可供多个文件共享的元素。
- 当多个源文件依赖于相同的函数声明时，头文件确保了一致性和可维护性。
- 通过使用头文件，当函数声明改变时，只需要更新头文件，而不必手动修改每个源文件。

**开发技巧**

- 开发中，为了方便管理和减少错误，通常会将外部函数的声明放到一个或多个头文件中。
- 外部函数的定义放在源文件（`.cpp`或`.c`）中，而声明放在头文件（`.h`）中。
- 在需要使用这些函数的源文件顶部包含相应的头文件，就可以调用在其他源文件中定义的函数。

**总结**

​	函数的跨文件调用允许开发者组织和模块化代码，但这也要求开发者注意函数声明和定义的管理。正确使用`static`和`extern`（对于函数，默认是extern）关键字以及头文件可以帮助开发者维护大型项目的清晰度和结构性，同时减少潜在的错误。这种做法支持了代码复用、降低了耦合度，并促进了团队合作。

### 5.static关键字用法总结

​	`static`关键字在C语言中有两个主要用途：

1. **静态局部变量**：在函数内部声明的`static`变量只初始化一次，其值在函数调用之间保持不变。这类变量仍然是局部的，但它们的生命周期延伸至整个程序执行期。是对应保存在静态存储区的。
2. **静态全局变量和函数**：在函数或全局变量声明前使用`static`关键字使得它们只能在定义它们的文件中被访问或调用，对其他文件不可见。这有助于限制变量或函数的作用域，增强封装性。

​	`static`关键字的使用可以有效地控制变量和函数的作用域与生命周期，有助于提高程序的模块化和封装性。

​	`static`关键字在C语言中是一个非常重要的修饰符，用于控制变量和函数的存储周期和作用域。以下是`static`关键字的详细用法总结：

**静态局部变量**

1. **定义**：
    - 当`static`用在函数内部的局部变量前，它修改了变量的存储周期，使得变量跨函数调用保持其值。
2. **生命周期**：
    - 这些变量在程序执行开始时初始化一次，并且只在程序结束时销毁，而不是在函数结束时。
3. **初始化**：
    - 如果静态局部变量在声明时未赋予初始值，它会被自动初始化为0。
4. **用途**：
    - 适用于需要保持函数间状态的情况，如计数器或函数内的缓存。

**静态全局变量**

1. **定义**：
    - 在全局变量前使用`static`，该变量的作用域被限制在定义它的文件内，对其他文件中的代码不可见。
2. **生命周期**：
    - 与普通全局变量相同，其生命周期为整个程序的执行期间。
3. **用途**：
    - 当不希望全局变量在文件之外被访问时使用，这有助于减少命名空间污染和避免外部文件的不必要依赖。

**静态函数（内部函数）**

1. **定义**：
    - 在函数的定义之前加上`static`关键字，该函数变为内部函数，也即只在其定义的源文件内可见。
2. **用途**：
    - 用于隐藏函数实现，防止函数被其他文件调用，增加了代码的封装性和模块化。

**使用建议和注意事项**

- **减少全局变量**：虽然`static`可以限制全局变量的作用域，但最好的做法是尽量减少全局变量的使用，通过函数参数和返回值来传递数据。
- **限制函数的可见性**：当不需要在其他文件中调用某个函数时，使用`static`来定义内部函数。
- **状态保持**：当需要在函数调用之间保持信息时，静态局部变量是一个好选择，但要注意这可能导致函数的副作用，这在多线程环境中尤其重要。
- **初始化一次**：静态局部变量在程序的生命周期中只初始化一次，因此它们适用于需要执行一次性初始化的场合。

​	总之，`static`关键字是C语言提供的一种强大工具，它可以帮助程序员更好地封装代码、管理内存和控制变量作用域。正确地使用`static`能够提升代码质量，降低错误率，提高程序的可维护性和清晰度。

**拓展**1

​	`static`变量，无论是全局的还是在函数内部声明的，确实在程序启动时就已经分配了存储空间，这是在编译和链接的过程中完成的。这个空间通常位于程序的数据段中，这与堆或栈空间不同。然而，`static`变量的**初始化**（即赋予初始值）通常是在程序执行流程第一次到达该变量声明的地点时进行的，而不是在编译期。

​	例如，如果一个`static`变量在一个函数内部被初始化，那么这个初始化动作只会在第一次调用该函数时执行一次，随后的函数调用不会重新初始化这个变量。这与变量的存储空间已经预留好不冲突，但初始化（赋值）的动作是在运行时第一次访问到该声明时进行的。这是因为`static`变量可以被初始化为运行时才确定的值（如函数调用的结果或其他运行时表达式的值），如果这些初始化在编译时就完成了，那么就不能反映运行时的动态结果。

​	**总结一下，`static`变量的内存地址分配发生在编译和链接的过程中**(

- **编译时**：编译器处理源代码，生成目标代码。在这个阶段，编译器确实会识别`static`变量，并对其进行处理，但它只是生成了相应的符号和可能的初始值（对于初始化为常量的`static`变量）。
- **链接时**：链接器将多个目标代码文件和库合并成一个可执行文件。在这个阶段，`static`变量被分配到程序的数据段中。链接器确定了每个`static`变量的内存地址，并处理了所有关于这些变量的引用。

)**，而对应的物理内存空间通常在程序加载到内存时被分配。静态全局变量在程序启动前初始化(通常在程序启动前（即主函数`main`执行前）完成初始化，这是因为它们的初始值需要在程序开始执行前就设定好)，而静态局部变量的实际初始化（即初次赋值）是在程序运行时首次执行到该变量声明的位置时完成的。**

**拓展2**

​	全局变量和静态变量在C语言中都扮演着重要的角色，它们在内存分配、初始化时机、默认值和作用域方面有一些区别。以下是它们之间的主要差异：

**1. 存储位置**

- **全局变量**：存储在程序的全局数据区（也称为静态存储区）。这包括程序中定义的所有全局变量和静态变量。
- **静态变量**：无论是静态全局变量还是静态局部变量，都存储在全局数据区。静态全局变量对整个程序可见，而静态局部变量只在定义它的函数内可见。

**2. 内存分配时机**

- **全局变量和静态变量**：全局变量和静态变量的内存地址是在编译和链接时确定的，而它们的物理内存空间通常在程序加载到内存时被分配。

**3. 初始化时机**

- **全局变量**：在程序启动之前，即主函数执行之前就已经完成初始化。
- **静态变量**：
    - 静态全局变量同全局变量，在程序启动之前初始化。
    - 静态局部变量在程序流程第一次达到变量定义的位置时初始化，只初始化一次。

**4. 默认初始化值**

- **全局变量和静态变量**：如果没有显式初始化，它们都会被自动初始化为零。这包括基本类型变量被初始化为0或NULL，数组每个元素都初始化为0或NULL。

**5. 作用域和链接属性**

- 全局变量：
    - 作用域为整个程序，除非使用`static`关键字限定。
    - 可以被程序中的任何函数访问，除非它们被声明为`static`，这使其链接属性变为内部（只在定义它的文件内可见）。
- 静态变量：
    - 静态全局变量的作用域为整个程序，但链接属性是内部的，只在定义它的文件内可见。
    - 静态局部变量的作用域限定在定义它的函数内，但它的生命周期延续到程序的整个执行期间。

​	这些属性决定了全局变量和静态变量的使用场景，全局变量通常用于需要在多个文件或函数间共享的数据，而静态变量（尤其是静态局部变量）用于保持函数内部的状态，或限制变量的作用域仅在单一文件中。

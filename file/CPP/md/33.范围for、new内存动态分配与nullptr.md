# 范围for、new内存动态分配与nullptr

## 1.范围for语句

​	C语言部分学习过了for语句，在C++11中for语句的能力被进一步扩展，引入了范围for语句，用于遍历一个序列。看看如下范例：

```cpp
int v[]{12,13,14,16,18};
// 数组v中每个元素依次放入x并打印x值，相当于把v的每个元素值复制到x中，然后打印
for (auto x : v)
{
    std::cout << x << std::endl;
}

// {}中是一个元素序列，for就是应用于任意的这种元素序列
for (auto x : {11,34,56,21,34,34})
{
    std::cout << x << std::endl;
}
```

​	上面范例中第一个for语句的写法有个缺点，多了一个复制的动作，也就是把数组v中的元素值依次复制（赋值）到了x中，然后循环输出x值。那如何修改一下以避免这种复制动作，提高程序运行效率呢？非常简单，只需要把for这行代码修改成如下即可：

```cpp
for (auto& x : v)// 使用引用的方式，避免数据的复制动作
```

​	一般来讲，一个容器只要其内部支持begin和end成员函数用于返回一个迭代器，能够指向容器的第一个元素和末端元素的后面，这种容器就可以支持范围for语句（容器后面讲）。

## 2.动态内存分配问题(注意两种方式的C++内存分配是如何分配定义的，一定要搞明白)

​	在前面C语言部分学习了内存中供用户使用的存储空间，包括程序代码区、静态存储区、动态存储区。程序执行所需的数据都放在静态存储区和动态存储区。例如，全局变量放在静态存储区，局部变量放在动态存储区。

在C++中，把内存进一步更详细地分成5个区域：

（1）栈。函数内的局部变量一般在这里创建，由编译器自动分配和释放。

（2）堆。由程序员使用malloc/new申请，free/delete释放。malloc/new申请并使用完毕后要及时free/delete以节省系统资源，防止资源耗尽导致程序崩溃。如果程序员忘记free/delete，程序结束时会由操作系统回收这些内存。

3）全局/静态存储区。全局变量和静态变量放这里，程序结束时释放。

（4）常量存储区。存放常量，不允许修改，如用双引号包含起来的字符串。

（5）程序代码区。相当于C语言中的程序代码区。

这5个区域重点关注堆和栈，其他几个区域简单理解即可。堆和栈都相当于C语言部分所说的动态存储区，但用途不同。下面总结一下堆和栈的区别：

（1）栈空间有限（这是系统规定的），使用便捷。例如代码行`int a = 4;`，系统就自动分配了一个4字节给变量a使用。分配速度快，程序员控制不了它的分配和释放。

（2）堆空间是程序员自由决定所分配的内存大小，大小理论上只要不超出实际拥有的物理内存即可，分配速度相对较慢，可以随时用new/malloc分配、free/delete释放，非常灵活。

下面介绍new/malloc与free/delete。

### 1.malloc和free

​	在C语言（不是C++）中，malloc和free是系统提供的函数，成对使用，用于从堆（堆空间）中分配和释放内存。malloc的全称是memoryallocation，翻译成中文含义是“动态内存分配”。一般形式为：

```cpp
void* malloc(int NumBytes);
```

​	说明：malloc向系统申请分配指定NumBytes字节的内存空间。返回类型是`void*`类型。`void*`表示未确定类型的指针。C/C++规定，`void*`类型可以强制转换为任何其他类型的指针。如果分配成功则返回指向被分配内存的指针，如果分配失败则返回空指针`NULL`。分配成功后且当内存不再使用时，应使用`free()`函数将内存释放。

free函数的一般形式为：

```cpp
void free(void* Ptr);
```

​	说明：该函数是将之前用malloc分配的内存空间还给程序或者操作系统，也就是释放先前分配的内存，这样这块内存就被系统回收并在需要的时候由系统自由分配出去再使用。

看看如下范例：

```cpp
int* p = NULL;
p = (int*)malloc(10 * sizeof(int));// 分配了40个字节
// p = static_cast<int*>malloc(10 * sizeof(int));// 这样更为安全
if (p != NULL)
{
    *p = 5;
    std::cout << *p << std::endl;
    free(p);
}
```

再继续看范例：

```cpp
char* point = NULL;
point = (char*)malloc(100 * sizeof(char));// 100字节
if (point != NULL)
{
    strcpy_s(point, 20, "hello world!");
    std::cout << point << std::endl;
    free(p);
}
```

​	上面的strcpy_s看起来有点熟悉，第1部分学习过strcpy函数，但这里多了一个_s，代表的是strcpy函数的安全版本，能够检测所容纳的元素是否越界，如果越界则会停止程序运行并弹出警告窗口。有兴趣的读者可以用搜索引擎学习该函数，类似的函数还有strcat_s等。

再继续看范例：

```cpp
int* p = (int*)malloc(sizeof(int) * 100);// 分配可以放得下100个整数的内存空间
if (p != NULL)
{
    int* q = p;
    *q++ = 1;
    *q++ = 5;
    std::cout << *p << std::endl;// 1
    std::cout << *(p+1) << std::endl;// 5
}
```

### 2.new和delete

​	new和delete是运算符，不是函数。C++中使用new和delete从堆中分配和释放内存，两者成对使用。

​	new有很多用法和特性，因为现在学习的知识点还不多，所以这里简单地提一提用法，深入的用法在后续章节讲解中再逐步深入。

​	首先要理解一点，那就是new/delete做了和malloc/free同样的事情——分配和释放内存，同时，new/delete还做了更多的事情。这里先看一看，new/delete在分配内存方面的用法。new一般使用格式有如下几种：

- 指针变量名 = new 类型标识符;
- 指针变量名 = new 类型标识符(初始值);
- 指针变量名 = new 类型标识符(内存单元个数);

看如下范例：

```cpp
// 开辟一个存放整数的存储空间，返回一个指向该存储空间的地址.将一个int类型的地址给整形指针myint
int* myint = new int;
if (myint != NULL)
{
    *myint = 8;							// *myint代表指针指向的向量
    std::cout << *myint << std::endl;	// 8
    delete myint;						// 释放
}
```

再继续看范例：

```cpp
int* a = new int[100]; // 开辟一个大小为100的整形数组空间
if (a != nullptr)
{
    int *p = a;
    *p++ = 12;
    *p++ = 18;
    std::cout << *a << std::endl;// 12
    std::cout << *(a+1) << std::endl;// 18
    /**
    * new时用了[]，delete时就要用[]，否则回收的内存就是第一个数组元素空间而不是整个数组，[]起了回收整个数组的作用，delete中[]内不用写数组中元素个数，保持空着，系统有办法知道这个数组大小，写了数字也会被系统忽略
    */
    delete[] a;		//释放int数组空间  
}
```

几点说明：

（1）配对使用，有malloc成功必有free，有new成功必有delete。

（2）free/delete不要重复调用，因为free/delete的内存可能被系统立即回收后再利用，再free/delete一次很可能把不是自己的空间释放掉了，导致程序运行出现异常甚至崩溃。

​	后面学习类的时候还会看到很多new的用法。

​	malloc/free与new/delete的区别：

​	new不但分配内存，还会额外做一些初始化工作，后面会学习到，而delete不但释放内存，还会额外做一些清理工作，后面同样会学习到。这就是new/delete这一对比malloc/free这一对多做的事情。所以，在C++中，不要再使用malloc/free，而是使用new/delete。

### 3.nullptr  

​	nullptr是C++11引入的新关键字，代表“空指针”。

​	看看如下范例：

```cpp
char* p = NULL;			// NULL实际为0(是这样吗？待验证)
char* q = nullptr;		// NULL和nullptr非常类似,但是也有略微的差别
int* a = nullptr;		
if (p == nullptr) 		// 条件成立
{
    std::cout << "nullptr" << std::endl;
}
```

​	有资料指出：使用nullptr能够避免在整数和指针之间发生混淆。但这句话说得有点模棱两可。看看下面的演示范例：

```cpp
std::cout << std::typeid(NULL).name() << std::endl;//int 
std::cout << std::typeid(nullptr).name() << std::endl;//std::nullptr_t  
```


​	上面范例中，std::typeid先不深入解释，后面章节会详细学习，这里只理解成“用于取类型”。然后.name()可以打印出类型名，通过结果可以看到，NULL和nullptr两者的类型是不同的。

​	在后面学习函数重载时，因为NULL和nullptr类型不同，所以如果把这两者当函数实参传递到函数中去，则会导致因为实参类型不同而调用不同的重载函数。看看如下范例：

```cpp
void myfunc(void* ptmp)
{
	printf("myfunc(void* ptmp)\n");   
}
void myfunc(int tmpvalue)	//重载函数，函数名相同但参数不同
{
    printf("myfunc(int tmpvalue)\n");
}

int main()
{
    myfunc(NULL);		// 调用void myfunc(int tmpvalue)
    myfunc(nullptr);	// 调用void myfunc(void* ptmp)
    return O;
}
```

上面范例也展示了NULL和nullptr的区别，目前先简单理解着。当然还有其他的区别，不过现在不需要深究太多。给出一些结论：

（1）对于指针的初始化，能用nullptr的全部用nullptr。

（2）以往用到的与指针有关的NULL的场合，能用nullptr取代的全部用nullptr取代。





---------以下为待补充内容---------待办---------

1.四类转换(如static_cast)的原理、区别和联系以及使用场景

2.NULL和nullptr的区别和联系的完整内容
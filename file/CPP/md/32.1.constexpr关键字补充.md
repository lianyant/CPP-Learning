# constexpr关键字补充(要有代码证明)

## constexpr 关键字起什么作用？


​	constexpr 是 C++11 引入的一个关键字，用于指明变量、函数、构造函数等可以在编译时进行计算。使用 constexpr 声明的变量或函数能够提高程序的效率，同时帮助生成更可预测、错误更少的代码。这里详细解释一下 constexpr 的功能和应用场景：

## 对变量的作用

​	当 constexpr 用于变量时，它表明该变量的值在编译时就必须是已知的，这样的变量实际上是一个常量表达式。这通常用于定义程序中的常量数据，如物理常数、配置参数等。

示例：

```cpp
constexpr int max_size = 512; // 编译时常量
constexpr double pi = 3.14159; // 编译时常量
```

## 对函数的作用

当 constexpr 用于函数时，它表明该函数在给定编译时常量作为参数时，能够在编译时执行。这意味着函数必须足够简单，以便编译器可以在编译期完成其求值。这使得 constexpr 函数非常适合用于计算常量表达式，如数学函数、转换函数等。

示例：

```cpp
constexpr int square(int x) {
    return x * x;
}

```

这个函数可以在编译时计算出结果，如用于数组大小或模板参数。

## 对构造函数的作用

从 C++14 开始，constexpr 也可以用于构造函数，使得对象可以在编译时被创建和初始化。这对于想要在编译时初始化常量对象的场合非常有用。

示例：

```cpp
class Point {
public:
    constexpr Point(double x, double y) : x_(x), y_(y) {}

    constexpr double getX() const { return x_; }
    constexpr double getY() const { return y_; }

private:
    double x_, y_;
};

constexpr Point origin(0.0, 0.0); // 编译时对象
```

## 优势和限制

使用 constexpr 的优势在于它提供了保证在编译时进行计算的强大工具，有助于优化性能和增强类型安全。此外，constexpr 能确保涉及的所有计算在编译时完成，从而避免运行时错误和不确定性。

然而，constexpr 函数和构造函数的限制在早期的 C++ 标准中比较多，如 C++11 中不允许使用循环和复杂的分支语句。C++14 和 C++17 对此进行了放宽，允许更复杂的操作。

总之，constexpr 关键字是 C++ 现代化特性中的一部分，它扩展了编译时计算的能力，使得生成的代码更加高效和安全。

## 额外讨论1

### 提问：

对于

```cpp
constexpr int square(int x) {
    return x * x;
}
```

而言，形参是一个编译时常量吗？如果是的话，根据前面说的：当 constexpr 用于函数时，此函数能够在编译时执行。那么这样意味着：

```cpp
constexpr int max_size = 512;
constexpr int max_;
```


都是编译时常量？

### 回答：

​	在函数 constexpr int square(int x) 中，参数 x 本身并不必须是编译时常量。但是，如果你想要在编译时计算该函数的结果，并将该结果用于其他 constexpr 变量或者模板参数，那么传递给 square() 的实参必须是编译时常量。

### 如何理解这个过程：

​	函数定义：当你定义一个 constexpr 函数时，你是在告诉编译器这个函数**可以**在编译时进行计算，只要它的所有输入都是编译时已知的常量。这不意味着函数的所有使用都必须在编译时计算。

### 函数使用：

​	如果函数的调用使用的实参是编译时常量，例如 ：

```cpp
constexpr int max_size = 512; 
constexpr int area = square(max_size);
```

那么 `area` 将在编译时计算，并且其结果也是编译时常量。如果实参不是编译时常量，函数仍然可以在运行时调用和计算，就像普通函数一样(验证下)。

上面的示例：

```cpp
constexpr int max_size = 512;
constexpr int max_ = square(max_size);  // 编译时计算
```

在这个例子中：

max_size 是一个 constexpr 变量，其值在编译时确定。square(max_size) 也在编译时计算，因为它的输入是编译时常量。max_ 因此也是编译时常量，它的值是 square(512) 的结果，即 512 * 512。

### 关键点：

constexpr 函数的能力：这种函数能够在编译时和运行时执行，取决于其输入。这使得 constexpr 函数非常灵活。
编译时与运行时：明确区分编译时常量和运行时变量对于理解 constexpr 的使用非常关键。

总结，constexpr 函数提供了在可能的情况下在编译时计算结果的能力，从而可以用于定义其他编译时常量，也可以用于普通运行时计算。这增加了代码的灵活性和效率。

## 额外讨论2

### 提问：

就是说针对constexpr 而言：
如果是一个对象(静态/局部？)，加上这个关键字之后必定会表明该变量的值在编译时就必须是已知的，这样的变量实际上是一个常量表达式，可以在编译时执行。

而对于函数而言(全局、成员、静态？)，加上这个关键字之后，是否能够在编译时执行取决于给的形参是否是编译时常量，如果是那么就可以在编译时执行，如果不是就不能，对于函数而言，此关键字是可以有此功能但不一定有。对吗？

### 回答：

是的，这样理解是正确的。让我们进一步澄清 constexpr 在对象和函数中的用法及其意义：

### 对于对象（变量）

​	当为一个对象（无论是静态还是局部变量）使用 constexpr 关键字时，你确实是在声明这个对象必须是一个编译时常量。这意味着：其值必须在编译时就已经确定。
​	这个对象本质上是一个常量表达式，可以用在任何需要编译时常量的场合，比如数组的大小、模板参数、其他 constexpr 表达式等。

### 对于函数

​	对于函数来说，constexpr 指明该函数能够在编译时执行，但这只在所有输入参数也都是编译时常量的情况下成立。因此：

​	如果你调用一个 constexpr 函数并且提供了编译时常量作为参数，那么该函数可以在编译时执行，其结果也是一个编译时常量。
​	如果调用该函数的实参不是编译时常量，那么该函数就像普通函数一样在运行时执行。
​	constexpr 函数必须满足一定的条件（尤其是在C++11中，这些限制更为严格），比如不能有任何不确定的行为、不能调用非 constexpr 函数等。

### 应用场景

​	1.静态和局部变量：对于静态和局部变量，使用 constexpr 可以帮助编译器优化代码，同时明确变量的用途是作为编译时常量。
​	2.全局变量：全局 constexpr 变量同样需要在定义时就被初始化，通常用于定义跨多个文件共享的常量。
​	3.成员变量：成员变量可以是 constexpr，通常用于定义类的静态常量数据成员。
​	4.静态和成员函数：静态和成员函数可以声明为 constexpr，用于在对象构造或与对象类型直接相关的计算中提供编译时计算能力。

### 结论

​	constexpr 的引入增加了C++程序的表达能力和执行效率，通过允许更多的计算在编译时完成，减少运行时的开销。对于函数和对象来说，它们确实如你所述：对象必须在编译时确定，而函数则取决于其参数是否为编译时常量。
# cstdio和stdio.h的区别

​	当在C++中使用`printf`和`scanf`函数而没有使用`std::`前缀或`using namespace std;`声明时，很可能是因为你直接包含了C风格的头文件`stdio.h`而不是C++风格的`cstdio`。这种情况下，`printf`和`scanf`以及其他C标准库函数直接位于全局命名空间中，因为`stdio.h`没有将这些函数封装在任何命名空间内。

### 区别：`cstdio` 与 `stdio.h`

- **头文件内容**：
  - **`stdio.h`**：这是C语言的标准输入输出头文件，用于提供输入输出函数如`printf`, `scanf`, `fopen`等。在C++中包含`stdio.h`时，其中定义的所有名称（如`printf`和`scanf`）都位于全局命名空间。
  - **`cstdio`**：这是C++中的对应版本，功能与`stdio.h`相同，但它将所有的名字放入了`std`命名空间中。这意味着，要使用`cstdio`中的函数，你通常需要使用`std::`前缀，例如`std::printf`和`std::scanf`，除非你使用了`using namespace std;`声明。**在C++中，`cstdio` 将所有的C标准I/O库函数放在 `std` 命名空间中，虽然这些函数仍然可以在全局命名空间中访问，但推荐使用 `std::printf()`, `std::scanf()` 等形式来调用这些函数。（确实是这样的,以此句为准。既可以加上std::访问也可以不加std::进行访问。）**

### 使用`cstdio`的优势
​	使用`cstdio`而非`stdio.h`的主要优势是能够保持命名空间的清洁和有序，这有助于避免在大型项目中名字冲突的问题。这也是面向现代C++开发的推荐做法。

### 实际使用
​	在实际的C++项目中，推荐使用`cstdio`并显式地使用`std::`前缀来调用函数，以保持代码的清晰性和一致性。然而，由于历史原因和向后兼容性，直接使用`stdio.h`仍然是可能的，尤其是在那些从C过渡来的项目或者是对性能有极端要求的低级系统编程中。

​	这样的处理方式使得C++具有很高的灵活性，允许开发者根据具体的项目需求和背景来选择最适合的方法。

### 包含关系与实现细节

​	在C++中，`cstdio`这个头文件确实是基于C语言的`stdio.h`头文件。它提供了`stdio.h`中相同的功能，但是有几个关键的差异，特别是在如何组织这些函数的方面。

- **函数封装**：`cstdio`通常会包含或重新声明`stdio.h`中定义的所有函数、宏和类型，并将它们置于`std`命名空间中。这是通过在C++的头文件中包括对应的C头文件（如`stdio.h`），然后再使用命名空间声明将所有内容封装在`std`内来实现的。

- **实现方式**：具体实现取决于编译器和C++标准库的实现。在大多数实现中，`cstdio`会直接或间接地包含`stdio.h`，以确保提供相同的功能。然后，它通过在`std`命名空间内再次声明这些函数来实现C++的命名空间规范。

​	为什么要这样做？ 目的是为了保持与C语言的兼容性，同时利用C++的命名空间特性提高代码组织的清晰度和避免全局命名空间的污染。这样，C++程序员可以选择使用`std::`前缀来调用标准库函数，这有助于区分标准库的函数和用户定义的或其他库的函数。

​	所以，尽管`cstdio`并不直接是`stdio.h`，它提供了`stdio.h`的所有功能，并且按照C++的风格对这些功能进行了封装。这使得C++程序员可以在享受C语言功能的同时，还能利用C++的语言特性。

​	观察到在linux系统的c++下包含<cstdio>头文件，去看这个头文件的开头内容时发现：

```cpp
#pragma GCC system_header

#include <bits/c++config.h>
#include <stdio.h>

#ifndef _GLIBCXX_CSTDIO
#define _GLIBCXX_CSTDIO 1

#if __cplusplus <= 201103L && !defined(_GLIBCXX_HAVE_GETS)
extern "C" char* gets (char* __s) __attribute__((__deprecated__));
#endif
```

看到<cstdio>头文件是包含了<stdio.h>头文件的。

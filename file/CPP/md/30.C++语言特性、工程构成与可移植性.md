

# C++语言特性、工程构成与可移植性(要有代码证明)

## 1.语言特性、工程构成与可移植性

### 1.1.面向过程式的程序设计

​	C语言的编程风格是属于过程式的程序设计，或者称为面向过程式的程序设计。那么，如何理解过程式的程序设计呢？就是当编写代码解决一个问题时，代码的编写方法是从上到下，逐步求精，一些公用的功能写成函数，需要用到结构体时就定义结构体等。这属于按顺序一步一步把问题解决，例如要上班，得先起床、穿衣服、刷牙、吃早饭、上班，这得按顺序来，不能没穿衣服就上班。 

​	C++语言对过程式的程序设计完全支持，并且支持的还非常好，这并不奇怪，因为C++语言本身的特性也是在不断扩充和完善的。

###  1.2.基于对象的程序设计和面向对象的程序设计

​	C++本身支持C语言风格的程序设计，同时也支持基于对象的程序设计和面向对象的程序设计。

​	无论基于对象的程序设计还是面向对象的程序设计，都没离开一个概念叫“对象”。那“对象”该如何解释呢？ 

​	在过程式程序设计中，例如要上班，得先起床、穿衣服、刷牙、吃早饭、上班，这个步骤是很清晰的。但是往往要解决的实际问题并不这么简单，也不是严格按照固定顺序走，比如正在吃早饭的时候，有个朋友突然打电话来借钱应急，那么上班的这个步骤就会被打乱。此时，那这种过程式的程序设计就显得过程太过简单了(不好处理突发事件以及改动方面的问题)，不容易应付一些意外的事情的处理。我们就试图找一找有没有更好的处理方式(更好的程序设计方式)。

​	在C语言部分学习了结构（一个学生，把学号、名字、性别、成绩等成员变量放到一起，构成结构），也叫结构体，但在C++中，不叫结构， 而叫“类”。在C语言中，要使用结构，需要先定义一个属于该结构体的变量（结构体变量），在C++中，不叫结构体变量，叫“对象”。

​	**对象的定义：是人们要进行研究的任何事物(指现实世界中的一切事物)，从最简单的整数到复杂的飞机等都可以看成对象；它不仅能表示具体的事物，还能表示抽象的规则，计划的事件。在C++中, 用 "类" 来描述 "对象"**。

​	但是类比结构更强大的地方在于：在类中，不仅可以定义成员变量，还可以定义成员函数（也叫方法）以实现一些功能。看看如下范例（很多成员函数命名方法采用拼音方式，方便看懂）：

```cpp
struct dagongzai
{
    // 用于面试和服装购买(方法)
    void qichuang();    // 起床
    void chuanyifu();   // 穿衣服
    void shuaya();      // 刷牙
    void chizaofan();   // 吃早餐
    void shangban();    // 上班

    // 提供对外接口,供其他人调用,突发事件
    void tufashijian(int eventtype); // 事件类型
};

struct dagongzai zhangsan;  // 定义一个此类的变量(对象)
zhangsan.qichuang();        // 调用对象的方法去起床
zhangsan.chuanyifu();       // 调用对象的方法去穿衣服

....
```

​	请看这种设计，把起床、穿衣服等功能包到一个类中去，然后定义一个属于该类的变量（对象），那么这个变量就可以调用这个类中的各种成员函数，如起床（qichuang）、穿衣服（chuanyifu）等。其他变量是没法调用起床、穿衣服等成员函数的。

​	但是这个类也提供一些对外接口，如上面的tufashijian（突发事件）成员函数，外界通过满足一定的条件，也能调用这个成员函数，如借钱的人，是你很好的朋友，才来借钱，大马路上随便一个陌生人是不会来借钱的，也就是说你的好朋友能调用tufashijian成员函数，而陌生人不能调用这个成员函数。

​	这种把功能包到类中(对应C++特性：**封装性**)，定义一个类对象并通过该对象调用各种成员函数实现各种功能的程序书写方式，称为基于对象的程序设计。 

​	随着发展，需求也在变更，不断出现了许多新需求。假如将来有一种新打工仔职业，如推销员tuixiaoyuan，老板要求推销员在每天正式上班之前，必须要在公司操场前面集合，先集体唱一次国歌，然后再开始手头 工作。那么，可以增加一个tuixiaoyuan类，继承自dagongzai类，这一继承，dagongzai类的很多方法，如起床、穿衣服、刷牙、吃早饭、上班 等，tuixiaoyuan类就都继承过来了，而且tuixiaoyuan类还可以增加自己的新成员函数changguoge（唱国歌），这在C++中称为**继承性**。

​	C++中还有一种特性叫**多态性**，后面会学习到，读者可以暂时这样理解：父类dagongzai和子类tuixiaoyuan都有一个同名的成员函数，那么，在做该成员函数调用时，到底是调用父类的还是调用子类的该函数呢？就会有一些说法了，这种说法就是所谓的多态性。

​	当把继承性和多态性技术融入程序设计中去时，基于对象的程序设计就升华了，也就是变得更高级了，此时就叫作面向对象的程序设计。

​	所以基于对象和面向对象程序设计的主要区别是：在基于对象的程序设计中额外运用了继承性和多态性技术，从而变成了面向对象程序设计(面向对象的三大特性： 封装、继承和多态)。 

​	那么，面向对象的程序设计优点也就显而易见了： 

​	（1）易维护。现在只有一个打工仔类，将来如果有个体户（getihu）类、教师（jiaoshi）类、大老板（dalaoban）类，他们的作息规律和上班的人不同，会有不同的接口，那每个接口的维护修改都在自己的类中进行，这就更清晰、更好维护了。

​	（2）易扩展。通过继承性和多态性，可以少写很多代码，实现很多变化。

​	（3）模块化。通过设置各种访问级别来限制别人的访问。例如，dagongzai类的shangban方法，如果不想让个体户访问到，那么通过设置，个体户就访问不到。这也保护了数据的安全。 面向对象程序设计其实就是一种程序设计理念，这种程序设计理念包含着许多不同的特性，后面会慢慢讲。因为这些特性在程序设计的过程中带来了更多的便利，大大提高了工作效率，等等。

### 1.3.面向过程、基于对象和面向对象之间的区别

​	面向过程编程、基于对象编程、和面向对象编程各有其特点和用途：

1. **面向过程编程**：
   - **关注点**：面向过程编程关注于函数或过程。程序被设计成一系列需要按特定顺序执行的步骤或函数。
   - **结构**：典型地，数据和函数是分开的，数据结构被定义并在不同的函数间传递。
   - **优势**：面向过程的编程语言通常简单易学，适合于一些需要直接操作硬件或进行系统级编程的场景。
   - **示例**：C语言是面向过程编程的一个典型代表(C语言是一种面向过程的编程语言)。

2. **基于对象编程**：
   - **封装**：虽然基于对象的语言支持将数据和函数封装成对象，但不支持继承和多态。
   - **重用**：代码重用更多依赖于复制粘贴或组合已有的对象，而不是通过继承关系。
   - **示例**：早期的编程语言如Ada和Modula-2支持这种范式。

3. **面向对象编程**：
   - **核心特性**：封装、继承和多态是面向对象编程的三大核心特性。
   - **设计**：通过类的概念允许程序员定义同时包含数据结构及相关方法的模块，新的类可以通过继承得到已有类的特性。
   - **目的**：通过使用面向对象的特性，可以创建更加模块化和可复用的代码。
   - **示例**：Java、C++ 和 Python 等。

​	面向过程编程侧重于过程的执行，基于对象编程引入了对象的概念但不支持对象之间的继承，而面向对象编程则通过继承和多态性等特性支持高度复用和模块化的软件设计。这些编程范式各有其适用的场景和优势，程序员可以根据具体的项目需求选择最适合的编程范式。



j进一步说明基于对象和面向对象的区别：

"基于对象"（Object-based）和"面向对象"（Object-oriented）这两个术语描述了相关但有区别的编程范式：

1. **基于对象编程**：
   - **无继承支持**：在基于对象的编程中，可以定义包含数据和方法的结构（对象），但不支持对象之间的继承。这意味着每个对象都是独立的，且不从其他对象继承属性或行为。
   - **重用限制**：由于缺乏继承，代码的重用主要依靠复制、粘贴和修改现有代码，而不是通过扩展已有类。
   - **示例**：一些早期的编程语言，如Ada和Modula-2，支持使用结构化数据和过程，但不支持完整的面向对象特性。

2. **面向对象编程**（OOP）：
   - **封装**：将数据（属性）和能操作这些数据的方法封装在一起。
   - **继承**：允许新的对象类直接取用（继承）另一个类的属性和方法，无需重新编写相同的代码。
   - **多态性**：允许子类以适合自己特定需求的方式重写（覆盖）父类的方法。
   - **示例**：Java、C++和Python等现代语言支持完全的面向对象特性，包括继承和多态性。

基于对象编程是面向对象编程的一个子集，支持对象的创建和使用，但不包括继承和多态这些核心的面向对象特性。面向对象编程则提供了更完整的工具集来组织和复用代码，通过继承和多态增强了软件的灵活性和可维护性。

### 1.4.其他特性

​	当然，C++不仅仅支持面向过程、基于对象、面向对象的程序设计， 还有很多其他特性，这些其他特性仅仅用面向过程、基于对象、面向对象 这种用词还无法完全包容进来，读者就理解成：C++的设计目标，就是各 种程序设计风格的综合，不会局限在只会是一个什么样子。 C++的版本更新速度越来越快，C++11、14、17，每过几年就出现 一个新的标准，所以对C++的认识也不能仅仅停留在面向对象程序设计 上。在今后的学习中，随着学习到的新知识的增多和经验积累的增加，慢慢会有更多体会。

### 1.5.C++接口类说明

​	c++的接口类到底是干什么用的？什么叫接口？ 这就好比你抽象一个类"人"：class people。人有一些必须要做的事，比如：吃饭、呼吸。 但是每个人吃饭又不一样，比如：用筷子吃（中国人）、用刀叉（欧美人）、用手抓（印度人）。 那么你如果不把“人”（people）这个类做为一个接口（抽象类）。单独一个吃就至少要写3个“吃”的重载方法。但一个中国人可能永远也用不到用刀叉吃饭、用手抓饭这样的方法。 这会造成写“人”(people)这个类的时候写了两个多余的方法。 所以C++提供了一个叫接口（抽象类）的东西，使得在声明一个“人”这个类的时候，就告诉大家：你们如果想继承我写的这个接口（抽象类）类， 就必须为“人”(people)这个类的子类写吃饭、呼吸的方法。这样，欧美的朋友继承你写的这个类的时候，他们写“吃”的方法就会用刀叉。而你印度的朋友继承你这个类的时候，他们写“吃”的方法就会用手抓。

​	进一步对C++接口类详细解释：

​	接口类在C++中通常是通过含有至少一个纯虚函数的抽象类来实现的。

**接口类（抽象类）**

- **定义**：在C++中，接口类通常是指那些包含至少一个纯虚函数（即只有声明没有实现的函数，使用`=0`进行声明）的类。这样的类不能直接实例化，只能被继承。
- **用途**：接口类定义了一个合同，继承它的子类必须实现这些纯虚函数，提供具体的行为。这样，接口类提供了一个公共的基础框架，让不同的子类可以在统一的接口下实现各自的功能。

**示例**

```cpp
#include <iostream>
using namespace std;

// 抽象类
class People {
public:
    // 纯虚函数，定义接口
    virtual void eat() = 0;
    virtual void breathe() = 0;
};

// 继承People并实现接口的类
class Chinese : public People {
public:
    void eat() override {
        cout << "Use chopsticks to eat." << endl;
    }
    void breathe() override {
        cout << "Breathe air." << endl;
    }
};

class American : public People {
public:
    void eat() override {
        cout << "Use fork and knife to eat." << endl;
    }
    void breathe() override {
        cout << "Breathe air." << endl;
    }
};

int main() {
    // People myPeople; // 错误: 不能实例化抽象类
    Chinese zhangsan;
    American john;

    People *p = &zhangsan;
    p->eat(); // Outputs: Use chopsticks to eat.
    p = &john;
    p->eat(); // Outputs: Use fork and knife to eat.

    return 0;
}
```

​	这个例子中，`People`是一个接口类，它定义了所有人都应该实现的`eat`和`breathe`方法。不同文化背景的人（如`Chinese`和`American`）以不同的方式实现了这些方法。这样，我们通过抽象类和接口的使用，能够编写出更灵活、可扩展和易于管理的代码。

### 1.6.C++中类的概念、接口与实现的区别、以及类实例的意义

​	一般地，我们称C++类声明中的“函数原型”为接口，它只是提供给了用户如何使用的具体细节，而隐藏了具体的代码；类似地，我们称类的成员函数的具体的代码为实现。如下： 

```cpp
class Test 
{ 
 public:
    // 此处的成员函数void test()仅仅告诉告诉用户调用它时传递度几个参数，以及它返回什么值，什么作用等，
    // 并没有告诉用户test()函数到底怎么完问成这些功能的，这就是接口；
 	void test();                                            
}; 

void Test::test() {...}//这里是实现，此处是test()函数具体的代码，用户无需关心它是怎么写的。

int main()
{
    /*此处定义了一个Test类型的对象abc，abc 一般我们称之为类的“实例”（不是实现）。一个没有定义对象的类，只是一个“概念”，而不是一个实体，即实际存在的东西。 类的作用只有在定义了类的实例（也就是类对象）后才会体现出来（静态成员函数和静态成员变量例外）。以int i;为例，int就好比是类（class），而i好比是类的实例。*/
    Test abc;
    
    return 0;
}
```

​	进一步详细解释：

 **类声明与函数原型（接口）**

​	在C++中，类声明包括数据成员和成员函数的声明。当我们提到一个成员函数的“函数原型”，我们实际上是在定义一个接口。这个接口告诉用户或调用者该函数需要什么参数、返回什么值、预期执行什么功能，但并不展示函数的具体实现。这样的设计有几个好处：

- **封装**：通过隐藏实现细节，我们提高了代码的安全性和可维护性。
- **抽象**：用户只需要知道如何使用接口，而不需要关心背后的具体实现，这降低了使用复杂系统的难度。

**成员函数的实现**

​	成员函数的实现通常在类声明的外部进行，除非是内联函数。实现部分包含了函数如何完成其声明功能的具体代码。这部分对用户来说是不可见的，它允许开发者在不影响使用者的情况下改进或修改实现细节。

**类的实例**

类的实例是类的一个具体对象。在上面的例子中，`Test abc;` 创建了一个名为 `abc` 的 `Test` 类型的对象。这个对象是类概念的具体化，它具备类中定义的属性和行为。通过这个实例，我们可以使用类定义的方法和访问其数据成员。

​	在面向对象编程中，类的数据成员通常包括两种类型：普通成员变量和静态成员变量。

1. **普通成员变量**：这些变量是与类的每个实例关联的。每个对象都有其自己的一份拷贝，所以它们的状态是独立的。这些变量通常用于存储对象的属性和状态信息。这些变量是每个类实例特有的。它们不共享数据，每个对象都有自己的一份数据拷贝。 
2. **静态成员变量**：这些变量与类本身关联，而不是与类的任何特定实例关联。它们在内存中只有一份拷贝，由类的所有实例共享。静态变量常用于存储所有实例共有的信息或者类级别的状态。这些变量属于类本身，而不是类的某个特定实例。无论创建多少个对象，所有实例都会共享同一个静态变量的数据。

​	总结来说，类的数据成员确实包括了这两种类型的变量，它们的主要区别在于数据存储和访问的方式。

**比喻解释**

你用 `int` 和 `i` 的比喻是恰当的。在这个比喻中：

- **`int`**：类似于一个类（`class`），它定义了数据类型的特征和可能的操作。
- **`i`**：类似于一个类的实例，它是具体的变量，存储了整数类型的值。

**总结**

- **类声明**：是一个模板，定义了数据成员和函数的结构。
- **接口**：类中函数的声明，定义了如何与函数交互但隐藏了具体实现。
- **实现**：函数的具体代码，定义了函数的行为。
- **实例**：类的具体对象，通过实例化类可以创建具有实际值的对象。

这种设计允许程序员编写灵活、高效且易于维护的代码。通过抽象和封装，类提供了一种强大的方式来组织和处理数据和功能，使得大型软件项目的管理变得更加可行。


## 2.C++程序和项目文件构成谈

​	项目构成：

​	（1）一个项目（工程）中可以包含多个.cpp文件和多个.h头文件， 一般.cpp叫源文件，.h叫头文件。一些公共的定义一般都会放在头文件中 （如函数声明，一些类、结构的定义，一些#define等），然后在源文件中用#include把头文件包含进来使用。

​	 （2）以往见过的源文件名是以.cpp后缀结尾，头文件名是以.h后缀结尾，这些后缀用来告诉编译器这是一个C++的源程序或者是C++的头文 件 。 不同的C++编译器会使用不同的文件后缀名，如有.c、.cpp、.cc、.cxx这些源文件后缀，.cc、.cxx一般在GNU编译器上比较常见。此外，还有.m、.mm——如果在MacOS苹果电脑上用Xcode进行开发，它们用的是Objective-C语言，但里面有时也会嵌入C或者C++代码。一般.m就暗示代码含有Objective-C和C语言语句，.mm就暗示代码含有Objective-C和C++语句。

​	（ 3 ）C++语言的头文件扩展名一般以.h居多，此外，还有.hpp。.hpp一般来讲就是把定义和实现都包含在一个文件里，有一些公共开源库就是这样做，主要是能有效地减少编译次数，读者在日后学习类的定义和实现时会慢慢理解把定义和实现都包含在一个文件里的情形，也会慢慢领会这种开发思想和精神。

​	（4）还能够发现，很多C++提供的头文件已经不带扩展名。以往在C语言中经常用到的头文件，如比较熟悉的stdio.h等，在C++98标准之后，都变成了以c开头并去掉扩展名的文件，如stdio.h就变成了cstdio文件，但是cstdio和stdio.h是两个文件，用#include命令表示的时候只需要写成#include＜cstdio＞，至于cstdio里面做的事，肯定包含stdio.h 中做的事，而且额外还做了一些其他事，细节可以不必关心。

## 3.编译型语言概念与可移植性问题

​	C++本身是属于编译型语言。什么叫编译型语言呢？程序在执行之前需要一个专门的编译过程，把程序编译成二进制文件（可执行文件），执行的时候，不需要重新翻译，直接使用编译的结果就行了。 

​	相对于编译型语言，还有解释型语言。解释型语言编写的程序不进行预先编译，以文本方式存储程序代码。但是，在执行程序的时候，解释型语言必须先解释再执行。 

​	显然，编译型语言执行速度快，因为它不需要解释。而像Lua等语言，就属于解释型语言。 

​	请考虑一个问题，在Windows操作系统上生成的可执行程序到Linux操作系统上去能执行吗？当然是执行不了的。因为不同操作系统平台的可执行程序的结构不同、接口不同等有太多的不同。 

​	如果从编写程序的角度谈到可移植性，实际上是针对源代码而言的， 也就是源代码的可移植性，相同的一份源代码，在Windows操作系统上能够成功地编译和运行（如借助Visual Studio），在Linux操作系统上也能够成功地编译和运行（如借助g++工具）。当然，在不同的操作系统 上，这份代码生成的可执行文件执行后能够实现相同的功能，那么这份源代码就被称为可移植的。

## 4.C与C++的编程风格区别

C语言和C++语言虽然有着密切的联系，但在编程风格上存在显著的差异，主要体现在它们支持的编程范式和功能上：

1. **编程范式**：

   - **C语言**：是一种面向过程的编程语言。在C语言中，重点放在过程和函数上，数据和操作数据的函数通常是分开的。
   - **C++语言**：是一种支持多范式的编程语言，既支持面向过程编程，也支持面向对象编程。此外，C++还引入了泛型编程和函数式编程的元素。

2. **代码结构和组织**：

   - **C语言**：程序通常组织为一系列的函数调用，数据结构和操作它们的函数是分离的。
   - **C++语言**：可以将数据和相关的操作封装到类中，利用继承和多态来构建复杂的系统。这使得代码更加模块化，易于管理和扩展。

3. **抽象级别**：
   - **C语言**：提供基本的抽象，主要通过函数和结构体来实现。它更接近硬件，经常被用于系统编程，如操作系统和嵌入式系统。
   - **C++语言**：提供了更高级的抽象，如类和模板。这些特性使得C++更适合于设计大型软件系统和应用程序。

4. **内存管理**：
   - **C语言**：提供基本的内存管理函数，如`malloc`和`free`，程序员需要手动管理内存。
   - **C++语言**：除了支持C风格的内存管理，还引入了构造函数、析构函数、以及基于作用域的资源管理（RAII），自动管理资源。还支持新的内存管理操作如`new`和`delete`。

5. **标准库**：
   - **C语言**：标凈库相对简单，主要包括I/O处理、字符串操作、数学函数等。
   - **C++语言**：拥有更为丰富的标准库，包括标准模板库（STL），这提供了一系列的数据结构和算法，如向量、列表、队列、栈以及各种算法。

6. **类型安全**：

   - **C语言**：类型检查相对宽松，允许更多的隐式转换。
   - **C++语言**：增强了类型安全，提供了函数重载和模板等特性，减少了类型错误的可能性。

7. **标准库头文件的使用**：

   - 头文件命名和结构

     - **C语言头文件**：C语言的头文件通常包括扩展名，例如`stdio.h`、`stdlib.h`等。这些头文件直接定义了函数、宏和类型。
     - **C++语言头文件**：C++为了与C语言的兼容性，同样可以使用C语言风格的头文件，如`stdio.h`。但C++推荐使用没有扩展名的头文件，这些文件是C头文件的C++版本，如`cstdio`、`cstdlib`等。这些头文件将C库的内容置于`std`命名空间中，这有助于避免全局命名空间的污染，增强了程序的封装性和模块化。

   - 命名空间的使用

     ​	C++引入了命名空间的概念，主要是为了解决大型项目中可能出现的命名冲突问题。通过使用命名空间，C++标准库的所有实体都被放在`std`命名空间下：

     - 在C中，标准库函数如`printf`和`scanf`直接位于全局命名空间。
     - 在C++中，相应的函数如`std::printf`和`std::scanf`位于`std`命名空间中。这意味着在C++中使用这些函数时，要么使用命名空间前缀`std::`，要么通过使用`using namespace std;`声明来引入整个命名空间。

   - 库函数的实现方式

     - **类型安全和重载**：C++对C标准库函数进行了重载和类型安全的增强。例如，C++中的`<cstring>`头文件提供了多个版本的`std::strchr`和`std::strstr`，这使得使用这些函数时更加安全和方便。
     - **模板和泛型编程**：C++还提供了模板，允许函数和类与数据类型无关。这在C中是不可能的，因为C不支持泛型编程。

     头文件的差异、命名空间的引入以及对类型安全和泛型编程的支持，这些都是C++在继承C的基础上进行的改进。这些改进使得C++在组织大型、复杂程序时更为有效，也更适应现代软件开发的需求。相比之下，C语言以其简洁和直接操作硬件的能力，在系统编程和资源受限的环境中仍然具有不可替代的优势。

总体来说，C语言的编程风格更加简洁和直接，适合低层次的硬件操作和系统编程。而C++的编程风格则更加复杂，支持更高层次的抽象和软件工程，适合构建大型软件系统。选择使用哪种语言往往取决于项目需求、性能要求和开发资源。


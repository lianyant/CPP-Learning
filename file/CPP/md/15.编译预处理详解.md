# 编译预处理详解

## 1.C/C++语言的编译过程


C/C++语言的编译过程可以分为四个主要阶段：预处理、编译、汇编和链接。这个过程将源代码转换成可执行文件。下面是各个阶段的详细说明：

### 1. 预处理（Preprocessing）

预处理阶段发生在实际编译之前。在这个阶段，预处理器接收源代码文件，并处理所有以`#`开始的预处理指令，这包括：

- **宏定义的扩展**：将所有宏定义（如`#define`）替换为它们的值。
- **条件编译**：根据`#ifdef`、`#ifndef`、`#endif`等条件编译指令确定哪些部分的代码被编译。
- **文件包含**：处理`#include`指令，将头文件的内容插入到源文件中。
- **移除注释**：从源代码中移除所有注释。
- **添加编译器标记**：插入特定编译器可能使用的特殊标记。

处理完预处理指令后，预处理器输出的结果是一个展开的源代码文件，这个文件接着被送到编译器进行编译。

### 2. 编译（Compilation）

编译阶段是将预处理过的源代码转换成汇编代码的过程。编译器分析代码并生成平台相关的汇编指令，通常这些指令对应着源代码中的结构和语句。

- **语法分析**：编译器检查代码是否符合语法规则。
- **语义分析**：确认代码中的元素（如变量和函数）都有正确的定义和使用。
- **优化**：编译器在保持程序逻辑不变的情况下尝试优化代码，以提高运行效率和减少资源使用。

编译器的输出是汇编语言代码。

### 3. 汇编（Assembly）

汇编器接收汇编语言代码，并将其转换为机器语言指令（通常称为目标代码或目标文件）。目标代码是由操作系统和处理器直接理解的指令集合。

每个源代码文件在被编译和汇编后都会生成一个相应的目标文件，例如在Windows系统中，这些文件通常有`.obj`扩展名，在UNIX系统中则是`.o`。

### 4. 链接（Linking）

链接是编译过程的最后一个阶段。链接器的工作是将所有的目标文件和程序需要的库文件合并成一个单独的可执行文件。

- **解析引用**：链接器查找所有变量和函数调用对应的内存地址。
- **地址和大小的分配**：给每个目标文件中的符号（变量和函数）分配最终的地址。
- **合并**：将所有目标文件和库合并成一个单一的可执行文件。

在这个阶段，如果代码中有任何一个模块引用了另一个模块中未定义的符号，就会发生链接错误。

最终，链接器输出的是一个可执行文件，如Windows中的`.exe`文件或Linux中的执行文件。

整个编译过程可以通过编译器驱动程序（如gcc或cl）进行控制，通常一条命令就可以自动完成这四个阶段。程序员也可以选择手动执行每个阶段，以便更细致地控制编译过程。



## 2.编译之预处理

​	编译预处理阶段是C/C++编译过程中的第一步，主要目的是准备源代码以便于编译器能够顺利编译。在这个阶段，预处理器处理所有的预处理指令，这些指令通常以`#`开始。主要的预处理任务包括宏定义、文件包含和条件编译。

### (1)宏定义

​	宏定义是一种在预处理时进行文本替换的简便方式。

#### 1).**不带参数的宏定义**

​	不带参数的宏定义在C/C++语言中是一种基本的预处理功能，用于在预处理阶段将指定的宏名替换为定义的内容。这种替换机制提高了代码的可读性、方便性和可维护性。以下是对不带参数宏定义的全面详细总结：

**定义和展开**

- **定义**：通过`#define`预处理指令定义，形式为`#define 宏名 宏内容`。
- **宏展开**：预处理器将代码中出现的所有宏名替换为对应的宏内容，这一替换过程称为宏展开或宏替换。

**优点**

1. **便于修改**：通过集中定义宏，可以方便地修改代码中重复出现的值或表达式，只需修改宏定义即可影响整个程序，提高了代码的可维护性。
2. **提高可读性**：使用宏名代替复杂的常量或表达式，可以使代码更易读懂。
3. **提高可移植性**：对于可能根据不同平台变化的值，通过宏定义可以轻松调整，增加程序的可移植性。

**注意事项**

1. **宏名习惯**：宏名一般使用大写字母，以便与普通变量区分，这是一种广泛遵循的编程习惯。
2. **非语句**：宏定义不是C语言的语句，不应在宏定义的末尾加分号；否则，分号也会成为宏展开的一部分。
3. **作用范围**：宏定义的作用范围从定义点开始，到源文件结束，或者遇到相应的`#undef`指令为止。它不能跨文件使用。要在多个文件中使用相同的宏定义，可以将它们放在一个头文件中，并在需要的源文件中包含这个头文件。
4. **层层替换**：宏定义可以引用其他已定义的宏，预处理器会递归地进行宏展开。
5. ****：位于字符串常量中的宏名不会被预处理器替换。

**示例**

```c
#define PI 3.14159
#define TWO_PI 2*PI

void exampleFunction() {
    double area = PI * r * r; // 使用PI
    double circumference = TWO_PI * r; // 使用TWO_PI，展开后为2*3.14159*r
    // 特殊的：字符串内的宏名不替换
    printf("asjdlak:%s\n","TWO_PI");// 并不会进行替换
}

// #undef可以终止宏的定义，使其后的代码中不能使用该宏
#undef PI
```

​	不带参数的宏定义是C/C++预处理中的一个强大工具，它通过简单的文本替换机制，为编写高效、易于维护和可移植的程序代码提供了便利。正确和适当地使用宏定义，可以极大地改善程序的可读性和可维护性。

#### 2).带参数的宏定义

​	带参数的宏定义在C/C++中是一种强大的预处理特性，它允许在宏定义中使用参数，从而提高代码的复用性和灵活性。以下是关于带参数宏定义的全面详细总结：

**定义形式**

​	带参数的宏定义允许在宏名后面加上一组括号，括号内是参数列表，形式为：

```c
#define 宏名(参数列表) 被替换的内容
```

​	这允许宏在展开时将实参替换到指定位置，增加了宏的灵活性和功能性。

**宏展开过程**

​	在预处理阶段，当遇到宏调用时，预处理器将实参替换到被替换的内容中相应的形参位置。这个过程不涉及参数类型检查，也不计算表达式的值，仅仅是文本替换。

**使用注意事项**

1. **参数包含运算符**： 当宏的参数中包含运算符，如加号`+`，应在宏定义中对参数使用括号括起来，避免因优先级问题导致不预期的结果。
2. **宏定义与空格**： 宏名和参数列表之间不应有空格，否则之后的内容会被视为宏内容的一部分。
3. **宏与函数区别**：
    - 带参数的宏展开是在编译时进行的，不涉及运行时求值。
    - 宏的参数没有类型，仅是简单的文本替换。
    - 使用宏可以减少运行时开销，但如果过度使用，会增加编译后的代码量。
4. **避免宏展开导致的错误**： 由于宏展开是简单的文本替换，可能会引入诸如操作符优先级不符合预期的问题。使用括号正确封装参数和整个宏定义是解决这一问题的有效方式。

**示例**

- **计算面积的宏**：

    ```c
    #define AREA(r) (3.14159 * (r) * (r))
    ```

- **求两数最大值的宏**：

    ```c
    #define MAX(a, b) ((a) > (b) ? (a) : (b))
    ```

- **防止优先级错误的宏**：

    ```c
    #define SUM(a, b) ((a) + (b))
    ```

**示例2**

在C或C++中，定义带参数的宏时，宏名与参数列表之间加入空格会导致预处理器误解其定义，从而影响宏的展开和使用。这里通过一个例子来说明这个问题：

错误的宏定义示例：

​	假设定义一个宏来计算两个数的和：

```c
#define SUM (a, b) (a + b)
```

​	这里，在`SUM`和`(a, b)`之间加入了一个空格。根据预处理器的工作方式，它会将`SUM`视为宏名，而将`(a, b) (a + b)`整体视为宏的替换文本。这意味着在代码中尝试使用`SUM(1, 2)`时，预处理器不会识别它为带参数的宏调用，因为它期望找到的宏名是`SUM`而不是`SUM `（注意空格）。

​	尝试使用这个宏的代码如下：

```c
int main() {
    int result = SUM(1, 2); // 试图计算1 + 2的和
    return 0;
}
```

​	在这种情况下，编译器可能会报错，指出`SUM`后面的`(1, 2)`是意外的，因为`SUM`被视为不带参数的宏，所以括号内的内容无法正确处理。

正确的宏定义示例：

​	为了避免这种问题，应该在宏名和参数列表之间**不加空格**，如下所示：

```c
#define SUM(a, b) (a + b)
```

​	这样定义后，使用宏的代码可以正确地被预处理器展开：

```c
int main() {
    int result = SUM(1, 2); // 正确展开为1 + 2
    return 0;
}
```

​	在这个修正后的定义中，`SUM(1, 2)`会被预处理器正确地展开为`1 + 2`。

​	宏定义中宏名与参数列表之间的空格会导致预处理器错误地解析宏定义，从而影响宏的正确展开。在定义带参数的宏时，务必不要在宏名和参数列表之间加入空格。

**高级用法**

​	宏还支持一些高级用法，如使用`##`进行参数连接，使用`#`将参数转为字符串。这些高级用法在某些特定场合非常有用。

**结论**

​	带参数的宏定义是C/C++预处理器提供的一种强大工具，它通过允许在宏中使用参数来增加代码的可读性和重用性。然而，正确使用宏需要对其展开机制有深入理解，以避免常见的陷阱，如优先级错误。在实践中，应当在确实需要时才使用宏，同时注意保持代码的清晰和可维护性。

### (2)文件包含和条件编译

#### 1).文件包含

​	文件包含是C/C++预处理指令中的一个重要特性，允许将一个文件的内容包含到另一个文件中。这一功能主要通过`#include`指令实现。以下是关于文件包含的全面详细总结：

**基本概念**

- **目的**：`#include`指令使得程序员可以将代码的一部分抽离到单独的文件中，然后在需要的地方包含进来，常见于头文件的引用。
- **使用场景**：最常见的用途是包含头文件（`.h`或`.hpp`），头文件通常包含函数声明、宏定义、类型定义等。

**`#include`的基本形式**

1. **使用尖括号**：`#include <filename>`。用于包含标准库头文件或系统头文件，编译器会在标准库的目录中查找指定的文件。
2. **使用双引号**：`#include "filename"`。首先在当前文件的目录下查找指定的文件，如果未找到，再按标准库路径搜索。适用于包含项目内的自定义头文件。

**文件包含的特性**

1. **可重用性**：通过把公共代码抽取到头文件中，多个源文件可以重用这些代码，提高代码的重用性和一致性。
2. **嵌套包含**：头文件可以包含其他头文件，形成包含的嵌套关系。但要注意避免循环包含，这可能导致编译错误。
3. **编译依赖**：修改了某个头文件后，包含了这个头文件的所有源文件都需要重新编译，因为预处理结果已经改变。

**注意事项**

1. **重复包含问题**：为防止头文件内容被重复包含（特别是在头文件嵌套包含的情况下），通常使用宏定义防护（`#ifndef`、`#define`、`#endif`）来避免。
2. **路径问题**：使用双引号时，首先在当前目录查找，然后再按系统设置的搜索路径查找。使用尖括号时，直接按系统设置的搜索路径查找。
3. **文件包含与模块化**：适当的文件包含策略有助于项目的模块化设计，便于管理和维护。

**示例**

- 标准库头文件包含：

    ```c
    #include <stdio.h>
    
    
    // 也可以写成:
    #include "stdio.h"
    /*当使用#include "filename"形式包含头文件时，编译器首先会在当前源文件的目录（或指定的搜索路径）中查找该头文件。如果在这里找到了名为filename的文件，那么它会使用这个找到的文件。这意味着如果您使用#include "stdio.h"，并且在您的项目目录中有一个自定义的stdio.h文件，编译器将优先使用这个项目内的头文件而不是标准库中的stdio.h。
    
    因此，如果您确实有自定义的stdio.h头文件，使用#include "stdio.h"将导致编译器包含您的自定义版本，这可能会覆盖标准的功能，除非这正是您的意图。这种做法在某些情况下可能是有用的，比如您需要扩展或修改标准库的某些功能，但这通常需要非常谨慎地处理，以避免引入预期外的行为或错误。
    
    如果您希望确保总是包含标准库中的stdio.h，应该使用尖括号形式：#include <stdio.h>。这样做将指导编译器从系统的标准库路径中查找和包含头文件，忽略本地目录中的同名文件。*/
    ```

- 自定义头文件包含：

    ```c
    #include "myheader.h"
    ```

**总结**

​	文件包含是C/C++中用于代码组织和模块化的核心机制。合理使用`#include`指令，可以显著提高代码的可读性、可维护性和重用性。开发者应当熟悉包含机制的正确使用方法，避免常见的问题，如重复包含和循环包含，确保代码的健壮性和清晰的组织结构。

#### 2).条件编译

- 条件编译是C/C++预处理指令的一部分，允许基于特定条件来包含或排除代码段。这种机制特别有用于跨平台开发、调试和编译时优化。以下是条件编译的全面详细总结：

    

    **条件编译的主要形式**

    1. **基于是否定义了标识符**：
        - 使用`#ifdef`和`#ifndef`预处理指令可以检查某个宏是否被定义。
        - `#ifdef`当标识符被定义时编译程序段1。
        - `#ifndef`当标识符未被定义时编译程序段1。
        - 可选的`#else`部分可以指定标识符未定义（`#ifdef`）或已定义（`#ifndef`）时编译的代码。
    2. **基于表达式的值**：
        - 使用`#if`可以根据表达式的值来控制编译。如果表达式为真（非0），则编译程序段1。
        - `#elif`和`#else`可用于提供额外的条件分支和默认选项。

    **应用场景**

    1. **调试**：
        - 通过定义或未定义特定的宏，可以控制调试代码的包含，方便在开发过程中调试而在发布版本中自动排除这些代码。
    2. **跨平台开发**：
        - 条件编译使得相同的源代码能够针对不同平台进行适当的编译，通过检测平台特定的宏来包含或排除特定的代码段。

    **优点**

    1. **减少目标程序的长度**：通过在编译阶段排除不需要的代码，可以减小最终生成的程序的大小。
    2. **提高代码的可移植性**：使得一套代码能够更容易地在不同的环境下编译和运行，减少平台相关代码的重复。

    **注意事项**

    - **过度使用注意**：虽然条件编译非常强大，但过度使用会使代码难以阅读和维护。应当谨慎使用，尽量保持代码清晰。
    - **避免复杂的条件嵌套**：过于复杂的条件嵌套可能导致代码逻辑难以理解。在可能的情况下，简化条件编译逻辑或寻求其他解决方案。

    **示例**

    ```c
    #define DEBUG
    
    #ifdef DEBUG
        printf("Debug information\n");
    #else
        printf("Release version\n");
    #endif
    
    #ifndef WINDOWS
        printf("Non-Windows platform\n");
    #endif
    
    #if defined(WINDOWS) && !defined(DEBUG)
        printf("Windows release version\n");
    #endif
    ```

    **总结**

    ​	条件编译是预处理阶段非常强大的一部分，它为代码的调试、优化和跨平台开发提供了极大的便利。合理使用条件编译指令可以使代码更加灵活，适应不同的编译环境和需求。然而，应该避免过度依赖条件编译，以保持代码的可读性和可维护性。

## 3.编译之编译

​	编译过程是C/C++程序从源代码转换成可执行代码的关键步骤之一。在预处理之后，编译器将处理过的源代码（已经展开了所有的预处理指令）转换成机器语言或者更常见的汇编语言代码。以下是编译过程的详细说明：

### 1. 解析和语法分析

- **解析**：编译器首先将源代码分解成一系列的符号（tokens），这些符号包括关键字、变量名、操作符等。
- **语法分析**：编译器根据语言的语法规则检查源代码的结构是否正确。这一阶段会构建一个或多个抽象语法树（AST），用于表示源代码的结构。如果源代码中存在语法错误，编译器会在这一阶段报错并停止编译过程。

### 2. 语义分析

- **类型检查**：编译器检查数据类型的使用是否合法，包括变量的定义、函数的调用等。
- **作用域规则**：编译器根据作用域规则确定变量和函数的可见性。
- **符号绑定**：编译器将变量和函数的使用与其定义关联起来，确保所有的引用都有对应的定义。

### 3. 优化

编译器在保持程序语义不变的前提下，对代码进行优化，以提高程序的运行效率和减少资源消耗。优化可以在多个层次上进行，包括但不限于：

- **局部优化**：对单个函数或代码块进行优化。
- **全局优化**：跨函数或整个程序的优化。
- **机器代码优化**：针对特定硬件平台的优化。

优化的目标包括减少CPU使用、缩短程序执行时间、减少内存使用等。

### 4. 代码生成

- **目标代码生成**：编译器将AST转换成目标平台的机器代码或汇编代码。这包括为变量分配寄存器或内存地址、生成具体的机器指令等。
- **汇编**：如果生成的是汇编代码，则需要一个汇编过程将汇编代码转换为机器代码。

### 5. 产出物

编译过程的最终产出是目标代码文件，通常是机器代码组成的目标文件（如`.o`或`.obj`文件）。这些目标文件随后会被链接器使用，生成可执行文件或库文件。

### 总结

编译过程是将预处理后的源代码转换为目标代码的复杂过程，涉及到多个步骤，包括语法分析、语义分析、优化和代码生成。通过这一过程，编译器确保代码符合C/C++语言的规范，同时尽可能地优化代码，为生成高效的可执行程序奠定基础。编译过程的效果和性能很大程度上取决于编译器的实现和配置，以及源代码的特点。

## 4.编译之汇编

​	在C/C++程序的编译过程中，汇编过程是编译阶段之后进行的一步，它将编译器生成的汇编代码转换成机器可执行的指令（即目标代码）。以下是汇编过程的详细说明：

### 1. 汇编代码

- **来源**：编译阶段结束后，编译器生成的汇编代码作为汇编过程的输入。这些汇编代码通常是人类可读的文本格式，描述了程序执行的具体指令，以及数据的存储位置等。

### 2. 汇编器的作用

- **转换**：汇编器（Assembler）读取汇编代码，并将其转换为机器代码。机器代码是计算机硬件能直接理解和执行的二进制指令集。
- **符号解析**：汇编代码中的符号（如变量名和函数名）被替换为实际的内存地址或其他标识符。
- **地址分配**：汇编器为程序中的各种指令和数据分配具体的内存地址。

### 3. 产出物

- **目标文件**：汇编过程的输出是目标文件（Object File），它包含了程序的机器代码。这些目标文件通常还需要链接（Linking）过程，才能生成最终的可执行文件或库文件。

### 4. 汇编语言与机器语言

- **汇编语言**：汇编语言是一种低级语言，每一条汇编指令几乎直接对应一条机器指令，但它使用符号和单词来表示操作和数据，比纯二进制的机器代码更易于人类理解和编写。
- **机器语言**：机器语言是计算机处理器直接执行的二进制指令序列。汇编语言的指令在汇编过程中被转换为机器语言。

### 5. 注意事项

- **平台依赖性**：由于汇编语言紧密依赖于特定的硬件架构，汇编代码和生成的机器代码通常是针对特定处理器设计的。因此，汇编过程和产生的目标文件是平台相关的。
- **调试信息**：在某些情况下，汇编器可以包含额外的调试信息在目标文件中，这有助于后续的调试过程。

### 总结

汇编过程是编译过程的一部分，它将编译器生成的汇编代码转换成机器代码。这一步骤是程序从人类编写的源代码最终变成计算机可以直接执行的指令的关键环节。汇编过程的具体实现和效果取决于汇编器的设计以及目标硬件平台的特性。

## 5.编译之链接

​	在C/C++程序的编译过程中，链接（Linking）是最后一步，紧跟在汇编过程之后。链接的主要任务是将编译器生成的一个或多个目标文件（Object Files）以及所需的库（Libraries）合并成一个单一的可执行文件（Executable）或库文件（Library）。以下是链接过程的详细说明：

### 1. 链接器的作用

- **合并目标文件**：链接器将各个目标文件中的代码和数据合并到一起。在这一过程中，它需要处理各种符号的引用和定义，确保每个符号引用都正确地指向其定义。
- **解析外部符号**：程序中使用的函数和变量，如果定义在其他文件或库中，链接器负责解析这些外部引用，确保引用的正确性。
- **地址分配**：链接器为程序中的每个函数和全局变量分配最终的内存地址，并调整代码中的地址引用，以确保它们指向正确的位置。

### 2. 静态链接与动态链接

- **静态链接**：在静态链接中，链接器将所有用到的库函数的代码直接合并到可执行文件中。这意味着可执行文件包含了它运行所需的全部代码，但这也可能导致文件体积较大。
- **动态链接**：在动态链接中，程序使用的库不会被合并到可执行文件中，而是在程序运行时由操作系统加载。这可以减小可执行文件的大小，使得多个程序共享同一份库代码成为可能。

### 3. 重定位

- **作用**：因为在编译时，编译器无法知道目标代码在内存中的确切位置，链接器通过重定位调整代码和数据的地址，确保程序可以在内存中的任意位置正确执行。

### 4. 符号解析

- **全局与局部符号**：链接器需要区分全局符号（如函数和全局变量）和局部符号（如局部变量）。全局符号可能在多个目标文件中引用或定义，而局部符号仅在其定义的目标文件中可见。
- **符号冲突**：如果多个目标文件定义了相同的全局符号，链接器将报错，指出符号重定义。

### 5. 库链接

- **系统库和用户库**：链接过程中，链接器除了处理用户编写的目标文件，还需要链接程序所需的系统库和用户自定义库。
- **库搜索路径**：链接器根据库搜索路径来找到程序引用的库。系统库路径通常由系统预定义，而用户库路径可以通过编译命令指定。

### 6. 产出物

- **可执行文件**：对于应用程序，链接的最终产物是一个可执行文件，可以由操作系统加载和执行。
- **库文件**：对于库，链接的产物是一个库文件，可被其他程序在编译时或运行时引用。

### 总结

​	链接过程是编译过程的最后一步，它将所有的目标文件和库合并成一个完整的可执行文件。链接器在这个过程中解决符号引用、重定位和库依赖等问题，确保程序能够正确执行。静态链接和动态链接提供了不同的程序部署和共享方式，开发者可以根据需要选择适当的链接方式。
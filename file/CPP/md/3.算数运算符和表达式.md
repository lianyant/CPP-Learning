# 算数运算符和表达式(待vscode代码验证)

## 1.C/C++语言的运算符

在C和C++中，运算符用于对数据进行操作。大多数C语言中的运算符在C++中也同样存在，并且C++还增加了一些新的运算符。以下是C语言和C++语言中的运算符列表：

### C语言中的运算符：

#### 算术运算符：

- `+` 加法
- `-` 减法
- `*` 乘法
- `/` 除法
- `%` 取模

#### 关系运算符：

- `==` 等于
- `!=` 不等于
- `>` 大于
- `<` 小于
- `>=` 大于等于
- `<=` 小于等于

#### 逻辑运算符：

- `&&` 逻辑与
- `||` 逻辑或
- `!` 逻辑非

#### 位运算符：

- `&` 按位与
- `|` 按位或
- `^` 按位异或
- `~` 按位取反
- `<<` 左移
- `>>` 右移

#### 赋值运算符：

- `=` 赋值
- `+=` 加后赋值
- `-=` 减后赋值
- `*=` 乘后赋值
- `/=` 除后赋值
- `%=` 模后赋值
- `<<=` 左移后赋值
- `>>=` 右移后赋值
- `&=` 按位与后赋值
- `^=` 按位异或后赋值
- `|=` 按位或后赋值

#### 递增递减运算符：

- `++` 递增
- `--` 递减

#### 条件运算符：

- `?:` 三元条件运算符

#### 逗号运算符：

- `,` 逗号

#### 其他运算符：

- `sizeof` 运算符
- `&` 取地址运算符
- `*` 指针解引用运算符
- `->` 结构体和联合体指针成员访问
- `.` 结构体和联合体成员访问

### C++语言中新增的运算符：

#### 类成员访问运算符：

- `.*` 类成员通过对象访问
- `->*` 类成员通过指针访问

#### 类型相关运算符：

- `typeid` 类型信息
- `const_cast` 类型转换
- `dynamic_cast` 类型转换
- `static_cast` 类型转换
- `reinterpret_cast` 类型转换
- `new` 分配内存
- `delete` 释放内存
- `new[]` 分配数组内存
- `delete[]` 释放数组内存

#### 其他运算符：

- `::` 命名空间分辨符
- `noexcept` 异常规范（C++11）
- `alignof` 对齐规范（C++11）
- `alignas` 对齐声明（C++11）

#### Lambda表达式（C++11及以后）：

- `[]` Lambda介绍符
- `()` Lambda参数列表
- `{}` Lambda函数体

请注意，随着C++标准的发展，可能会有新的运算符加入。以上列表覆盖了至C++17标准的运算符。

#### 强制类型转换运算符

在C和C++中，存在强制类型转换（也称为显式类型转换）运算符，它们用于将一个变量的类型转换为另一个类型。在C++中，这些转换通常比C语言中的转换提供了更好的类型检查和更明确的意图。

##### C语言中的强制类型转换运算符：

- 使用括号的类型转换（C-风格转换）：(类型名)(表达式名)

```c
int x;
double y = 10.5;
x = (int)y; // 显式类型转换为int
```

##### C++中新增的强制类型转换运算符：

C++提供了四种强制类型转换运算符，它们分别是：

- `static_cast<type>(expression)`：用于非多态类型的转换。
- `dynamic_cast<type>(expression)`：用于多态类型的转换，例如在类的继承体系中。
- `const_cast<type>(expression)`：用于添加或移除`const`或`volatile`属性。
- `reinterpret_cast<type>(expression)`：用于低层次的重新解释类型的转换，通常用于指针类型。

这些转换提供了比传统C风格转换更精细的控制，并且每种转换的用途和行为都有清晰的定义。

例如，使用`static_cast`进行基础数据类型的转换：

```cpp
double pi = 3.14159;
int whole_number = static_cast<int>(pi);
```

在使用这些C++专有的强制类型转换运算符时，它们会提供更严格的类型检查，这有助于防止某些类型的不安全转换，提高代码的安全性和可维护性。



## 2.运算符优先级

运算符的优先级决定了表达式中操作的执行顺序。以下是C/C++运算符按优先级从高到低排序的列表，同一行的运算符具有相同的优先级，并且在没有括号改变执行顺序的情况下，它们将按照从左到右的顺序被求值（除了赋值运算符和三元运算符是从右到左）。

1. `::` 解析运算符
2. `()` 函数调用    `[]` 数组下标    `.` 成员访问运算符    `->` 成员访问运算符    `++` 后缀自增    `--` 后缀自减    `typeid` 类型信息    `const_cast` 类型转换    `dynamic_cast` 类型转换    `static_cast` 类型转换    `reinterpret_cast` 类型转换
3. `++` 前缀自增    `--` 前缀自减    `+` 一元加法    `-` 一元减法    `!` 逻辑非    `~` 位非    `*` 解引用    `&` 取地址    `sizeof` 大小    `new` 动态内存分配    `new[]` 动态内存分配（数组）    `delete` 动态内存释放    `delete[]` 动态内存释放（数组）    `noexcept` 异常规范
4. `(type)` C风格强制转换
5. `.*` 成员对象指针访问运算符    `->*` 成员指针访问运算符
6. `*` 乘法    `/` 除法    `%` 取模
7. `+` 加法    `-` 减法
8. `<<` 左位移    `>>` 右位移
9. `<` 小于    `<=` 小于等于    `>` 大于    `>=` 大于等于
10. `==` 等于    `!=` 不等于
11. `&` 按位与
12. `^` 按位异或
13. `|` 按位或
14. `&&` 逻辑与
15. `||` 逻辑或
16. `?:` 三元条件运算符(也叫条件运算符)
17. `=` 赋值    `+=` 加后赋值    `-=` 减后赋值    `*=` 乘后赋值    `/=` 除后赋值    `%=` 模后赋值    `<<=` 左移后赋值    `>>=` 右移后赋值    `&=` 按位与后赋值    `^=` 按位异或后赋值    `|=` 按位或后赋值
18. `,` 逗号运算符

请注意，运算符优先级是编程语言的一个基本特征，通常在所有编译器中保持一致。为避免混淆，建议在复杂表达式中使用括号来明确运算顺序。

### 关系运算符和相等性运算符(也属于关系运算符)优先级比较

​	在C和C++中，关系运算符和相等性运算符确实有一些细微的区别在优先级上：

- **关系运算符** (`<`, `<=`, `>`, `>=`) 有比相等性运算符 (`==`, `!=`) 稍高的优先级。

​	这意味着在一个复合表达式中，比较大小的运算符将先于相等或不等的运算符被评估。这个细微的差异可以影响涉及这些运算符的表达式的评估顺序。

**示例**

考虑以下表达式：

```c
bool result = 5 > 4 == 3;  // 如何评估？
```

由于 `>` 的优先级高于 `==`，这个表达式实际上被解释为：

```c
bool result = (5 > 4) == 3;
```

​	这里，首先比较 `5 > 4`，结果为 `true`（在C++中，`true` 通常被表示为 `1`）。然后，`true` （或 `1`）与 `3` 进行比较，结果是 `false`，因为 `1` 不等于 `3`。

​	如果没有这种优先级规则，人们可能会错误地认为表达式的意图是比较 `4` 和 `3` 的大小，并查看 `5` 是否等于比较的结果，这显然会导致逻辑错误。

**结论**

​	确实，关系运算符和相等性运算符在优先级上是分开的，其中关系运算符 (`<`, `<=`, `>`, `>=`) 的优先级稍微高于相等性运算符 (`==`, `!=`)。这个优先级的设定是为了保证逻辑表达式中比较的自然顺序和清晰度，帮助避免可能的逻辑错误或误解。在编写涉及这些运算符的代码时，理解它们的优先级是非常重要的。

### 单独说明：成员访问运算符 .  和  ->

​	在C++中，成员访问运算符 . 和 -> 具有相同的优先级，并且这两个运算符的优先级都非常高，高于大多数其他运算符。它们的执行顺序通常取决于表达式的结构。

​	在 C++ 中，`->`（箭头运算符）和 `.`（点运算符）都用于成员访问，因此可以统称为成员访问运算符。具体来说：

- `.`（点运算符）：用于通过类的对象访问其成员（属性或方法）。
- `->`（箭头运算符）：用于通过指向类对象的指针访问对象的成员。

​	它们的功能是一样的，区别在于操作的对象不同（一个是实例，另一个是指针）。虽然 `.` 和 `->` 都被用于访问类的成员，它们在语法和使用上服务于相同的目的，但它们是两个不同的运算符。这两个运算符不能互换使用，它们的适用场景不同，`.`（点运算符）用于对象实例；`->`（箭头运算符）用于对象指针。因此，虽然它们都属于成员访问运算符且功能相似，它们是两个独立的、专用的运算符。

​	不存在直接比较 .（点运算符）和 ->（箭头运算符）优先级的情况，因为它们用于不同的上下文中。. 用于通过对象本身访问成员，而 -> 用于通过指向对象的指针来访问成员。在实际使用中，你不会在同一表达式中直接比较或混用这两个运算符的优先级，因为它们操作的对象类型（直接对象 vs. 对象指针）不同。因此，讨论这两个运算符的优先级更高是没有意义的。每个运算符都在它适用的上下文中使用，且没有交叉的场景需要比较它们的优先级。

​	举例：

```cpp
// .（点运算符） - 成员访问运算符：
// 用于访问对象的成员。当你有一个对象实例时，你可以使用点运算符直接访问其成员变量和成员函数。
MyClass obj;
obj.memberFunction(); // 调用成员函数
std::cout << obj.memberVariable; // 访问成员变量


// ->（箭头运算符） - 成员访问运算符：
// 当你有一个指向对象的指针而不是对象本身时，你使用箭头运算符来访问其成员。
MyClass* pObj = &obj;
pObj->memberFunction(); // 通过指针调用成员函数
std::cout << pObj->memberVariable; // 通过指针访问成员变量
```



### 单独说明：成员对象指针访问运算符.* 和 成员指针访问运算符->*

​	详细对比 `.*`（点星运算符）和 `->*`（箭头星运算符）这两个成员指针访问运算符：

#### (1)`.*`（点星运算符） - 成员对象指针访问运算符

- **用法**：当你有一个对象（而非指针）以及一个指向该对象成员的指针时，使用 `.*` 来通过对象访问这个成员。这个成员可以是成员变量或成员函数。与成员指针（特别是成员函数指针）一起使用，用于通过对象实例及成员指针来访问对象的(普通)成员(函数)。`.*` 用于对象实例(即.*运算符之前的那个对象实例)和成员指针（尤其是成员函数指针）之间的操作。

- 示例：

    ```cpp
    class MyClass {
    public:
        void myMemberFunc() { /* ... */ }
    };
    
    MyClass obj;
    void (MyClass::*funcPtr)() = &MyClass::myMemberFunc; // 成员函数指针
    (obj.*funcPtr)(); // 通过对象使用成员函数指针调用函数
    ```

#### (2)`->*`（箭头星运算符）- 成员指针访问运算符

- **用法**：当你有一个指向对象的指针以及一个指向该对象成员的指针时，使用 `->*` 来通过对象指针访问这个成员。同样，这个成员可以是成员变量或成员函数。用于通过对象的指针和成员指针来访问对象的(普通)成员(函数)。`->*` 用于对象指针(即->*运算符之前的那个指针)和成员指针之间的操作。

- 示例：

    ```cpp
    MyClass* pObj = &obj;
    (pObj->*funcPtr)(); // 通过对象指针使用成员函数指针调用函数
    ```

#### (3)相同点和不同点

- **相同点**：`.*` 和 `->*` 都用于结合对象（或对象指针）和成员指针来访问对象的成员。它们让你能够在运行时动态地选择对象的哪个成员进行操作。
- **不同点**：它们操作的对象类型不同——`.*` 用于直接对象实例，而 `->*` 用于对象的指针。这意味着，你不能将这两个运算符互换使用，它们各自适用于特定的上下文。

#### (4)优先级相同

与 `.` 和 `->` 的情形类似，`.*` 和 `->*` 也具有相同的优先级，并且它们的优先级低于 `.` 和 `->`。在没有明确括号指示的复杂表达式中，`.*` 和 `->*` 通常后于 `.` 和 `->` 被求值。

总的来说，虽然 `.*` 和 `->*` 的使用场景比 `.` 和 `->` 更少见，但它们为C++提供了强大的灵活性，允许开发者写出更抽象和动态的代码。在实践中，正确地使用这些运算符需要对它们的行为有深入的理解。就像 . 和 -> 运算符一样，.* 和 ->* 也服务于不同的上下文。.* 适用于直接对象实例，而 ->* 适用于对象的指针。在实际使用中，不会将这两个运算符混合在同一个表达式中进行优先级比较，因为它们分别操作不同类型的操作数（一个是实例，另一个是指针）。

因此，讨论 .* 和 ->* 之间的优先级哪个更高同样没有实际意义，每个运算符都在其特定的使用场景下发挥作用，没有直接的竞争或可比性。在编写代码时，选择使用哪个运算符完全取决于操作的对象类型（实例还是指针）以及你想要访问的成员类型。

#### (5)特别说明

成员对象指针访问运算符（`.*`）和成员指针访问运算符（`->*`）通常用于通过成员函数指针来访问类的成员函数。它们并不直接用于访问成员变量，无论是普通成员变量还是静态成员变量。这是因为这两个运算符的设计初衷是与指向成员的指针（尤其是成员函数指针）一起使用。

##### 一、类中的成员变量：

- 不能使用 `.*` 和 `->*` 运算符来直接访问类中的成员变量。访问成员变量通常使用 `.` 和 `->` 运算符。

```cpp
// 特殊场景
类中的一个成员变量,外面有个指针指向它
class MyClass {
public:
    void myMemberFunc() { /* ... */ }
    int a;
};
MyClass obj;
MyClass *ptr_obj = &obj;
int* ptr = &obj.a;// 这一行是正确的，正确地创建了一个指向 MyClass 类的成员变量 a 的指针
obj.*ptr = 100;// 这行是不正确的用法1
ptr_obj->*ptr;// 这行是不正确的用法2

//针对不正确的用法1的解释：
/*
代码片段尝试通过成员对象指针访问运算符 .* 来访问并修改类 MyClass 的成员变量 a 的值。然而，这个尝试是不正确的，因为它混淆了对成员变量的直接访问和通过成员指针访问成员函数或变量的语法。obj.*ptr = 100; 这一行尝试使用成员对象指针访问运算符 .* 来访问 ptr 指向的成员。问题在于，ptr 是一个指向 int 类型的普通指针，而不是一个指向成员的指针（如成员函数指针），因此这里的用法是不正确的。要修改 a 的值，你可以直接通过对象访问它,如：obj.a = 100;
如果想要使用指针来修改 a 的值，你可以直接通过指针进行：*ptr = 100;
成员指针（尤其是成员函数指针）的正确用法涉及到成员函数指针的声明和使用，而不是像上述尝试那样。如果你有一个指向成员函数的指针，那么可以使用 .* 或 ->* 运算符来调用该成员函数。但是对于直接的成员变量访问或修改，应直接通过对象或通过成员变量的指针进行，而无需使用 .* 运算符。
*/

//针对不正确的用法2的解释：
/*
对于 ptr_obj->*ptr;，这不是一个有效的语法，因为 ptr 是一个指向 int 类型的指针，而不是一个指向成员的指针（特别是不是成员函数指针）。->* 运算符应该与指向成员函数的指针一起使用，而不是用于普通的成员变量指针。要修改 a 的值，可以直接通过对象或对象指针访问 a，如：
直接通过对象访问和修改：obj.a = 100;
直接通过对象访问和修改：ptr_obj->a = 100;
如果持有一个指向成员变量的指针，可以直接通过解引用该指针来修改成员变量的值：*ptr = 100; // 正确地修改obj.a的值
*/

// 关于.* 和 ->*的正确使用方法见上边关于这两个运算符的使用举例
```



##### 二、类中的静态成员函数：

- 静态成员函数不依赖于类的实例，因此通常不需要通过对象或对象指针来访问。它们可以直接通过类名来访问。因此，使用 `.*` 和 `->*` 运算符来访问静态成员函数是不必要的，也不是这些运算符的预期用途。

##### 三、类中的静态成员变量：

- 类似地，静态成员变量也可以直接通过类名来访问，不需要通过对象或对象指针。因此，`.*` 和 `->*` 运算符也不用于访问静态成员变量。

##### 四、举例

- 虽然静态成员函数和静态成员变量不依赖于类的具体实例，可以直接通过类名进行访问，但从技术上讲，使用 .、->、.* 和 ->* 运算符来访问静态成员函数在语法上是允许的，不会导致编译错误。

例如：

```cpp
// 使用 . 和 -> 访问静态成员函数：
MyClass obj;
MyClass* pObj = &obj;

MyClass::staticMemberFunction();  // 通常的访问方式
obj.staticMemberFunction();       // 通过对象实例访问静态成员函数
pObj->staticMemberFunction();     // 通过对象指针访问静态成员函数
// 待对应添加此情况下访问静态成员变量的例子

// // // // // // // // // // // // // // // // // // // //
// 使用 .* 和 ->* 访问静态成员函数（虽然不常见，但也是可行的）：
void (*funcPtr)() = &MyClass::staticMemberFunction;  // 静态成员函数指针
(obj.*funcPtr)();  // 通过对象实例和成员函数指针调用静态成员函数
(pObj->*funcPtr)();  // 通过对象指针和成员函数指针调用静态成员函数
// 待对应添加此情况下访问静态成员变量的例子
```

​	然而，需要注意的是，即使这样的访问是可能的，使用对象实例或指针来访问静态成员（不管是变量还是函数）通常不是推荐的做法。这是因为静态成员属于类本身，而非类的某个实例，因此最清晰和直接的访问方式是通过类名。

​	使用对象实例或指针来访问静态成员可能会引起阅读代码的人的困惑，因为这样做模糊了成员是静态还是非静态的区别。因此，尽管语法上允许，但为了代码的清晰性和易于维护，推荐直接通过类名来访问静态成员。

##### 五、总结：

- `.*` 和 `->*` 主要用于通过对象（或对象指针）和成员函数指针来动态地访问类的成员函数。
- 访问成员变量（包括静态成员变量）或调用静态成员函数，通常不使用 `.*` 和 `->*`，而是直接使用类名、`.` 或 `->` 运算符，或者在静态成员函数的情况下，直接使用函数名进行调用。

这样的设计是基于面向对象编程中对对象实例成员和类静态成员访问方式的区分。静态成员属于类本身，而非类的某个特定实例，因此它们的访问方式与依赖实例的成员不同。



### 单独说明：解析运算符::

解析运算符（Scope Resolution Operator），在C++中表示为 `::`，用于定义或访问代码中的命名空间范围内的标识符，如类成员、命名空间成员或全局变量。

解析运算符有几个用途：

1. **访问全局变量**： 当局部变量名字与全局变量冲突时，可以使用解析运算符来访问全局变量。

   ```cpp
   int value = 10; // 全局变量
   
   int main() {
       int value = 5; // 局部变量
       std::cout << ::value; // 输出全局变量value，结果为10
       return 0;
   }
   ```

2. **访问类的静态成员**： 即使没有类的实例，也可以使用类名和解析运算符来访问其静态成员。

   ```cpp
   class MyClass {
   public:
       static int staticValue;
   };
   
   int MyClass::staticValue = 0;
   
   int main() {
       MyClass::staticValue = 5;
       std::cout << MyClass::staticValue; // 输出5
       return 0;
   }
   ```

3. **定义类之外的成员函数**： 在类的定义外部定义成员函数时，解析运算符用于指定函数所属的类。

   ```cpp
   class MyClass {
   public:
       void myFunction();
   };
   
   void MyClass::myFunction() {
       // 函数实现
   }
   ```

4. **指定命名空间中的元素**： 用于明确指定某个命名空间中的变量或函数。

   ```cpp
   namespace MyNamespace {
       int value;
   }
   
   int main() {
       MyNamespace::value = 10; // 明确指定命名空间
       return 0;
   }
   ```

在C语言中没有解析运算符，因为C语言不支持命名空间或类。解析运算符是C++中用来支持其更复杂类型系统和范围规则的特性。

## 3.自增自减运算符单独讨论

​	*后缀自增 ++ 和后缀自减 -- 的优先级高于前缀自增 ++ 和前缀自减 -- 的，其原因在于操作的顺序和结果。*

- ***后缀自增/自减（例如，`a++` 或 `a--`）**：首先返回变量的当前值，然后变量的值增加或减少。因此，在一个更复杂的表达式中，需要先评估变量的原始值，这就要求后缀版本的优先级更高。*
- ***前缀自增/自减（例如，`++a` 或 `--a`）**：首先增加或减少变量的值，然后返回变量的新值。前缀版本的变化是立即发生的，但是在一个表达式中，当它被用作另一个值的时候（例如 `b = ++a;`），整个表达式的结果依赖于已经改变的值。*

​	*由于后缀自增/自减要返回原始值，这需要在其他任何操作之前确定这个值，因此它们有更高的优先级。这样设计是为了确保表达式的值按预期那样被计算，不会因为其他运算符的运算而改变。*



​	*通过代码示例能更清晰地理解前置和后置自增/自减运算符的工作原理。下面是C++代码示例，演示了这两种运算符的不同行为：*

```cpp
#include <iostream>

int main() {
    int a = 5;
    int b = 5;
    
    // 前置自增
    // ++a 会先将a的值加1，然后返回a的新值。
    std::cout << "Original a: " << a << std::endl;
    std::cout << "Prefix ++a: " << ++a << std::endl; // a变为6，输出6
    std::cout << "After ++a, a: " << a << std::endl; // a是6

    // 后置自增
    // b++ 会先返回b的当前值，然后将b的值加1。
    std::cout << "\nOriginal b: " << b << std::endl;
    std::cout << "Postfix b++: " << b++ << std::endl; // 输出5，但b在表达式结束后变为6
    std::cout << "After b++, b: " << b << std::endl; // b是6

    return 0;
}

/**输出结果为：
*Original a: 5
*Prefix ++a: 6
*After ++a, a: 6
*
*Original b: 5
*Postfix b++: 5
*After b++, b: 6
*
*
**/
```

*这里的关键点是：*

​	*前置自增/自减 (++a 或 --a)：这种形式的运算符先修改变量的值，然后返回变量的新值。在上述例子中，++a 使 a 由5变为6，并立即返回6。*

​	*后置自增/自减 (a++ 或 a--)：这种形式的运算符先返回变量的当前值，然后再对变量进行修改。在上述例子中，b++ 首先返回 b 的原始值5，然后才将 b 由5增加到6。*

​	*理解这两种运算符的这种区别对于编写正确的C++代码是非常重要的，特别是当它们被用在复杂的表达式中时。在某些情况下，选择使用前置或后置自增/自减运算符可能会对代码的结果产生显著影响。*

### *前置和后置自增/自减运算符的内部实现原理：*

​	*前置和后置自增/自减运算符的内部实现原理实际上取决于它们是如何被编译器处理的。在C++中，编译器会为这些运算符提供不同的实现，以确保它们的行为符合定义。以下是这些运算符的一般实现方式：*

#### *前置自增/自减运算符（Prefix ++/--）*

​	*前置自增或自减运算符直接对操作数的值进行增加或减少，并返回操作后的引用。其内部工作机制大致如下：*

```cpp
// 假设operator++是一个类的成员函数
T& T::operator++() {
    *this += 1;     // 增加当前对象的值
    return *this;   // 返回当前对象的引用
}

// 直观例子
	// ++i
{
	i = i+1;
	return i;
}

	// --i
{
	i = i-1;
	return i;
}
```

#### *后置自增/自减运算符（Postfix ++/--）*

​	*后置自增或自减运算符在执行操作前先保存操作数的原始值，然后对操作数进行增加或减少，最后返回保存的原始值。其内部工作机制大致如下：*

```cpp
// 假设operator++(int)是一个类的成员函数，int参数用于区分后置版本
T T::operator++(int) {
    T temp = *this;  // 保存当前对象的副本
    *this += 1;      // 增加当前对象的值
    return temp;     // 返回保存的原始副本
}

// 直观例子
	// i++
{
    int temp;
    temp = i;
    i = i+1;
    return temp;
}

	// i--
{
    int temp;
    temp = i;
    i = i-1;
    return temp;
}
```

​	*在后置版本中，由于返回的是对象的副本而不是引用，因此后置运算符通常比前置运算符更耗费资源，因为它需要创建一个临时对象。*

​	*这些是运算符重载的概念性示例，展示了如何在用户定义的类型中实现这些运算符。内置类型的自增和自减运算符由编译器直接处理，通常是通过汇编语言指令来优化它们的性能。*

​	*在实际应用中，推荐使用前置自增/自减运算符，因为它们通常更高效，尤其是在涉及到复杂对象或迭代器时。后置版本由于需要创建临时对象，可能会引入额外的性能开销。*

### *double/float的++/--：*

​	*在C和C++中，`float` 和 `double` 类型的变量也可以使用 `++` 和 `--` 运算符。这些运算符不仅适用于整数类型，也适用于浮点类型，并且它们的行为与整数类型相似：*

- *对于 `float` 和 `double` 类型的变量，**前置自增 `++`** 运算符将变量的值增加 `1.0`，然后返回新值。*
- ***后置自增 `++`** 运算符先返回变量的当前值，然后将变量的值增加 `1.0`。*
- *同理，**前置自减 `--`** 运算符将变量的值减少 `1.0`，然后返回新值。*
- ***后置自减 `--`** 运算符先返回变量的当前值，然后将变量的值减少 `1.0`。*

​	*这里是一个简单的示例代码，展示了如何在 `float` 和 `double` 类型上使用这些运算符：*

```cpp
#include <iostream>

int main() {
    float f = 10.5f;
    double d = 10.5;

    std::cout << "Original float value: " << f << std::endl;
    std::cout << "Float value after ++: " << ++f << std::endl; // f becomes 11.5

    std::cout << "Original double value: " << d << std::endl;
    std::cout << "Double value after --: " << --d << std::endl; // d becomes 9.5

    return 0;
}
```

*输出将是：*

```bash
Original float value: 10.5
Float value after ++: 11.5
Original double value: 10.5
Double value after --: 9.5
```

​	*这意味着你完全可以对浮点数执行自增和自减操作，这在处理循环或需要递增/递减变量值的算法中可能很有用。在内部，这些运算符会对浮点数进行适当的加法和减法操作。*

### *额外说明：*

*优先级的规则并不直接反映操作的先后顺序，而是确定了在没有明确括号的情况下，表达式中各部分如何被组合或“绑定”在一起。后缀 `++/--`（自增/自减）运算符的优先级高于前缀 `++/--`，这主要是因为它们与操作数的结合方式不同。*

- ***后缀 `++/--`（自增/自减）**的高优先级意味着，当它们出现在表达式中时，它们会直接作用于紧邻的操作数。在它们作用的那一刻，返回操作数的原始值（然后操作数的值被增加或减少）。这个返回值可以直接用于表达式的其他部分。*
- ***前缀 `++/--`**由于优先级较低，它们通常在表达式的求值中稍后考虑（相对于后缀版本来说），但是实际上，由于它们和操作数之间的紧密结合，它们实际上在对操作数应用任何其他运算之前就已经修改了操作数的值，并返回修改后的值。*

*让我们用一个例子来说明为什么后缀 `++` 的优先级高于前缀 `++` 时，这种设计是有意义的：*

```
cppCopy codeint a = 5;
int b = a++; // 后缀自增，b = 5, 然后 a = 6
int c = ++a; // 前缀自增，a = 7, 然后 c = 7
```

*在这个例子中，`b = a++;` 需要先获取 `a` 的当前值（5），赋给 `b`，然后 `a` 的值自增。后缀自增的高优先级确保了这个操作是作为一个整体立即发生的，而不会被表达式中的其他操作所干扰。*

*对于 `int c = ++a;`，`a` 的值首先被增加，然后新值（7）被赋给 `c`。前缀自增虽然优先级低于后缀自增，但在实际表达式中，它直接作用于其操作数并且在进行其他操作之前就已经完成了值的修改。*

*总之，优先级规则是为了确保表达式中操作的组合方式符合逻辑和预期。后缀自增/自减的高优先级反映了它们紧密绑定到操作数并且能够立即返回操作数的原始值的特性，而前缀自增/自减直接修改值并返回新值，其相对优先级在语法分析中体现了不同的操作顺序和绑定方式。*

### *运算符优先级的定义：*

*优先级主要决定了在表达式中操作符与其操作数结合（即操作顺序）的紧密程度，也就是说，它决定了在没有括号明确指定顺序的情况下，哪些操作先执行，哪些后执行。每个操作符都有一个预定义的优先级，这个优先级决定了表达式的计算顺序。*

- ***高优先级的操作符**会先与其最近的操作数结合。例如，在表达式 `a + b * c` 中，乘法运算符 `*` 有比加法运算符 `+` 更高的优先级，所以先计算 `b * c`，然后结果与 `a` 相加。*
- ***同优先级的操作符**遵循特定的结合规则，通常是从左到右或从右到左。例如，加法运算符 `+` 和减法运算符 `-` 有相同的优先级，它们的结合顺序是从左到右，所以在表达式 `a - b + c` 中，会先计算 `a - b`，然后将结果与 `c` 相加。*
- ***操作数结合的顺序**指的是在给定操作符的情况下，操作数如何与操作符结合。例如，前缀自增 `++a` 中的 `++` 与其后的操作数 `a` 直接结合，表示先增加 `a` 的值，然后返回新值；而后缀自增 `a++` 中的 `++` 也与 `a` 结合，但表示先返回 `a` 的当前值，然后增加 `a` 的值。*

*优先级确保了在复杂表达式中，不需要过多的括号就能正确地解释操作的顺序。然而，为了提高代码的可读性，有时候在逻辑上明确无误的情况下添加括号来明确操作顺序是一个好习惯，尤其是当操作符优先级可能引起混淆时。*



​	*运算符的优先级决定了在表达式中操作符对操作数的绑定顺序，即在没有明确的括号指示顺序的情况下，哪些操作先被执行。这涉及到在复杂表达式中，各个操作符与其相邻操作数结合的紧密程度。所以，优先级确实影响了操作的顺序，但它更准确地描述的是操作符和操作数之间的结合关系。*

*对于后缀 ++/--（例如，a++、a--）和前缀 ++/--（例如，++a、--a）：*

​	*后缀 ++/-- 的优先级较高，意味着它们首先与其操作数结合。对于后缀形式，操作的效果是先返回操作数的当前值，然后再执行自增或自减操作。这确保了在复杂表达式中，即使周围有其他优先级较低的操作，后缀自增/自减也会优先应用于其直接操作数。*

​	*前缀 ++/--，虽然优先级相对较低（但仍然高于大多数其他操作），它们会直接对操作数执行自增或自减操作，然后返回操作后的新值。"优先级较低"的说法主要是与后缀版本相比较，但实际上，前缀自增/自减在应用时由于没有其他与之竞争的操作，所以它们直接作用于操作数并立即改变其值。*

​	*因此，优先级的概念确实涉及到了操作顺序，但更重要的是它定义了操作符如何与操作数结合，并因此间接影响了表达式内各部分的执行顺序。在实际编码时，理解这些区别有助于正确预测和控制复杂表达式的行为。*

### *其他1：*

​	*解释为何前缀 `++/--` 的运算符优先级相较于后缀 `++/--` 更低，主要是基于它们如何与操作数结合和表达式中的作用。但这里的表述需要澄清：实际上，前缀和后缀 `++/--` 的优先级之间的比较，更准确地说，是关于它们在表达式中的应用和效果，而不是优先级本身造成的直接影响。*

- ***后缀 `++/--`（例如，`a++` 或 `a--`）**：后缀版本的优先级高，意味着在涉及多个运算符的表达式中，后缀 `++/--` 会先于大多数其他运算符与其操作数结合。这种结合规则导致其先返回操作数的原始值，再执行自增或自减操作。后缀形式的优先级高，保证了在复杂表达式中，其行为（返回原始值）在任何其他操作之前得以保持。*
- ***前缀 `++/--`（例如，`++a` 或 `--a`）**：尽管前缀形式直接对操作数进行修改并返回修改后的值，但在讨论优先级的上下文中，"优先级较低"的表述可能引起混淆。实际上，前缀 `++/--` 的操作（修改值）在它作用的那一刻是优先执行的，但因为它不涉及与其他运算符的紧密结合顺序问题，所以通常我们不强调它的"优先级较低"。在实际使用中，前缀 `++/--` 的作用（即立即改变并返回新值）对于单独的操作数来说是明确的，而优先级主要影响的是多个运算符共同作用于同一操作数时的行为。*

*在实际编程中，前缀和后缀版本的 `++/--` 运算符的选择取决于你需要的操作效果（是需要操作前的值还是操作后的值）。在涉及到表达式求值顺序的讨论中，重要的是理解每种形式如何影响其操作数的值，以及这些变化如何被表达式中的其他运算符所使用。*

*因此，解释前缀和后缀形式的区别，以及它们在实际代码中的使用，应侧重于它们对操作数影响的时机和方式，而不仅仅是优先级的数值比较。优先级确实决定了运算的绑定顺序，但前缀和后缀版本的实际应用更多地反映在它们对操作数的即时影响上。*

### *其他2：*

​	*在同一个表达式中，确实可以同时出现前缀和后缀的 `++` 或 `--` 运算符，而且它们之间的优先级确实是有区别的。在 C 和 C++ 中，后缀版本（`a++`、`a--`）的优先级确实高于前缀版本（`++a`、`--a`）。这意味着在复杂的表达式中，如果同时存在，后缀运算符首先与其操作数结合，然后是前缀运算符。*

#### *为什么会有优先级的区别？*

​	*优先级的设置主要是为了确定在没有足够括号明确指示的情况下表达式的求值顺序。后缀 `++/--` 的较高优先级意味着它们在涉及多个不同类型运算符的表达式中会首先被求值。*

#### *同一个表达式中同时出现前缀和后缀*

​	*虽然技术上可能在同一个表达式中同时使用前缀和后缀形式的 `++` 或 `--`，但这样做可能会导致代码难以阅读和理解，因此并不推荐。例如：*

```c
int a = 5;
int result = ++a + a++; // 可能导致混淆和未定义的行为
```

​	*在这种情况下，`result` 的值取决于 `++a`（前缀增加）和 `a++`（后缀增加）的执行顺序，以及它们如何影响 `a` 的值。虽然优先级和运算符的结合规则可以决定这些运算符如何作用于其操作数，但当这样的操作在同一个表达式中混合使用时，它们可能导致难以预测的结果，尤其是当涉及到序列点和表达式的求值顺序时。*

#### *结论*

​	*在实践中，为了保持代码的清晰性和避免潜在的未定义行为，最好避免在同一表达式中同时使用前缀和后缀的自增或自减运算符。如果需要执行多步自增或自减操作，建议将它们分解为多个独立的语句。这样不仅能提高代码的可读性，也能避免由于求值顺序带来的潜在问题。*





进一步说明：

当我们讨论后缀自增 (`a++`) 和后缀自减 (`a--`) 与前缀自增 (`++a`) 和前缀自减 (`--a`) 的优先级时，事实上，后缀操作符的优先级是高于前缀操作符的。这不仅是因为它们直接影响表达式中的计算顺序，而且因为它们的行为特性在程序中的应用非常关键。

这一优先级的安排允许后缀操作符在涉及多个运算符的表达式中首先与它的操作数绑定，确保其操作（返回当前值，然后递增或递减）的正确性和预期效果。例如，在表达式 `int x = y++;` 中，后缀自增操作 `y++` 必须首先解析，以保证 `y` 的当前值被正确赋值给 `x`，然后 `y` 的值才进行增加。

这种安排是基于操作的语义和它们在实际编程中的应用效果：

1. **后缀自增/自减** 提供了一种操作，其中变量的原始值被用于表达式的计算，然后才更新该变量的值。这种“先用后改”的特性在迭代过程中特别有用，比如在使用迭代器或处理数组时。
2. **前缀自增/自减** 提供了一种操作，其中变量立即更新，然后新值用于任何进一步的表达式计算。这种“先改后用”的方式在需要立即使用更新值的情况下非常有用。

在编写代码时，选择使用前缀或后缀形式应基于所需的操作效果以及如何影响相关变量的值。使用前缀还是后缀可以影响代码的性能和逻辑流程，尤其在循环或条件语句中。

最后，虽然理解这些操作符的优先级对于编写有效和正确的代码非常重要，但在实际使用中，如果表达式可能导致混淆或错误，应考虑通过更清晰的代码结构或使用额外的变量和括号来明确操作顺序。这种做法不仅可以避免潜在的逻辑错误，还可以增加代码的可读性和可维护性。

到底优先级谁更高呢？

不要纠结无用、技术无用！！！！能拿到钱就好了



## 4.拓展问题：字符/字符串

对于大多数编程语言中的字符常量和字符变量，确实有一些通用的规则：

1. **使用单引号**：字符常量或字符变量通常用单引号（`'`）括起来，以区分字符串常量，后者通常用双引号（`"`）括起来。这个规则在如C、C++、Java等语言中是相通的。例如，`'a'`是一个字符常量，而`"a"`是一个字符串常量。
2. **存储单个字符**：`char`类型的变量确实是设计来存储单个字符的。这意味着在如C、C++、Java这样的语言中，一个`char`变量中不能存储多个字符。如果你尝试将多个字符赋值给`char`类型的变量，编译器会报错。

如果你需要存储多个字符，应该使用字符串类型，如C++中的`std::string`，Java中的`String`，或C语言中的字符数组（以`'\0'`结尾的字符序列）。

举个例子，以下是在C++中使用`char`和`std::string`的示例：

```cpp
// char类型变量存储单个字符
char c = 'a';

// std::string类型变量存储字符串（即多个字符）
std::string s = "hello";
```

在一些特定的上下文中，比如某些解释型语言或者脚本语言中，字符和字符串之间的区别可能不那么明显，但在编译型语言中，这个区别是很重要的。

​	在C语言（以及一些其他使用类似表示法的语言）中，字符串实际上是以`'\0'`（空字符，ASCII码为0）作为终结符的字符数组。这意味着，当你创建一个字符串时，计算机使用`'\0'`来标识字符串的结束位置。例如，字符串`"hello"`在内存中实际上被存储为`'h' 'e' 'l' 'l' 'o' '\0'`。这使得程序能够知道字符串何时结束，而不是无限制地读取内存。

​	对于单个字符来说，它仅占用内存中的一个字节（在大多数现代系统上），不需要结束符来标示其结束，因为它本身就是最小的数据单位。字符类型（`char`）的变量直接存储该字符的ASCII（或者在某些系统上可能是其他编码，如UTF-8）编码值。因此，单个字符并没有“末尾”的概念，它就是一个单独的字节。

简而言之：

- 字符串以`'\0'`结尾，这是用来标示字符串结束的特殊字符。
- 单个字符没有末尾，它由单个字节表示，直接存储该字符的编码值。

## 5.指针结合的const限定符的简单描述

### 1.常量指针(const (某某类型)* 变量名)

在C和C++中，常量指针的初始化取决于其声明的上下文：

- **局部变量**：如果`const`指针作为局部变量，建议在定义时初始化。这是因为未初始化的局部变量含有未定义的值，使用这样的指针可能导致不确定的行为。然而，技术上你可以先声明一个`const`指针，稍后再初始化，但这要求使用指向`const`的指针的指针（即`const`指针的地址），因为`const`指针一旦被赋值后就不能再被修改了。
- **全局变量或静态变量**：对于全局或静态作用域的`const`指针，如果你在声明时不初始化它，它将被自动初始化为`NULL`（在C++中是`nullptr`）。这是因为全局和静态变量自动初始化为零。

总的来说，尽管在某些情况下不立即初始化`const`指针是可能的，但最佳实践是在声明时就对其进行初始化，特别是对于局部作用域的`const`指针。

### 2. 指针的大小

指针占用的内存大小并不是固定的，它依赖于所用的操作系统和硬件架构，主要是CPU的位数。在32位系统上，所有指针的大小通常是4字节；而在64位系统上，指针的大小通常是8字节。这个规则适用于所有类型的指针，无论是指向基本数据类型还是复杂数据结构的指针。

这意味着，不管指针指向的是`int`、`float`、某个结构体还是其他什么，指针本身的大小是由其运行的系统架构决定的，与指针所指向的数据类型无关。

​	在给定的操作系统和硬件架构上，所有类型的指针通常都占用相同大小的内存空间。这个大小依赖于操作系统和处理器架构的地址空间设计。

**指针的大小**

- **32位系统**：在32位操作系统和处理器架构上，指针通常是32位（4字节）长。这是因为32位指针可以寻址最多 232232 个不同的地址，即4GB的内存空间。
- **64位系统**：在64位操作系统和处理器架构上，指针通常是64位（8字节）长。这样的指针可以寻址最多 264264 个不同的地址，这对于现代计算机系统中的大内存需求来说是必要的。

**指针类型不影响大小**

​	无论指针是指向`int`、`double`、`char`还是任何其他类型，甚至是复杂的类或结构体，它们的大小都是相同的。这是因为指针本质上是存储内存地址的变量，而内存地址的大小是由系统的地址寻址能力决定的，与指针所指向的数据类型无关。

**示例代码**

下面是一个C++示例，展示了不同类型指针的大小：

```cpp
#include <iostream>

int main() {
    int* pInt;
    double* pDouble;
    char* pChar;
    void* pVoid;

    std::cout << "Size of int* pointer: " << sizeof(pInt) << " bytes\n";
    std::cout << "Size of double* pointer: " << sizeof(pDouble) << " bytes\n";
    std::cout << "Size of char* pointer: " << sizeof(pChar) << " bytes\n";
    std::cout << "Size of void* pointer: " << sizeof(pVoid) << " bytes\n";

    return 0;
}
```

无论是在32位还是64位系统上运行，上述代码中的所有指针类型都会显示相同的大小。

结论

​	指针在同一操作系统和硬件架构上占用相同的内存空间，这一事实有助于简化内存管理和指针运算。理解这一点对于进行系统级编程或优化软件性能非常重要。

### 3.补充

​	指针的类型确实决定了该指针所指向的内存空间中存放内容的类型，这影响了你可以如何解引用指针以及指针运算的行为。下面是对你给出的三个例子的解释及它们之间的区别：

#### 1. `const char *p = "db";`

​	这个声明创建了一个指针`p`，它指向一个常量字符。这意味着通过`p`指针，你不能修改它所指向的内容。这里`p`指向的是一个字符串字面量（"db"），实际上是指向该字符串的第一个字符'd'的地址。字符串字面量在C和C++中是常量，所以你不能通过`p`来修改字符串内容，例如`p[0] = 'a';`是不允许的。

#### 2. `const char *p = "d";`

​	这与第一个例子类似，`p`是一个指向常量字符的指针，指向的内容是字符串"d"。和上面一样，你不能通过`p`修改所指向的内容。尽管字符串只有一个字符'd'（加上自动添加的终止符'\0'），`p`的使用和限制与第一个例子相同。

#### 3. `char *p = 'a';`

​	这个声明尝试将`p`初始化为指向字符'a'的地址，但这是不正确的。在C和C++中，字符常量（如'a'）是用单引号表示的，它们是整数（通常是ASCII码值），而不是指向字符的指针。正确的方式是将`p`指向一个字符变量，或者使用双引号来创建一个字符串字面量（即`char *p = "a";`），这样`p`会指向包含字符'a'和终止符'\0'的字符串的第一个字符。

#### 4.const char *p = 'a';

​	是不正确的。原因在于 `'a'` 是一个字符字面量，其类型是 `char`，而不是 `char*` 或 `const char*`。字符字面量在C和C++中实际上是整数类型（通常是其ASCII值），因此尝试将它赋给一个指向字符的指针是类型不匹配的。

正确的赋值应该使用双引号包围的字符串字面量，这样创建的是一个字符串，而不仅仅是单个字符。例如：

`const char *p = "a";`

​	这样，`p` 是一个指向常量字符的指针，指向的内容是字符串 `"a"`。这个字符串实际上包括了两个字符：`'a'` 和随后的空字符 `'\0'`，用来标记字符串的结束。这种方式正确地使用了指针，且符合 `const char*` 的期望类型。

#### 5.他们之间的主要区别

- **对内容的修改权限**：前两个例子中的`p`都是指向常量的指针，意味着你不能通过这些指针修改所指向的内容。第三个例子（如果正确声明为`char *p = "a";`）中的`p`则没有这样的限制，你可以通过`p`修改所指向的字符串，但尝试修改字符串字面量的内容是未定义行为，因为它们通常存储在只读存储段中。
- **正确性和类型匹配**：第三个例子原本的形式是不正确的，因为它尝试将一个字符常量（实际上是一个整数值）赋给一个字符指针，这是类型不匹配的。正确的声明应该使用字符串字面量或指向字符的指针。

总结一下，对于声明指针并赋值：

- 使用单引号 `' '` 包围的是单个字符字面量，它的类型是 `char`。
- 使用双引号 `" "` 包围的是字符串字面量，它的类型可以被解释为 `char*` 或 `const char*`（取决于上下文和具体用法），且指向的是字符串的第一个字符。
- 当你声明一个指向字符或字符数组（字符串）的指针时，应该使用双引号来初始化它指向的内容。

#### 6.总结

​	字符字面量在C和C++中实际上是整数类型（通常是其ASCII值），因此尝试将它赋给一个指向字符的指针是类型不匹配的。为什么？

​	答：在C和C++中，字符字面量（例如 `'a'`）被视为整数类型是由于历史和语言设计决策的结果。这种设计允许字符字面量在需要整数值的上下文中直接使用，而无需进行显式类型转换。每个字符字面量对应于其ASCII码（或在非ASCII系统上，对应于相应字符集中的等效数值）的整数值。这意味着，当你写下`'a'`，编译器实际上看到的是97（假设ASCII编码），这是字母`a`在ASCII编码中的数值。

​	当尝试将字符字面量赋给一个指针时，如`const char *p = 'a';`，这里的`'a'`实际上被视为一个整数（ASCII值为97）。因为`p`是一个指向`char`的指针，编译器期望的赋值应该是一个地址（即一个指针值），而不是一个整数。将整数赋给指针变量，没有通过显式类型转换，是类型不匹配的，因此这种代码会导致编译器错误。正确的一个示例：

> char *p = "a";
> const char *p1 = p;
>
> 1. **第一行**：`char *p = "a";`
>     这行代码创建了一个名为`p`的指针，指向一个字符数组（在这个上下文中，是一个字符串字面量"a"）。字符串字面量"a"实际上是两个字符的数组：`'a'` 和一个隐含的终止字符`'\0'`。在C++中，将字符串字面量赋值给`char*`类型的指针是不推荐的，因为字符串字面量存储在只读内存段中，而`char*`允许修改所指向的内容，这可能导致未定义行为。C语言中这样做较为常见，但C++中更安全的做法是使用`const char*`。
> 2. **第二行**：`const char *p1 = p;`
>     这行代码创建了一个名为`p1`的指针，它是指向常量字符的指针，意味着通过`p1`不能修改所指向的内容。在这里，`p1`被初始化为`p`的值，即它们都指向同一个字符串字面量。由于`p1`是`const char*`类型，这表明你不打算通过`p1`修改所指内容，这是合法且安全的。
>
> 这个例子展示了如何从非`const`指针向`const`指针的转换，这种转换是允许的，因为它增加了一个约束（即不修改所指向的内容），这使得代码更安全。然而，反过来（从`const char*`到`char*`的转换）则需要显式的类型转换，因为它涉及到去除了对所指内容的修改约束，这可能是危险的。
>
> 总的来说，这两行代码是一种正确的使用方式，尤其是在处理字符串字面量时，推荐使用`const char*`来避免潜在的修改只读内存的行为。



​	这种设计决策的背后逻辑是，C和C++将字符视为小整数，这样可以无缝地将它们用于数值计算，如字符编码转换或直接进行字符算术运算。例如，`'A' + 1`会得到`'B'`，因为`'A'`的ASCII值是65，加上1后变为66，即`'B'`的ASCII值。

​	总的来说，这种设计使得在处理字符和字符串时，C和C++程序可以非常灵活和高效，但也要求程序员了解字符和指针之间的区别，以及如何正确地在它们之间转换。
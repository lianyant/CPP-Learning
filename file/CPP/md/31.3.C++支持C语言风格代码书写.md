# C++支持C语言风格代码书写

​	在C++中完全支持C语言风格的代码书写，也就是说C语言的代码完全可以在C++中执行。

```cpp
#include <iostream>
using namespace std;
struct student
{
    char name[100];
    int number;
};
namespace std
{
    struct student cout1;
}

int main()
{
    std::cout1;
    // 或者 cout1;都可以
    return 0;
}
```

​	这里的namespace std {……}是在扩充std这个命名空间的内容。编译是成功的。

## 补充

再看如下代码：

```cpp
#include <iostream>
struct student
{
    char name[100];
    int number;
};
namespace std
{
    struct student cout1;
}
using namespace std;

int main()
{
    std::cout1;
    // 或者 cout1;都可以
    return 0;
}
```

和前面代码相比，两段代码的不同之处在于using namespace std; 的位置，这说明了什么？

​	这两段代码之间的主要区别：`using namespace std;` 的位置。在第一个例子中，`using namespace std;` 在定义结构体之前，而在第二个例子中，它在定义之后。然而，两个例子的执行效果是相同的，因为 `using namespace std;` 的作用仅是允许在当前作用域内直接访问命名空间中的名称，而不需要 `std::` 前缀。

这两个示例展示了以下几点：

1. **`using namespace` 的作用域**：
   - `using namespace std;` 引入了 `std` 命名空间中所有可访问的名称到当前作用域。不论 `using namespace std;` 出现在对命名空间内容的使用之前还是之后，只要它在使用这些名称的作用域内，那些名称就可以无需 `std::` 前缀被访问。

2. **对解析和可见性的影响**：
   - `using namespace std;` 并不影响命名空间中的定义。无论这条指令出现在添加新成员到命名空间之前还是之后，新的成员都会成功地添加到命名空间中。这条指令的存在与否不会影响到命名空间内部成员的定义。

3. **好的编程实践**：
   - 尽管这两段代码表明 `using namespace std;` 可以在定义之前或之后使用，但一般推荐将 `using namespace` 放在所有相关的命名空间定义之后。这样可以更清楚地看到哪些命名空间被使用，并且可以避免潜在的名称冲突或解析混淆。

4. **编码风格和维护性**：
   - 代码的可读性和维护性可以通过保持一致的命名空间使用指令和相关定义的顺序来提高。例如，将 `using namespace` 语句统一放在文件或作用域的顶部，紧接着是所有的类型定义和命名空间的修改，可以帮助后续维护者快速理解代码结构和依赖关系。

总之，这两个例子说明了 `using namespace` 的位置对于能否访问命名空间中的名称没有直接影响，但对于代码的组织和清晰度有重要作用。正确的使用和放置这些指令是良好编程风格和实践的一部分。

